namespace Trike {
	/**
	* Low level materials that do not contain any child materials. Typically generated by
	* other materials.
	*/
    export class PassMaterial extends MaterialMulti {
        public type: string;
        public parentMaterial: MaterialMulti;

		/**
		* Creates a new pass material instance
		*/
        constructor( type: string, parent: MaterialMulti ) {
            super( MultiMaterialOptions.None );
            this.type = type;
            this.parentMaterial = parent;
        }

		/**
		* Cleans up the material
		*/
        dispose() {
            super.dispose();
            this.parentMaterial = null;
        }

        /**
        * Use this function to set a uniform value on the material.
        * @param {string} name The name of the uniform
        * @param {any} val The new value of the uniform
        * @param {boolean} shared If true, then this value should be applied to all child materials
        */
        setUniform( name: string, val: any, shared: boolean = true ): UniformVar {
            const uniforms: { [ s: string ]: UniformVar; } = this._uniforms;
            const uniform = uniforms[ name ];
            const shaderTs = this.parentMaterial._shaderTextures;

            // If the value is exactly the same, then dont update anything
            if ( uniform.value === val )
                return uniform;

            // Remove old value from shader texture array
            if ( uniform.type === UniformType.TEXTURE && uniform.value instanceof ShaderTexture && shaderTs.indexOf( uniform.value ) !== -1 )
                shaderTs.splice( shaderTs.indexOf( uniform.value ), 1 );

            const toRet = super.setUniform( name, val, shared );

            // Check for shader textures
            if ( uniform.type === UniformType.TEXTURE && uniform.value instanceof ShaderTexture && shaderTs.indexOf( uniform.value ) === -1 )
                shaderTs.push( uniform.value );

            return toRet;
        }

		/**
		* Adds a uniform to this material. Will trigger the material to be re-built.
		*/
        addUniform( val: UniformVar, shared: boolean = true ) {
            super.addUniform( val, shared );
            const shaderTs = this.parentMaterial._shaderTextures;

            // Check for shader textures
            if ( val.type === UniformType.TEXTURE && val.value instanceof ShaderTexture && shaderTs.indexOf( val.value ) === -1 )
                shaderTs.push( val.value );
        }

		/**
		* Removes a uniform from this material. Will trigger the material to be re-built.
		*/
        removeUniform( name: string, shared: boolean = true ) {
            const uniform = this._uniforms[ name ];
            super.removeUniform( name, shared );
            const shaderTs = this.parentMaterial._shaderTextures;

            // Check for shader textures
            if ( uniform && uniform.type === UniformType.TEXTURE && uniform.value instanceof ShaderTexture && shaderTs.indexOf( uniform.value ) !== -1 )
                shaderTs.splice( shaderTs.indexOf( uniform.value ), 1 );
        }
    }
}