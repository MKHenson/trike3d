var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Trike;
(function (Trike) {
    /**
     * Internal class only used internally by the {EventDispatcher}
     */
    var EventListener = (function () {
        function EventListener(type, func, context) {
            this.type = type;
            this.func = func;
            this.context = context;
        }
        return EventListener;
    }());
    Trike.EventListener = EventListener;
    /**
     * A simple class that allows for the adding, removing and dispatching of events.
     */
    var EventDispatcher = (function () {
        function EventDispatcher() {
            this._listeners = [];
            this.disposed = false;
        }
        Object.defineProperty(EventDispatcher.prototype, "listeners", {
            /**
             * Returns the list of event listeners that are currently attached to this dispatcher.
             */
            get: function () {
                return this._listeners;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds a new listener to the dispatcher class.
         * @param type The event type we are sending
         * @param func The callback function
         * @param context [Optional] The context to call with
         */
        EventDispatcher.prototype.on = function (type, func, context) {
            if (!func)
                throw new Error('You cannot have an undefined function.');
            this._listeners.push(new EventListener(type, func, context));
        };
        /**
         * Adds a new listener to the dispatcher class.
         * @param type The event type we are sending
         * @param func The callback function
         * @param context [Optional] The context to call with
         */
        EventDispatcher.prototype.off = function (type, func, context) {
            var listeners = this.listeners;
            if (!listeners)
                return;
            if (!func)
                throw new Error('You cannot have an undefined function.');
            for (var i = 0, li = listeners.length; i < li; i++) {
                var l = listeners[i];
                if (l.type === type && l.func === func && l.context === context) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        /**
         * Sends a message to all listeners based on the eventType provided.
         * @param type The event type we are sending
         * @param data [Optional] The data to send with the emission
         */
        EventDispatcher.prototype.emit = function (type, data) {
            if (this._listeners.length === 0)
                return null;
            var listeners = this._listeners;
            var toRet = null;
            for (var _i = 0, _a = listeners; _i < _a.length; _i++) {
                var listener = _a[_i];
                if (listener.type === type) {
                    if (!listener.func)
                        throw new Error("A listener was added for " + type + ", but the function is not defined.");
                    toRet = listener.func.call(listener.context || this, type, data, this);
                }
            }
            return toRet;
        };
        /**
         * This will cleanup the component by nullifying all its variables and clearing up all memory.
         */
        EventDispatcher.prototype.dispose = function () {
            this._listeners.splice(0, this._listeners.length);
            this.disposed = true;
        };
        return EventDispatcher;
    }());
    Trike.EventDispatcher = EventDispatcher;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * The type of fog algorithm to use when drawing fog
    */
    (function (FogType) {
        FogType[FogType["None"] = 0] = "None";
        FogType[FogType["Linear"] = 1] = "Linear";
        FogType[FogType["Log"] = 2] = "Log";
        FogType[FogType["HeightBased"] = 3] = "HeightBased";
    })(Trike.FogType || (Trike.FogType = {}));
    var FogType = Trike.FogType;
    /**
    * Describes the tone mapping to use on the scene.
    * See:
    * http://alteredqualia.com/three/examples/webgl_deferred_postprocessing.html &
    * http://filmicgames.com/archives/75
    * http://www.slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting
    */
    (function (ToneMapper) {
        ToneMapper[ToneMapper["None"] = 0] = "None";
        ToneMapper[ToneMapper["Simple"] = 1] = "Simple";
        ToneMapper[ToneMapper["Linear"] = 2] = "Linear";
        ToneMapper[ToneMapper["Reinhard"] = 3] = "Reinhard";
        ToneMapper[ToneMapper["Filmic"] = 4] = "Filmic";
        ToneMapper[ToneMapper["Uncharted"] = 5] = "Uncharted";
    })(Trike.ToneMapper || (Trike.ToneMapper = {}));
    var ToneMapper = Trike.ToneMapper;
    /**
    * The quality of shadow filtering
    */
    (function (ShadowQuality) {
        ShadowQuality[ShadowQuality["Low"] = 0] = "Low";
        ShadowQuality[ShadowQuality["High"] = 1] = "High";
    })(Trike.ShadowQuality || (Trike.ShadowQuality = {}));
    var ShadowQuality = Trike.ShadowQuality;
    /**
    * Describes the type of shadow mapping filters to use
    */
    (function (ShadowSoftener) {
        ShadowSoftener[ShadowSoftener["None"] = 0] = "None";
        ShadowSoftener[ShadowSoftener["Interpolated"] = 1] = "Interpolated";
        ShadowSoftener[ShadowSoftener["PCF"] = 2] = "PCF";
        ShadowSoftener[ShadowSoftener["PCFSoft"] = 3] = "PCFSoft";
    })(Trike.ShadowSoftener || (Trike.ShadowSoftener = {}));
    var ShadowSoftener = Trike.ShadowSoftener;
    /**
    * The method used to sample the chrome texture
    */
    (function (ChromeDirection) {
        ChromeDirection[ChromeDirection["Reflective"] = 0] = "Reflective";
        ChromeDirection[ChromeDirection["Refractive"] = 1] = "Refractive";
    })(Trike.ChromeDirection || (Trike.ChromeDirection = {}));
    var ChromeDirection = Trike.ChromeDirection;
    /**
    * The method used to combine the chromal colors
    */
    (function (ChromeCombination) {
        ChromeCombination[ChromeCombination["Mix"] = 0] = "Mix";
        ChromeCombination[ChromeCombination["Multiply"] = 1] = "Multiply";
    })(Trike.ChromeCombination || (Trike.ChromeCombination = {}));
    var ChromeCombination = Trike.ChromeCombination;
    /**
    * The method used to combine the mirror samplers with other material colors
    */
    (function (MirrorMethod) {
        MirrorMethod[MirrorMethod["Mix"] = 0] = "Mix";
        MirrorMethod[MirrorMethod["Multiply"] = 1] = "Multiply";
    })(Trike.MirrorMethod || (Trike.MirrorMethod = {}));
    var MirrorMethod = Trike.MirrorMethod;
    /**
    * The method used to combine the refraction samplers with other material colors
    */
    (function (RefractionMethod) {
        RefractionMethod[RefractionMethod["Mix"] = 0] = "Mix";
        RefractionMethod[RefractionMethod["Multiply"] = 1] = "Multiply";
    })(Trike.RefractionMethod || (Trike.RefractionMethod = {}));
    var RefractionMethod = Trike.RefractionMethod;
    /**
    * Describes each the different passes the renderer uses when drawing the scene.
    */
    (function (PassType) {
        // Colors,
        PassType[PassType["GBuffer"] = 0] = "GBuffer";
        PassType[PassType["GBuffer2"] = 1] = "GBuffer2";
        PassType[PassType["PointsTextureMap"] = 2] = "PointsTextureMap";
        PassType[PassType["PointsNormalMap"] = 3] = "PointsNormalMap";
        PassType[PassType["Skybox"] = 4] = "Skybox";
        PassType[PassType["Composition"] = 5] = "Composition";
        PassType[PassType["Texture"] = 6] = "Texture";
        PassType[PassType["ScreenQuad"] = 7] = "ScreenQuad";
        PassType[PassType["Albedo"] = 8] = "Albedo";
        PassType[PassType["Lights"] = 9] = "Lights";
        PassType[PassType["EditorPass"] = 10] = "EditorPass";
        PassType[PassType["TerrainAlbedo"] = 11] = "TerrainAlbedo";
        PassType[PassType["ShadowLightPass"] = 12] = "ShadowLightPass";
        // ShadowLightSoftness,
        PassType[PassType["ShadowPass"] = 13] = "ShadowPass";
    })(Trike.PassType || (Trike.PassType = {}));
    var PassType = Trike.PassType;
    (function (SpriteLightingModel) {
        SpriteLightingModel[SpriteLightingModel["Basic"] = 0] = "Basic";
        SpriteLightingModel[SpriteLightingModel["Phong"] = 1] = "Phong";
    })(Trike.SpriteLightingModel || (Trike.SpriteLightingModel = {}));
    var SpriteLightingModel = Trike.SpriteLightingModel;
    /**
    * Describes the type of uniform
    */
    (function (UniformType) {
        UniformType[UniformType["TEXTURE"] = 0] = "TEXTURE";
        UniformType[UniformType["TEXTURE_CUBE"] = 1] = "TEXTURE_CUBE";
        UniformType[UniformType["FLOAT"] = 2] = "FLOAT";
        UniformType[UniformType["FLOAT2"] = 3] = "FLOAT2";
        UniformType[UniformType["FLOAT3"] = 4] = "FLOAT3";
        UniformType[UniformType["FLOAT4"] = 5] = "FLOAT4";
        UniformType[UniformType["QUAT"] = 6] = "QUAT";
        UniformType[UniformType["INT"] = 7] = "INT";
        UniformType[UniformType["COLOR3"] = 8] = "COLOR3";
        UniformType[UniformType["MAT3"] = 9] = "MAT3";
        UniformType[UniformType["MAT4"] = 10] = "MAT4";
        UniformType[UniformType["TEXTURE_ARRAY"] = 11] = "TEXTURE_ARRAY";
        UniformType[UniformType["INT_ARRAY"] = 12] = "INT_ARRAY";
        UniformType[UniformType["MAT3_ARRAY"] = 13] = "MAT3_ARRAY";
        UniformType[UniformType["MAT4_ARRAY"] = 14] = "MAT4_ARRAY";
        UniformType[UniformType["FLOAT_ARRAY"] = 15] = "FLOAT_ARRAY";
        UniformType[UniformType["FLOAT2_ARRAY"] = 16] = "FLOAT2_ARRAY";
        UniformType[UniformType["FLOAT3_ARRAY"] = 17] = "FLOAT3_ARRAY";
        UniformType[UniformType["FLOAT4_ARRAY"] = 18] = "FLOAT4_ARRAY";
    })(Trike.UniformType || (Trike.UniformType = {}));
    var UniformType = Trike.UniformType;
    /**
    * Describes the attribute type
    */
    (function (AttributeType) {
        AttributeType[AttributeType["POSITION"] = 0] = "POSITION";
        AttributeType[AttributeType["COLOR"] = 1] = "COLOR";
        AttributeType[AttributeType["TANGENT"] = 2] = "TANGENT";
        AttributeType[AttributeType["UV"] = 3] = "UV";
        AttributeType[AttributeType["UV2"] = 4] = "UV2";
        AttributeType[AttributeType["NORMAL"] = 5] = "NORMAL";
        AttributeType[AttributeType["SCREEN_CORNER_INDEX"] = 6] = "SCREEN_CORNER_INDEX";
        AttributeType[AttributeType["SKIN_INDEX"] = 7] = "SKIN_INDEX";
        AttributeType[AttributeType["SKIN_WEIGHT"] = 8] = "SKIN_WEIGHT";
        AttributeType[AttributeType["SCALE"] = 9] = "SCALE";
        AttributeType[AttributeType["ALPHA"] = 10] = "ALPHA";
        AttributeType[AttributeType["ROTATION"] = 11] = "ROTATION";
        AttributeType[AttributeType["SURFACE"] = 12] = "SURFACE";
        AttributeType[AttributeType["CUSTOM_1"] = 13] = "CUSTOM_1";
        AttributeType[AttributeType["CUSTOM_2"] = 14] = "CUSTOM_2";
        AttributeType[AttributeType["CUSTOM_3"] = 15] = "CUSTOM_3";
        AttributeType[AttributeType["CUSTOM_4"] = 16] = "CUSTOM_4";
        AttributeType[AttributeType["CUSTOM_5"] = 17] = "CUSTOM_5";
    })(Trike.AttributeType || (Trike.AttributeType = {}));
    var AttributeType = Trike.AttributeType;
    /**
    * Describes the floating point precision to be used in the shaders
    */
    var ShaderPrecision = (function () {
        function ShaderPrecision() {
        }
        ShaderPrecision.HIGH = 'highp';
        ShaderPrecision.MEDIUM = 'mediump';
        ShaderPrecision.LOW = 'lowp';
        return ShaderPrecision;
    }());
    Trike.ShaderPrecision = ShaderPrecision;
    /*
    * Describes how many components there are for each pixel.

    * See http://books.google.co.uk/books?id=3c-jmWkLNwUC&pg=PA80&lpg=PA80&dq=Int16Array+gl&source=bl&ots=z-tp2x2DAd&sig=2YW_MZ5s8HysyJIhIwTmVjc7QpU&hl=en&sa=X&ei=OSgcVKrpHcmxggSYmYJY&ved=0CCkQ6AEwAQ#v=onepage&q=Int16Array%20gl&f=false
    * PG 181

    *	Base Internal Format    red     green   blue    alpha   luminance
    *    --------------------    ---     -----   ----    -----   ---------
    *    ALPHA                                           A
    *    LUMINANCE                                               R
    *    LUMINANCE_ALPHA                                 A       R
    *    RGB                     R       G       B
    *    RGBA                    R       G       B       A
    */
    (function (TextureFormat) {
        TextureFormat[TextureFormat["AlphaFormat"] = 0] = "AlphaFormat";
        TextureFormat[TextureFormat["RGBFormat"] = 1] = "RGBFormat";
        TextureFormat[TextureFormat["RGBAFormat"] = 2] = "RGBAFormat";
        TextureFormat[TextureFormat["DepthStencil"] = 3] = "DepthStencil";
        TextureFormat[TextureFormat["DepthComponent"] = 4] = "DepthComponent";
        TextureFormat[TextureFormat["LuminanceFormat"] = 5] = "LuminanceFormat";
        TextureFormat[TextureFormat["LuminanceAlphaFormat"] = 6] = "LuminanceAlphaFormat";
    })(Trike.TextureFormat || (Trike.TextureFormat = {}));
    var TextureFormat = Trike.TextureFormat;
    /**
    * Describes how the texture should be mapped
    */
    (function (TextureMapping) {
        TextureMapping[TextureMapping["UVMapping"] = 0] = "UVMapping";
        TextureMapping[TextureMapping["ReflectionMapping"] = 1] = "ReflectionMapping";
    })(Trike.TextureMapping || (Trike.TextureMapping = {}));
    var TextureMapping = Trike.TextureMapping;
    /**
    * Describes how the texture should be wrapped around a polygon when it reaches the edge of the texture
    */
    (function (TextureWrapping) {
        TextureWrapping[TextureWrapping["RepeatWrapping"] = 0] = "RepeatWrapping";
        TextureWrapping[TextureWrapping["ClampToEdgeWrapping"] = 1] = "ClampToEdgeWrapping";
        TextureWrapping[TextureWrapping["MirroredRepeatWrapping"] = 2] = "MirroredRepeatWrapping";
    })(Trike.TextureWrapping || (Trike.TextureWrapping = {}));
    var TextureWrapping = Trike.TextureWrapping;
    /**
    * Describes how the texture should be filtered with distance
    */
    (function (TextureFilter) {
        TextureFilter[TextureFilter["Nearest"] = 0] = "Nearest";
        TextureFilter[TextureFilter["NearestMipMap"] = 1] = "NearestMipMap";
        TextureFilter[TextureFilter["NearestMipMapLinear"] = 2] = "NearestMipMapLinear";
        TextureFilter[TextureFilter["Linear"] = 3] = "Linear";
        TextureFilter[TextureFilter["LinearMipMap"] = 4] = "LinearMipMap";
        TextureFilter[TextureFilter["LinearMipMapNearest"] = 5] = "LinearMipMapNearest";
    })(Trike.TextureFilter || (Trike.TextureFilter = {}));
    var TextureFilter = Trike.TextureFilter;
    /**
    * These macros are used to control which parts of a shader are used.
    */
    var ShaderDefines = (function () {
        function ShaderDefines() {
        }
        // Set on materials that expect gl_POINTS
        ShaderDefines.POINT_VERTS = '#define POINT_VERTS';
        ShaderDefines.ATTR_ROTATION = '#define ATTR_ROTATION';
        ShaderDefines.ATTR_SIZE = '#define ATTR_SIZE';
        ShaderDefines.ATTR_ALPHA = '#define ATTR_ALPHA';
        ShaderDefines.ATTR_POSITION = '#define ATTR_POSITION';
        ShaderDefines.ATTR_COLOR = '#define ATTR_COLOR';
        ShaderDefines.ATTR_UV = '#define ATTR_UV';
        ShaderDefines.ATTR_NORMAL = '#define ATTR_NORMAL';
        ShaderDefines.ANIMATED = '#define ANIMATED';
        ShaderDefines.PREMULTIPLIED_ALPHA = '#define PREMULTIPLIED_ALPHA';
        ShaderDefines.ALPHA_TEST = '#define ALPHATEST';
        ShaderDefines.DOUBLE_SIDED = '#define DOUBLE_SIDED';
        ShaderDefines.BUMP_MAP = '#define USE_BUMPMAP';
        ShaderDefines.GAMA_INPUT = '#define GAMA_INPUT';
        ShaderDefines.BUMP_MAP_TILES = '#define USE_BUMPMAP_TILES';
        ShaderDefines.STANDARD_DERIVATIVES = '#define STANDARD_DERIVATIVES';
        ShaderDefines.QUAD_LIGHTING = '#define QUAD_LIGHTING';
        ShaderDefines.USE_ENV_MAP = '#define USE_ENV_MAP';
        ShaderDefines.REFLECTION_MAP = '#define REFLECTION_MAP';
        ShaderDefines.REFRACTION_MAP = '#define REFRACTION_MAP';
        ShaderDefines.SHADOW_MAPPING = '#define SHADOW_MAPPING';
        ShaderDefines.SHADOW_TYPE_VSM = '#define SHADOW_TYPE_VSM';
        ShaderDefines.EDITOR_PASS = '#define EDITOR_PASS';
        ShaderDefines.SHADOW_FILTER_INTERPOLATED = '#define SHADOW_FILTER_INTERPOLATED';
        ShaderDefines.SHADOW_FILTER_PCF = '#define SHADOW_FILTER_PCF';
        ShaderDefines.SHADOW_FILTER_PCF_SOFT = '#define SHADOW_FILTER_PCF_SOFT';
        ShaderDefines.DASHED = '#define DASH';
        ShaderDefines.SPECULAR_MAP = '#define USE_SPECULARMAP';
        ShaderDefines.TRANSLUCENCY_MAP = '#define TRANSLUCENCY_MAP';
        ShaderDefines.TRANSLUCENCY_ENABLED = '#define TRANSLUCENCY_ENABLED';
        ShaderDefines.FORWARD_NORMAL = '#define FORWARD_NORMAL';
        ShaderDefines.PASS_GBUFFER2 = '#define PASS_GBUFFER2';
        ShaderDefines.PASS_GBUFFER = '#define PASS_GBUFFER';
        ShaderDefines.PASS_POINT_MAP = '#define PASS_POINT_MAP';
        ShaderDefines.PASS_POINT_NORMAL = '#define PASS_POINT_NORMAL';
        ShaderDefines.PASS_SHADOW = '#define PASS_SHADOW';
        ShaderDefines.PASS_SHADOW_SOFTNESS = '#define PASS_SHADOW_SOFTNESS';
        ShaderDefines.BONE_INFLUENCES_1 = '#define BONE_INFLUENCES 1';
        ShaderDefines.BONE_INFLUENCES_2 = '#define BONE_INFLUENCES 2';
        ShaderDefines.BONE_INFLUENCES_3 = '#define BONE_INFLUENCES 3';
        ShaderDefines.BONE_INFLUENCES_4 = '#define BONE_INFLUENCES 4';
        ShaderDefines.SKINNING = '#define USE_SKINNING';
        ShaderDefines.USE_MAP = '#define USE_MAP';
        ShaderDefines.USE_HEIGHTFIELD = '#define USE_HEIGHTFIELD';
        ShaderDefines.DAY_MAP = '#define DAY_MAP';
        ShaderDefines.NIGHT_MAP = '#define NIGHT_MAP';
        // Terrain
        ShaderDefines.BRUSHMODE = '#define BRUSHMODE';
        ShaderDefines.TERRAIN_TEX_SPLAT = '#define TERRAIN_TEX_SPLAT';
        ShaderDefines.TERRAIN_TEX_BASE = '#define TERRAIN_TEX_BASE';
        ShaderDefines.TERRAIN_TEX_DIFF1 = '#define TERRAIN_TEX_DIFF1';
        ShaderDefines.TERRAIN_TEX_DIFF2 = '#define TERRAIN_TEX_DIFF2';
        ShaderDefines.TERRAIN_TEX_DIFF3 = '#define TERRAIN_TEX_DIFF3';
        ShaderDefines.TERRAIN_TEX_DIFF4 = '#define TERRAIN_TEX_DIFF4';
        ShaderDefines.TERRAIN_TEX_COLORS = '#define TERRAIN_TEX_COLORS';
        ShaderDefines.TERRAIN_TEX_LIGHTMAP = '#define TERRAIN_TEX_LIGHTMAP';
        return ShaderDefines;
    }());
    Trike.ShaderDefines = ShaderDefines;
    (function (TerrainTextureType) {
        TerrainTextureType[TerrainTextureType["Specular"] = 0] = "Specular";
        TerrainTextureType[TerrainTextureType["Splat"] = 1] = "Splat";
        TerrainTextureType[TerrainTextureType["Base"] = 2] = "Base";
        TerrainTextureType[TerrainTextureType["Rocks"] = 3] = "Rocks";
        TerrainTextureType[TerrainTextureType["Diffuse1"] = 4] = "Diffuse1";
        TerrainTextureType[TerrainTextureType["Diffuse2"] = 5] = "Diffuse2";
        TerrainTextureType[TerrainTextureType["Diffuse3"] = 6] = "Diffuse3";
        TerrainTextureType[TerrainTextureType["Diffuse4"] = 7] = "Diffuse4";
        TerrainTextureType[TerrainTextureType["Colors"] = 8] = "Colors";
        TerrainTextureType[TerrainTextureType["Lightmap"] = 9] = "Lightmap";
        TerrainTextureType[TerrainTextureType["Heightmap"] = 10] = "Heightmap";
    })(Trike.TerrainTextureType || (Trike.TerrainTextureType = {}));
    var TerrainTextureType = Trike.TerrainTextureType;
    /**
    * Describes how much space each component takes up in memory
    */
    (function (TextureType) {
        TextureType[TextureType["UnsignedByteType"] = 0] = "UnsignedByteType";
        TextureType[TextureType["UnsignedShort4444Type"] = 1] = "UnsignedShort4444Type";
        TextureType[TextureType["UnsignedShort5551Type"] = 2] = "UnsignedShort5551Type";
        TextureType[TextureType["UnsignedShort565Type"] = 3] = "UnsignedShort565Type";
        TextureType[TextureType["ByteType"] = 4] = "ByteType";
        TextureType[TextureType["ShortType"] = 5] = "ShortType";
        TextureType[TextureType["UnsignedShortType"] = 6] = "UnsignedShortType";
        TextureType[TextureType["IntType"] = 7] = "IntType";
        TextureType[TextureType["UnsignedIntType"] = 8] = "UnsignedIntType";
        TextureType[TextureType["FloatType"] = 9] = "FloatType";
        TextureType[TextureType["HalfFloatType"] = 10] = "HalfFloatType";
        TextureType[TextureType["UNSIGNED_INT_24_8_WEBGL"] = 11] = "UNSIGNED_INT_24_8_WEBGL";
    })(Trike.TextureType || (Trike.TextureType = {}));
    var TextureType = Trike.TextureType;
    /**
    * Describes how polygons are drawn by the renderer. Back is the default, which means vertices are drawn counter clockwise
    */
    (function (CullFormat) {
        CullFormat[CullFormat["None"] = 0] = "None";
        CullFormat[CullFormat["Front"] = 1] = "Front";
        CullFormat[CullFormat["Back"] = 2] = "Back";
        CullFormat[CullFormat["FrontAndBack"] = 3] = "FrontAndBack";
    })(Trike.CullFormat || (Trike.CullFormat = {}));
    var CullFormat = Trike.CullFormat;
    /**
    * Describes how to draw Lin Geometry
    */
    (function (LineMode) {
        LineMode[LineMode["HeadToTail"] = 0] = "HeadToTail";
        LineMode[LineMode["HeadToTailClosed"] = 1] = "HeadToTailClosed";
        LineMode[LineMode["Pairs"] = 2] = "Pairs";
    })(Trike.LineMode || (Trike.LineMode = {}));
    var LineMode = Trike.LineMode;
    /**
    * Describes how renderer should draw the geometry
    */
    (function (DrawMode) {
        /** draws each vertex as a single pixel dot...so if there are 24 vertices, you get 24 dots. */
        DrawMode[DrawMode["Points"] = 0] = "Points";
        /** connects each pair of vertices by a straight line, so 24 vertices produces 12 separate lines. */
        DrawMode[DrawMode["Lines"] = 1] = "Lines";
        /** connects each vertex to the next by a straight line, so 24 vertices produces 23 lines that are all connected end-to-end. */
        DrawMode[DrawMode["LineStrip"] = 2] = "LineStrip";
        /** LINELOOP is like LINESTRIP except that the last vertex is connected back to the first, so 24 vertices produces 24 straight lines - looping back to the start. */
        DrawMode[DrawMode["LineLoop"] = 3] = "LineLoop";
        /** connects each group of three consecutive vertices to make a triangle - so 24 vertices produces 8 separate triangles. */
        DrawMode[DrawMode["Triangles"] = 4] = "Triangles";
        /** TriangleStrip is a little harder to get your head around...let's letter our 24 vertices 'A' through 'X'. This produces N-2 triangles where N is the number of vertices...the first triangle connects vertices A,B,C, the remaining triangles are each formed from the previous two vertices of the last triangle...(swapped over to keep the triangle facing the same way) plus one new vertex, so the second triangle is C,B,D, the third is C,D,E, the fourth is E,D,F...all the way through to the 22nd triangle which is made from W,V,X. This sounds messy but imagine that you are drawing something like a long, winding ribbon - with vertices A,C,E,G down one side of the ribbon and B,D,F,H down the otherside. You'll need to sketch this one on some paper to get the hang of it. */
        DrawMode[DrawMode["TriangleStrip"] = 5] = "TriangleStrip";
        /** TriangleFan - similar in concept to the TriangleStrip but now we start with triangle A,B,C, then A,C,D, then A,D,E...and so on until A,W,X. The result looks like a ladies' fan. */
        DrawMode[DrawMode["TriangleFan"] = 6] = "TriangleFan";
    })(Trike.DrawMode || (Trike.DrawMode = {}));
    var DrawMode = Trike.DrawMode;
    /**
    * Defines the pixel factor in blending equations. There are two factors to consider - the source and destination.
    * Think of the source as the one that we're drawing right now,
    * and the destination fragment is the one that's already in the frame buffer.
    *
    * Typically the equation looks something like this:
    * Rresult = Rs * Sr + Rd * Dr
    * Gresult = Gs * Sg + Gd * Dg
    * Bresult = Bs * Sb + Bd * Db
    * Aresult = As * Sa + Ad * Da

    * Where Rs, Gs, Bs and As are the source factor and Sr, Sg, Sb, and Sa are the actual source values. Same can be said for the destination.
    * The above is using the add equation, but you can use other equations.
    */
    (function (PixelFactor) {
        PixelFactor[PixelFactor["DestinationColor"] = 0] = "DestinationColor";
        PixelFactor[PixelFactor["OneMinusDestinationColor"] = 1] = "OneMinusDestinationColor";
        PixelFactor[PixelFactor["SourceAlphaSaturate"] = 2] = "SourceAlphaSaturate";
        PixelFactor[PixelFactor["Zero"] = 3] = "Zero";
        PixelFactor[PixelFactor["One"] = 4] = "One";
        PixelFactor[PixelFactor["SourceColor"] = 5] = "SourceColor";
        PixelFactor[PixelFactor["OneMinusSourceColor"] = 6] = "OneMinusSourceColor";
        PixelFactor[PixelFactor["SourceAlpha"] = 7] = "SourceAlpha";
        PixelFactor[PixelFactor["OneMinusSourceAlpha"] = 8] = "OneMinusSourceAlpha";
        PixelFactor[PixelFactor["DestinationAlpha"] = 9] = "DestinationAlpha";
        PixelFactor[PixelFactor["OneMinusDestinationAlpha"] = 10] = "OneMinusDestinationAlpha";
        PixelFactor[PixelFactor["ConstantColor"] = 11] = "ConstantColor";
        PixelFactor[PixelFactor["OneMinusConstantColor"] = 12] = "OneMinusConstantColor";
        PixelFactor[PixelFactor["ConstantAlpha"] = 13] = "ConstantAlpha";
        PixelFactor[PixelFactor["OneMinusConstantAlpha"] = 14] = "OneMinusConstantAlpha";
    })(Trike.PixelFactor || (Trike.PixelFactor = {}));
    var PixelFactor = Trike.PixelFactor;
    /**
    * Determines the blending equation to use for calculating blended values. The most common is Add.
    */
    (function (BlendEquation) {
        BlendEquation[BlendEquation["Add"] = 0] = "Add";
        BlendEquation[BlendEquation["Subtract"] = 1] = "Subtract";
        BlendEquation[BlendEquation["ReverseSubtract"] = 2] = "ReverseSubtract";
    })(Trike.BlendEquation || (Trike.BlendEquation = {}));
    var BlendEquation = Trike.BlendEquation;
    /**
    * Determines the type of blending we do on a material. By default this is set to none. There are 3 modes to choose from that are
    * customly built. Alternatively you can use custom and define your own pixel factors and blend equation.
    */
    (function (BlendMode) {
        BlendMode[BlendMode["Normal"] = 0] = "Normal";
        BlendMode[BlendMode["Additive"] = 1] = "Additive";
        BlendMode[BlendMode["Subtractive"] = 2] = "Subtractive";
        BlendMode[BlendMode["Multiplication"] = 3] = "Multiplication";
        BlendMode[BlendMode["PremultipliedAlpha"] = 4] = "PremultipliedAlpha";
        BlendMode[BlendMode["Custom"] = 5] = "Custom";
        BlendMode[BlendMode["None"] = 6] = "None";
    })(Trike.BlendMode || (Trike.BlendMode = {}));
    var BlendMode = Trike.BlendMode;
    /**
    * Converts a Trike enum to its webgl equivalent
    */
    function getGLParam(e, gl) {
        switch (e) {
            /** Draw mode */
            case DrawMode.Points:
                return gl.POINTS;
            case DrawMode.Lines:
                return gl.LINES;
            case DrawMode.LineStrip:
                return gl.LINE_STRIP;
            case DrawMode.LineLoop:
                return gl.LINE_LOOP;
            case DrawMode.Triangles:
                return gl.TRIANGLES;
            case DrawMode.TriangleStrip:
                return gl.TRIANGLE_STRIP;
            case DrawMode.TriangleFan:
                return gl.TRIANGLE_FAN;
            /** Texture format */
            case TextureFormat.AlphaFormat:
                return gl.ALPHA;
            case TextureFormat.RGBFormat:
                return gl.RGB;
            case TextureFormat.RGBAFormat:
                return gl.RGBA;
            case TextureFormat.LuminanceFormat:
                return gl.LUMINANCE;
            case TextureFormat.LuminanceAlphaFormat:
                return gl.LUMINANCE_ALPHA;
            case TextureFormat.DepthStencil:
                return gl.DEPTH_STENCIL;
            case TextureFormat.DepthComponent:
                return gl.DEPTH_COMPONENT;
            /** Texture type */
            case TextureType.ByteType:
                return gl.BYTE;
            case TextureType.ShortType:
                return gl.SHORT;
            case TextureType.UnsignedShortType:
                return gl.UNSIGNED_SHORT;
            case TextureType.IntType:
                return gl.INT;
            case TextureType.UnsignedIntType:
                return gl.UNSIGNED_INT;
            case TextureType.FloatType:
                return gl.FLOAT;
            case TextureType.HalfFloatType:
                if (!Trike.Capabilities.getSingleton().glExtensionTextureHalfFloat)
                    return gl.FLOAT;
                return 0x8D61;
            case TextureType.UNSIGNED_INT_24_8_WEBGL:
                return 0x84FA;
            case TextureType.UnsignedByteType:
                return gl.UNSIGNED_BYTE;
            case TextureType.UnsignedShort4444Type:
                return gl.UNSIGNED_SHORT_4_4_4_4;
            case TextureType.UnsignedShort5551Type:
                return gl.UNSIGNED_SHORT_5_5_5_1;
            case TextureType.UnsignedShort565Type:
                return gl.UNSIGNED_SHORT_5_6_5;
            /** Texture filtering */
            case TextureFilter.Nearest:
                return gl.NEAREST;
            case TextureFilter.NearestMipMap:
                return gl.NEAREST_MIPMAP_NEAREST;
            case TextureFilter.NearestMipMapLinear:
                return gl.NEAREST_MIPMAP_LINEAR;
            case TextureFilter.Linear:
                return gl.LINEAR;
            case TextureFilter.LinearMipMapNearest:
                return gl.LINEAR_MIPMAP_NEAREST;
            case TextureFilter.LinearMipMap:
                return gl.LINEAR_MIPMAP_LINEAR;
            /** Texture Repeating */
            case TextureWrapping.RepeatWrapping:
                return gl.REPEAT;
            case TextureWrapping.ClampToEdgeWrapping:
                return gl.CLAMP_TO_EDGE;
            case TextureWrapping.MirroredRepeatWrapping:
                return gl.MIRRORED_REPEAT;
            /** Culling */
            case CullFormat.Back:
                return gl.BACK;
            case CullFormat.Front:
                return gl.FRONT;
            case CullFormat.FrontAndBack:
                return gl.FRONT_AND_BACK;
            /** Pixel modes */
            case PixelFactor.DestinationColor:
                return gl.DST_COLOR;
            case PixelFactor.OneMinusDestinationColor:
                return gl.ONE_MINUS_DST_COLOR;
            case PixelFactor.SourceAlphaSaturate:
                return gl.SRC_ALPHA_SATURATE;
            case PixelFactor.Zero:
                return gl.ZERO;
            case PixelFactor.One:
                return gl.ONE;
            case PixelFactor.SourceColor:
                return gl.SRC_COLOR;
            case PixelFactor.OneMinusSourceColor:
                return gl.ONE_MINUS_SRC_COLOR;
            case PixelFactor.One:
                return gl.ONE;
            case PixelFactor.SourceAlpha:
                return gl.SRC_ALPHA;
            case PixelFactor.OneMinusSourceAlpha:
                return gl.ONE_MINUS_SRC_ALPHA;
            case PixelFactor.DestinationAlpha:
                return gl.DST_ALPHA;
            case PixelFactor.OneMinusDestinationAlpha:
                return gl.ONE_MINUS_DST_ALPHA;
            case PixelFactor.ConstantColor:
                return gl.CONSTANT_COLOR;
            case PixelFactor.OneMinusConstantColor:
                return gl.ONE_MINUS_CONSTANT_COLOR;
            case PixelFactor.ConstantAlpha:
                return gl.CONSTANT_ALPHA;
            case PixelFactor.OneMinusConstantAlpha:
                return gl.ONE_MINUS_CONSTANT_ALPHA;
            /** Blend equation */
            case BlendEquation.Add:
                return gl.FUNC_ADD;
            case BlendEquation.Subtract:
                return gl.FUNC_SUBTRACT;
            case BlendEquation.ReverseSubtract:
                return gl.FUNC_REVERSE_SUBTRACT;
        }
        return -1;
    }
    Trike.getGLParam = getGLParam;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Collects data about the graphics card and its abilities.
    */
    var Capabilities = (function () {
        function Capabilities(gl) {
            this.flagUnusedUniforms = true;
            Capabilities._singleton = this;
            var precision = 2;
            this.glExtensionTextureFloat = gl.getExtension('OES_texture_float');
            this.glExtensionTextureFloatLinear = gl.getExtension('OES_texture_float_linear');
            this.glExtensionTextureHalfFloat = gl.getExtension('OES_texture_half_float');
            this.glExtensionTextureHalfFloatLinear = gl.getExtension('OES_texture_half_float_linear');
            this.glExtensionStandardDerivatives = gl.getExtension('OES_standard_derivatives');
            this.glExtensionTextureFilterAnisotropic = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
            this.glExtensionCompressedTextureS3TC = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
            if (gl.getShaderPrecisionFormat === undefined) {
                gl.getShaderPrecisionFormat = function () {
                    return {
                        'rangeMin': 1,
                        'rangeMax': 1,
                        'precision': 1
                    };
                };
            }
            this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            this.maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
            this.maxAnisotropy = this.glExtensionTextureFilterAnisotropic ? gl.getParameter(this.glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
            this.supportsVertexTextures = (this.maxVertexTextures > 0);
            this.supportsBoneTextures = this.supportsVertexTextures && this.glExtensionTextureFloat;
            this.compressedTextureFormats = this.glExtensionCompressedTextureS3TC ? gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS) : [];
            this.vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);
            this.vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);
            this.vertexShaderPrecisionLowpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT);
            this.fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
            this.fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);
            this.fragmentShaderPrecisionLowpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT);
            this.vertexShaderPrecisionHighpInt = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT);
            this.vertexShaderPrecisionMediumpInt = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT);
            this.vertexShaderPrecisionLowpInt = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT);
            this.fragmentShaderPrecisionHighpInt = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT);
            this.fragmentShaderPrecisionMediumpInt = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT);
            this.fragmentShaderPrecisionLowpInt = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT);
            // Allows us to use uints for index buffers
            this.uintIndices = gl.getExtension('OES_element_index_uint');
            // Check if we can render depth buffers to textures.
            this.depthTextureExt = gl.getExtension('WEBGL_depth_texture');
            if (!this.depthTextureExt) {
                this.depthTextureExt = gl.getExtension('WEBKIT_WEBGL_depth_texture');
                if (!this.depthTextureExt)
                    this.depthTextureExt = gl.getExtension('MOZ_WEBGL_depth_texture');
            }
            // Clamp precision to maximum available
            var highpAvailable = this.vertexShaderPrecisionHighpFloat.precision > 0 && this.fragmentShaderPrecisionHighpFloat.precision > 0;
            var mediumpAvailable = this.vertexShaderPrecisionMediumpFloat.precision > 0 && this.fragmentShaderPrecisionMediumpFloat.precision > 0;
            if (precision === 2 && !highpAvailable) {
                if (mediumpAvailable)
                    precision = 1;
                else
                    precision = 0;
            }
            if (precision === 1 && !mediumpAvailable)
                precision = 0;
            this.precision = precision;
        }
        /**
        * Gets the singleton of this class
        */
        Capabilities.getSingleton = function (gl) {
            if (!Capabilities._singleton)
                new Capabilities(gl);
            return Capabilities._singleton;
        };
        return Capabilities;
    }());
    Trike.Capabilities = Capabilities;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    var Utils = (function () {
        function Utils() {
        }
        Utils.addLineNumbers = function (error) {
            var chunks = error.split('\n');
            for (var i = 0, il = chunks.length; i < il; i++) {
                // Chrome reports shader errors on lines
                // starting counting from 1
                chunks[i] = (i + 1) + ': ' + chunks[i];
            }
            return chunks.join('\n');
        };
        Utils.checkFlag = function (value, reference) {
            return (value & reference) === reference;
        };
        Utils.error = function (message) {
            console.error(message);
        };
        Utils.compilerError = function (message, sourceCode) {
            console.error(message + '\r\n' + Utils.addLineNumbers(sourceCode));
        };
        return Utils;
    }());
    Trike.Utils = Utils;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A custom sorter based on the work done here: http://jsperf.com/sort-algorithms/28
    * This sorter is currently faster than the traditional sort function of arrays
    */
    var AdaptiveSort = (function () {
        function AdaptiveSort() {
        }
        AdaptiveSort.merge = function (left, right, prop) {
            /*
            * Given two non-empty ordered arrays (chains), returns a new
            * array containing an ordered union of the input chains.
            */
            var left_len = left.length, right_len = right.length, left_val, right_val, result;
            right_val = right[0];
            left_val = left[0];
            if (left[left_len - 1][prop] <= (right[0][prop])) {
                result = left.concat(right);
            }
            else if (right[right_len - 1][prop] < (left[0][prop])) {
                result = right.concat(left);
            }
            else {
                /* By this point, we know that the left and the right
                * arrays overlap by at least one element and simple
                * concatenation will not suffice to merge them. */
                result = new Array(left_len + right_len);
                var k = 0, h = 0;
                while (true) {
                    if (right_val[prop] < left_val[prop]) {
                        result[k + h] = right_val;
                        if (++h < right_len) {
                            right_val = right[h];
                        }
                        else {
                            while (k < left_len) {
                                result[k + h] = left[k++];
                            }
                            break;
                        }
                    }
                    else {
                        result[k + h] = left_val;
                        if (++k < left_len) {
                            left_val = left[k];
                        }
                        else {
                            while (h < right_len) {
                                result[k + h] = right[h++];
                            }
                            break;
                        }
                    }
                }
            }
            // setting array length to zero effectively removes the array from
            // memory (older versions of Firefox would leak unless these arrays
            // were reset).
            left.length = 0;
            right.length = 0;
            return result;
        };
        AdaptiveSort.find_fchain = function (arr, offset, limit, prop) {
            /*
            * Given an array and offset equal to indexOf(elA), find
            * the (indexOf(elZ) + 1) of an element elZ in the array,
            * such that all elements elA..elZ form a non-strict
            * forward-ordered chain.
            */
            var tmp, succ;
            for (tmp = arr[offset][prop]; ++offset < limit && tmp <= (succ = arr[offset][prop]); tmp = succ) { }
            return offset;
        };
        AdaptiveSort.find_strict_rchain = function (arr, offset, limit, prop) {
            /*
            * Given an array and offset equal to indexOf(elA), find
            * the (indexOf(elZ) + 1) of an element elZ in the array,
            * such that all elements elA..elZ form a strict
            * reverse-ordered chain.
            */
            var tmp, succ;
            for (tmp = arr[offset][prop]; ++offset < limit && (succ = arr[offset][prop]) < tmp; tmp = succ) { }
            return offset;
        };
        AdaptiveSort.chain_unit = function (arr, prop) {
            // Step 1: return an array of chain arrays
            // expecting data in reverse order
            var terminus, len = arr.length, tmp = [], f = AdaptiveSort.find_strict_rchain;
            for (var k = 0; k < len; k = terminus) {
                // try to find a chain (ordered sequence of at least
                // two elements) using a default function first:
                terminus = f(arr, k, len, prop);
                if (terminus - k > 1) {
                    tmp.push((f === AdaptiveSort.find_strict_rchain) ?
                        arr.slice(k, terminus).reverse() :
                        arr.slice(k, terminus));
                }
                else if (f === AdaptiveSort.find_strict_rchain) {
                    /* searched for a reverse chain and found none:
                    * switch default function to forward and look
                    * for a forward chain at k + 1: */
                    tmp.push(arr.slice(k, ++terminus));
                    f = AdaptiveSort.find_fchain;
                }
                else {
                    /* searched for a forward chain and found none:
                    * switch default function to reverse and look
                    * for a reverse chain at k + 1: */
                    tmp.push(arr.slice(k, ++terminus).reverse());
                    f = AdaptiveSort.find_strict_rchain;
                }
            }
            return tmp;
        };
        AdaptiveSort.chain_join = function (tmp, prop) {
            // Step 2: join all chains
            var j = tmp.length;
            if (j < 1) {
                return tmp;
            }
            // note: we reduce the size of the array after each iteration,
            // which is not really necessary (could be done at once at the end).
            for (; j > 1; tmp.length = j) {
                var k = void 0, lim = j - 2;
                // At this point, lim === tmp.length - 2, so tmp[k + 1]
                // is always defined for any k in [0, lim)
                for (j = 0, k = 0; k < lim; k = j << 1) {
                    tmp[j++] = AdaptiveSort.merge(tmp[k], tmp[k + 1], prop);
                }
                // Last pair is special -- its treatment depends on the initial
                // parity of j, which is the same as the current parity of lim.
                tmp[j++] = (k > lim) ? tmp[k] : AdaptiveSort.merge(tmp[k], tmp[k + 1], prop);
            }
            var result = tmp.shift();
            return result;
        };
        /**
        * Sorts an array of objects. You need to specify the property of the object we are comparing.
        * For example [ {age: 5}, {age : 8} ]. In this case the prop would be 'age'
        */
        AdaptiveSort.sort = function (arr, prop) {
            /* jshint bitwise: false */
            /* jshint noempty: false */
            'use strict';
            /**
            * Sorts an array of integers using the AdaptiveSort algorithm.
            * @param {Array.<number>} items Array of items to be sorted.
            */
            /*
            * Adaptive merge sort algorithm
            * Implementation: Eugene Scherba, 11/9/2010
            *
            * This is a stable sort algorithm, similar to merge sort except
            * that it takes advantage of partially ordered 'chains' (Donald
            * Knuth refers to these structures as 'runs'). Performance of this
            * algorithm is directly dependent on the amount of preexisting
            * partial ordering, however generally it is pretty good even on
            * completely random arrays.
            *
            * Time complexity: O(n) if array is already sorted,
            * O(n.log(n)) in a worst case which should be rare.
            * Space complexity: O(n) in worst case, usually around O(n/2).
            */
            // immutable version -- store result in a separate location
            return AdaptiveSort.chain_join(AdaptiveSort.chain_unit(arr, prop), prop);
            // mutable (standard) version -- store result in-place
            // var result = chain_join(chain_unit(arr));
            // for (var k = 0, len = arr.length; k < len; k++) {
            //    arr[k] = result[k];
            // }
            // result.length = 0;
            // return arr;
        };
        return AdaptiveSort;
    }());
    Trike.AdaptiveSort = AdaptiveSort;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A collection of useful math utils
    */
    var MathUtils = (function () {
        function MathUtils() {
        }
        /**
        * Converts from degrees to radians
        * @param {number} degrees
        * @returns {number}
        */
        MathUtils.degToRad = function (degrees) {
            return degrees * MathUtils.degreeToRadiansFactor;
        };
        /**
        * Converts from radians to degrees
        * @param {number} radians
        * @returns {number}
        */
        MathUtils.radToDeg = function (radians) {
            return radians * MathUtils.radianToDegreesFactor;
        };
        /**
        * Clamps a number x between a and b
        * @param {number} x
        * @param {number} a
        * @param {number} b
        * @returns {number}
        */
        MathUtils.clamp = function (x, a, b) {
            return (x < a) ? a : ((x > b) ? b : x);
        };
        /**
        * Gets the sign of a number
        * @param {number} x
        * @returns {number} -1 or 1
        */
        MathUtils.sign = function (x) {
            return (x < 0) ? -1 : (x > 0) ? 1 : 0;
        };
        /**
        * Checks if a number is a power of 2
        * @param {number} value
        * @returns {boolean}
        */
        MathUtils.isPowerOfTwo = function (value) {
            return (value & (value - 1)) === 0 && value !== 0;
        };
        /**
        * Smoothstep is a scalar interpolation function commonly used in computer graphics and video game engines.
        * The function interpolates smoothly between two input values based on a third one that should be
        * between the first two. The returned value is clamped between 0 and 1.
        * @param {number} min
        * @param {number} max
        * @param {number} value
        * @returns {number}
        */
        MathUtils.smoothstep = function (min, max, value) {
            var x = Math.max(0, Math.min(1, (value - min) / (max - min)));
            return x * x * (3 - 2 * x);
        };
        MathUtils.degreeToRadiansFactor = Math.PI / 180;
        MathUtils.radianToDegreesFactor = 180 / Math.PI;
        return MathUtils;
    }());
    Trike.MathUtils = MathUtils;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A Quaternion class for handling rotations in 3D.
    * Each Quat class also keeps an optional reference to an Euler object which can get updated each time the Quat is modified.
    */
    var Quat = (function () {
        /** Creates an instance of a Quat */
        function Quat(x, y, z, w) {
            this._x = x || 0;
            this._y = y || 0;
            this._z = z || 0;
            this._w = (w !== undefined) ? w : 1;
            this.elements = new Float32Array(4);
        }
        Object.defineProperty(Quat.prototype, "getElements", {
            get: function () {
                var elm = this.elements;
                elm[0] = this._x;
                elm[1] = this._y;
                elm[2] = this._z;
                elm[3] = this._w;
                return elm;
            },
            enumerable: true,
            configurable: true
        });
        /** Call this to update the internal euler object */
        Quat.prototype._updateEuler = function () {
            if (this._euler !== undefined) {
                this._euler.setFromQuaternion(this, undefined, false);
            }
        };
        Object.defineProperty(Quat.prototype, "x", {
            /**
            * Gets the x value of this Quat.
            * @returns {number}
            */
            get: function () {
                return this._x;
            },
            /**
            * Sets the x value of this Quat. This updates the internal euler object.
            * @param {number} value The x value
            */
            set: function (value) {
                this._x = value;
                this._updateEuler();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Quat.prototype, "y", {
            /**
            * Gets the y value of this Quat.
            * @returns {number}
            */
            get: function () {
                return this._y;
            },
            /**
            * Sets the y value of this Quat. This updates the internal euler object.
            * @param {number} value The y value
            */
            set: function (value) {
                this._y = value;
                this._updateEuler();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Quat.prototype, "z", {
            /**
            * Gets the z value of this Quat.
            * @returns {number}
            */
            get: function () {
                return this._z;
            },
            /**
            * Sets the z value of this Quat. This updates the internal euler object.
            * @param {number} value The z value
            */
            set: function (value) {
                this._z = value;
                this._updateEuler();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Quat.prototype, "w", {
            /**
            * Gets the w value of this Quat.
            * @returns {number}
            */
            get: function () {
                return this._w;
            },
            /**
            * Sets the w values of this Quat. This updates the internal euler object.
            * @param {number} value The w value
            */
            set: function (value) {
                this._w = value;
                this._updateEuler();
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Sets the values of this Quat
        * @param {number} x The x value
        * @param {number} y The y value
        * @param {number} z The z value
        * @param {number} w The w value
        * @returns {Quat}
        */
        Quat.prototype.set = function (x, y, z, w) {
            this._x = x;
            this._y = y;
            this._z = z;
            this._w = w;
            this._updateEuler();
            return this;
        };
        /**
        * Copies the values of a given Quat to this
        * @param {Quat} quaternion The Quat we are copying from
        * @returns {Quat}
        */
        Quat.prototype.copy = function (quaternion) {
            this._x = quaternion._x;
            this._y = quaternion._y;
            this._z = quaternion._z;
            this._w = quaternion._w;
            this._updateEuler();
            return this;
        };
        /**
        * Sets the values of this Quat from an Euler
        * See http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
        * @param {Euler} euler The Euler we are extracting values from
        * @param {boolean} update True if this operation should update the internal euler object of the Quat
        * @returns {Quat}
        */
        Quat.prototype.setFromEuler = function (euler, update) {
            var c1 = Math.cos(euler._x / 2);
            var c2 = Math.cos(euler._y / 2);
            var c3 = Math.cos(euler._z / 2);
            var s1 = Math.sin(euler._x / 2);
            var s2 = Math.sin(euler._y / 2);
            var s3 = Math.sin(euler._z / 2);
            if (euler.order === 'XYZ') {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            }
            else if (euler.order === 'YXZ') {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            }
            else if (euler.order === 'ZXY') {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            }
            else if (euler.order === 'ZYX') {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            }
            else if (euler.order === 'YZX') {
                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                this._w = c1 * c2 * c3 - s1 * s2 * s3;
            }
            else if (euler.order === 'XZY') {
                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                this._w = c1 * c2 * c3 + s1 * s2 * s3;
            }
            if (update !== false)
                this._updateEuler();
            return this;
        };
        /**
        * Sets the values of this Quat from a vector and its angle.
        * See http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
        * @param {Vec3} axis The axis mask. This must be normalized.
        * @param {number} angle The rotate amount in radians
        * @returns {Quat}
        */
        Quat.prototype.setFromAxisAngle = function (axis, angle) {
            var halfAngle = angle / 2, s = Math.sin(halfAngle);
            this._x = axis.x * s;
            this._y = axis.y * s;
            this._z = axis.z * s;
            this._w = Math.cos(halfAngle);
            this._updateEuler();
            return this;
        };
        /**
        * Sets the values of this Quat from a rotation matrix
        * @param {Matrix4} m The rotation matrix we are extracting values from.
        * @returns {Quat}
        */
        Quat.prototype.setFromRotationMatrix = function (m) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
            var s;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                this._w = 0.25 / s;
                this._x = (m32 - m23) * s;
                this._y = (m13 - m31) * s;
                this._z = (m21 - m12) * s;
            }
            else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                this._w = (m32 - m23) / s;
                this._x = 0.25 * s;
                this._y = (m12 + m21) / s;
                this._z = (m13 + m31) / s;
            }
            else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                this._w = (m13 - m31) / s;
                this._x = (m12 + m21) / s;
                this._y = 0.25 * s;
                this._z = (m23 + m32) / s;
            }
            else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                this._w = (m21 - m12) / s;
                this._x = (m13 + m31) / s;
                this._y = (m23 + m32) / s;
                this._z = 0.25 * s;
            }
            this._updateEuler();
            return this;
        };
        /**
        * Inverts this Quaternion
        * @returns {Quat}
        */
        Quat.prototype.inverse = function () {
            this.conjugate().normalize();
            return this;
        };
        /**
        * Conjugates this Quaternion (multiples by -1)
        * @returns {Quat}
        */
        Quat.prototype.conjugate = function () {
            this._x *= -1;
            this._y *= -1;
            this._z *= -1;
            this._updateEuler();
            return this;
        };
        /**
        * Returns the length squared of this Quaternion
        * @returns {number}
        */
        Quat.prototype.lengthSq = function () {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        };
        /**
        * Returns the length this Quaternion
        * @returns {number}
        */
        Quat.prototype.length = function () {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        };
        /**
        * Normalizes the values of this Quaternion. Making each of its components a value between 0 and 1
        * @returns {Quat}
        */
        Quat.prototype.normalize = function () {
            var l = this.length();
            if (l === 0) {
                this._x = 0;
                this._y = 0;
                this._z = 0;
                this._w = 1;
            }
            else {
                l = 1 / l;
                this._x = this._x * l;
                this._y = this._y * l;
                this._z = this._z * l;
                this._w = this._w * l;
            }
            return this;
        };
        /**
        * Multiplies this Quaternion with another
        * @returns {Quat}
        */
        Quat.prototype.multiply = function (q) {
            return this.multiplyQuaternions(this, q);
        };
        /**
        * Multiplies two Quaternions together and applies the result to this Quat.
        * @returns {Quat}
        */
        Quat.prototype.multiplyQuaternions = function (a, b) {
            // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
            var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
            var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
            this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
            this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
            this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
            this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
            this._updateEuler();
            return this;
        };
        /**
        * A form of linear interpolation between two quaternions
        * @param {Quat} qb The Quat we are interpolating to.
        * @param {number} t The weight between 0 and 1. 0 Means the quat is unchanged and 1 means its become qb
        * @returns {Quat}
        */
        Quat.prototype.slerp = function (qb, t) {
            if (t === 0)
                return this;
            if (t === 1)
                return this.copy(qb);
            var x = this._x, y = this._y, z = this._z, w = this._w;
            // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
            var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
            if (cosHalfTheta < 0) {
                this._w = -qb._w;
                this._x = -qb._x;
                this._y = -qb._y;
                this._z = -qb._z;
                cosHalfTheta = -cosHalfTheta;
            }
            else {
                this.copy(qb);
            }
            if (cosHalfTheta >= 1.0) {
                this._w = w;
                this._x = x;
                this._y = y;
                this._z = z;
                return this;
            }
            var halfTheta = Math.acos(cosHalfTheta);
            var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);
            if (Math.abs(sinHalfTheta) < 0.001) {
                this._w = 0.5 * (w + this._w);
                this._x = 0.5 * (x + this._x);
                this._y = 0.5 * (y + this._y);
                this._z = 0.5 * (z + this._z);
                return this;
            }
            var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
            this._w = (w * ratioA + this._w * ratioB);
            this._x = (x * ratioA + this._x * ratioB);
            this._y = (y * ratioA + this._y * ratioB);
            this._z = (z * ratioA + this._z * ratioB);
            this._updateEuler();
            return this;
        };
        /**
        * Checks if quaternion is equal
        * @param {Quat} quaternion The Quat we are testing against
        * @returns {boolean}
        */
        Quat.prototype.equals = function (quaternion) {
            return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);
        };
        /**
        * Builds a quaternion representing the rotation between two 3D vectors directions and applies the result
        * to this Quat.
        * @param {Vec3} vFrom The first vector
        * @param {Vec3} vTo The second vector
        * @returns {Quat}
        */
        Quat.prototype.setFromUnitVectors = function (vFrom, vTo) {
            // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
            // assumes direction vectors vFrom and vTo are normalized
            var v1, r;
            var EPS = 0.000001;
            if (v1 === undefined)
                v1 = new Trike.Vec3();
            r = vFrom.dot(vTo) + 1;
            if (r < EPS) {
                r = 0;
                if (Math.abs(vFrom.x) > Math.abs(vFrom.z))
                    v1.set(-vFrom.y, vFrom.x, 0);
                else
                    v1.set(0, -vFrom.z, vFrom.y);
            }
            else
                v1.crossVectors(vFrom, vTo);
            this.set(v1.x, v1.y, v1.z, r).normalize();
            this._updateEuler();
            return this;
        };
        /**
        * Builds this Quat from a 4 slot array
        * @param {Array<number>} array
        * @returns {Quat}
        */
        Quat.prototype.fromArray = function (array) {
            this._x = array[0];
            this._y = array[1];
            this._z = array[2];
            this._w = array[3];
            this._updateEuler();
            return this;
        };
        /**
        * Builds a 4 slot array from this Quat
        * @returns {Array<number>}
        */
        Quat.prototype.toArray = function () {
            return [this._x, this._y, this._z, this._w];
        };
        /**
        * Clones this Quat
        * @returns {Quat}
        */
        Quat.prototype.clone = function () {
            return new Quat(this._x, this._y, this._z, this._w);
        };
        /**
        * Performs a form linear interpolation of between 2 Quats
        * @param {Quat} from The Quat we are interpolating from
        * @param {Quat} to The Quat we are interpolating towards
        * @param {Quat} out The Quat we are storing the new orientation in
        * @param {number} t The weight between 0 and 1.
        * @returns {Quat}
        */
        Quat.slerp = function (from, to, out, t) {
            return out.copy(from).slerp(to, t);
        };
        return Quat;
    }());
    Trike.Quat = Quat;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    var Matrix3 = (function () {
        function Matrix3(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
            this.elements = new Float32Array(9);
            this.set((n11 !== undefined) ? n11 : 1, n12 || 0, n13 || 0, n21 || 0, (n22 !== undefined) ? n22 : 1, n23 || 0, n31 || 0, n32 || 0, (n33 !== undefined) ? n33 : 1);
        }
        Matrix3.prototype.set = function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
            var te = this.elements;
            te[0] = n11;
            te[3] = n12;
            te[6] = n13;
            te[1] = n21;
            te[4] = n22;
            te[7] = n23;
            te[2] = n31;
            te[5] = n32;
            te[8] = n33;
            return this;
        };
        Matrix3.prototype.identity = function () {
            this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
            return this;
        };
        Matrix3.prototype.copy = function (m) {
            var me = m.elements;
            this.set(me[0], me[3], me[6], me[1], me[4], me[7], me[2], me[5], me[8]);
            return this;
        };
        Matrix3.prototype.multiplyScalar = function (s) {
            var te = this.elements;
            te[0] *= s;
            te[3] *= s;
            te[6] *= s;
            te[1] *= s;
            te[4] *= s;
            te[7] *= s;
            te[2] *= s;
            te[5] *= s;
            te[8] *= s;
            return this;
        };
        Matrix3.prototype.determinant = function () {
            var te = this.elements;
            var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
            return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
        };
        Matrix3.prototype.getInverse = function (matrix, throwOnInvertible) {
            if (throwOnInvertible === void 0) { throwOnInvertible = false; }
            // input: THREE.Matrix4
            // ( based on http://code.google.com/p/webgl-mjs/ )
            var me = matrix.elements;
            var te = this.elements;
            te[0] = me[10] * me[5] - me[6] * me[9];
            te[1] = -me[10] * me[1] + me[2] * me[9];
            te[2] = me[6] * me[1] - me[2] * me[5];
            te[3] = -me[10] * me[4] + me[6] * me[8];
            te[4] = me[10] * me[0] - me[2] * me[8];
            te[5] = -me[6] * me[0] + me[2] * me[4];
            te[6] = me[9] * me[4] - me[5] * me[8];
            te[7] = -me[9] * me[0] + me[1] * me[8];
            te[8] = me[5] * me[0] - me[1] * me[4];
            var det = me[0] * te[0] + me[1] * te[3] + me[2] * te[6];
            // no inverse
            if (det === 0) {
                var msg = 'Matrix3.getInverse(): can\'t invert matrix, determinant is 0';
                if (throwOnInvertible || false) {
                    throw new Error(msg);
                }
                else {
                    console.warn(msg);
                }
                this.identity();
                return this;
            }
            this.multiplyScalar(1.0 / det);
            return this;
        };
        Matrix3.prototype.transpose = function () {
            var tmp, m = this.elements;
            tmp = m[1];
            m[1] = m[3];
            m[3] = tmp;
            tmp = m[2];
            m[2] = m[6];
            m[6] = tmp;
            tmp = m[5];
            m[5] = m[7];
            m[7] = tmp;
            return this;
        };
        Matrix3.prototype.getNormalMatrix = function (m) {
            // input: THREE.Matrix4
            this.getInverse(m).transpose();
            return this;
        };
        Matrix3.prototype.transposeIntoArray = function (r) {
            var m = this.elements;
            r[0] = m[0];
            r[1] = m[3];
            r[2] = m[6];
            r[3] = m[1];
            r[4] = m[4];
            r[5] = m[7];
            r[6] = m[2];
            r[7] = m[5];
            r[8] = m[8];
            return this;
        };
        Matrix3.prototype.clone = function () {
            var te = this.elements;
            return new Matrix3(te[0], te[3], te[6], te[1], te[4], te[7], te[2], te[5], te[8]);
        };
        Object.defineProperty(Matrix3.prototype, "getElements", {
            /**
            * Gets the Float32Array representation of this vector
            * @returns {Float32Array}
            */
            get: function () {
                return this.elements;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Checks if this matrxi is equal to ref by checking each element
        * @param {Matrix4} ref
        * @returns {boolean}
        */
        Matrix3.prototype.equals = function (ref) {
            var te = this.elements;
            var re = ref.elements;
            if (te[0] !== re[0])
                return false;
            if (te[1] !== re[1])
                return false;
            if (te[2] !== re[2])
                return false;
            if (te[3] !== re[3])
                return false;
            if (te[4] !== re[4])
                return false;
            if (te[5] !== re[5])
                return false;
            if (te[6] !== re[6])
                return false;
            if (te[7] !== re[7])
                return false;
            if (te[8] !== re[8])
                return false;
            return true;
        };
        return Matrix3;
    }());
    Trike.Matrix3 = Matrix3;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A simple Matrix4
    */
    var Matrix4 = (function () {
        /**
        * Creates an instance of a Matrix4
        */
        function Matrix4(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
            var te = this.elements = new Float32Array(16);
            te[0] = (n11 !== undefined) ? n11 : 1;
            te[4] = n12 || 0;
            te[8] = n13 || 0;
            te[12] = n14 || 0;
            te[1] = n21 || 0;
            te[5] = (n22 !== undefined) ? n22 : 1;
            te[9] = n23 || 0;
            te[13] = n24 || 0;
            te[2] = n31 || 0;
            te[6] = n32 || 0;
            te[10] = (n33 !== undefined) ? n33 : 1;
            te[14] = n34 || 0;
            te[3] = n41 || 0;
            te[7] = n42 || 0;
            te[11] = n43 || 0;
            te[15] = (n44 !== undefined) ? n44 : 1;
            if (!Matrix4._t1) {
                Matrix4._t1 = new Trike.Vec3();
                Matrix4._t2 = new Trike.Vec3();
                Matrix4._t3 = new Trike.Vec3();
            }
        }
        /**
        * Sets the matrix from values
        * @returns {Matrix4}
        */
        Matrix4.prototype.set = function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
            var te = this.elements;
            te[0] = n11;
            te[4] = n12;
            te[8] = n13;
            te[12] = n14;
            te[1] = n21;
            te[5] = n22;
            te[9] = n23;
            te[13] = n24;
            te[2] = n31;
            te[6] = n32;
            te[10] = n33;
            te[14] = n34;
            te[3] = n41;
            te[7] = n42;
            te[11] = n43;
            te[15] = n44;
            return this;
        };
        /**
        * Sets this matrix to an indentity matrix
        * @returns {Matrix4}
        */
        Matrix4.prototype.identity = function () {
            this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
        };
        /**
        * Copies the values of matrix m to this matrix
        * @param {Matrix4} m The matrix to copy from
        * @returns {Matrix4}
        */
        Matrix4.prototype.copy = function (m) {
            this.elements.set(m.elements);
            return this;
        };
        /**
        * Copies the position from one matrix into this
        * @param {Matrix4} m
        * @returns {Matrix4}
        */
        Matrix4.prototype.copyPosition = function (m) {
            var te = this.elements;
            var me = m.elements;
            te[12] = me[12];
            te[13] = me[13];
            te[14] = me[14];
            return this;
        };
        /**
        * Extracts rotation from a matrix
        * @param {Matrix4} m
        * @returns {Matrix4}
        */
        Matrix4.prototype.extractRotation = function (m) {
            var v1 = Matrix4._t1;
            var te = this.elements;
            var me = m.elements;
            var scaleX = 1 / v1.set(me[0], me[1], me[2]).length();
            var scaleY = 1 / v1.set(me[4], me[5], me[6]).length();
            var scaleZ = 1 / v1.set(me[8], me[9], me[10]).length();
            te[0] = me[0] * scaleX;
            te[1] = me[1] * scaleX;
            te[2] = me[2] * scaleX;
            te[4] = me[4] * scaleY;
            te[5] = me[5] * scaleY;
            te[6] = me[6] * scaleY;
            te[8] = me[8] * scaleZ;
            te[9] = me[9] * scaleZ;
            te[10] = me[10] * scaleZ;
            return this;
        };
        /**
        * Creates a rotation at matrix from an Euler
        * @param {Euler} euler
        * @returns {Matrix4}
        */
        Matrix4.prototype.makeRotationFromEuler = function (euler) {
            var te = this.elements;
            var x = euler.x, y = euler.y, z = euler.z;
            var a = Math.cos(x), b = Math.sin(x);
            var c = Math.cos(y), d = Math.sin(y);
            var e = Math.cos(z), f = Math.sin(z);
            if (euler.order === 'XYZ') {
                var ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e;
                te[4] = -c * f;
                te[8] = d;
                te[1] = af + be * d;
                te[5] = ae - bf * d;
                te[9] = -b * c;
                te[2] = bf - ae * d;
                te[6] = be + af * d;
                te[10] = a * c;
            }
            else if (euler.order === 'YXZ') {
                var ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce + df * b;
                te[4] = de * b - cf;
                te[8] = a * d;
                te[1] = a * f;
                te[5] = a * e;
                te[9] = -b;
                te[2] = cf * b - de;
                te[6] = df + ce * b;
                te[10] = a * c;
            }
            else if (euler.order === 'ZXY') {
                var ce = c * e, cf = c * f, de = d * e, df = d * f;
                te[0] = ce - df * b;
                te[4] = -a * f;
                te[8] = de + cf * b;
                te[1] = cf + de * b;
                te[5] = a * e;
                te[9] = df - ce * b;
                te[2] = -a * d;
                te[6] = b;
                te[10] = a * c;
            }
            else if (euler.order === 'ZYX') {
                var ae = a * e, af = a * f, be = b * e, bf = b * f;
                te[0] = c * e;
                te[4] = be * d - af;
                te[8] = ae * d + bf;
                te[1] = c * f;
                te[5] = bf * d + ae;
                te[9] = af * d - be;
                te[2] = -d;
                te[6] = b * c;
                te[10] = a * c;
            }
            else if (euler.order === 'YZX') {
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e;
                te[4] = bd - ac * f;
                te[8] = bc * f + ad;
                te[1] = f;
                te[5] = a * e;
                te[9] = -b * e;
                te[2] = -d * e;
                te[6] = ad * f + bc;
                te[10] = ac - bd * f;
            }
            else if (euler.order === 'XZY') {
                var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                te[0] = c * e;
                te[4] = -f;
                te[8] = d * e;
                te[1] = ac * f + bd;
                te[5] = a * e;
                te[9] = ad * f - bc;
                te[2] = bc * f - ad;
                te[6] = b * e;
                te[10] = bd * f + ac;
            }
            // last column
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;
            // bottom row
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;
            return this;
        };
        /**
        * Creates a rotation matrix from a quaternion
        * @param {Quat} q
        * @returns {Matrix4}
        */
        Matrix4.prototype.makeRotationFromQuaternion = function (q) {
            var te = this.elements;
            var x = q.x, y = q.y, z = q.z, w = q.w;
            var x2 = x + x, y2 = y + y, z2 = z + z;
            var xx = x * x2, xy = x * y2, xz = x * z2;
            var yy = y * y2, yz = y * z2, zz = z * z2;
            var wx = w * x2, wy = w * y2, wz = w * z2;
            te[0] = 1 - (yy + zz);
            te[4] = xy - wz;
            te[8] = xz + wy;
            te[1] = xy + wz;
            te[5] = 1 - (xx + zz);
            te[9] = yz - wx;
            te[2] = xz - wy;
            te[6] = yz + wx;
            te[10] = 1 - (xx + yy);
            // last column
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;
            // bottom row
            te[12] = 0;
            te[13] = 0;
            te[14] = 0;
            te[15] = 1;
            return this;
        };
        /**
        * Creates a look at matrix  from the eye, target and up vectors
        * @param {Vec3} eye The camera position
        * @param {Vec3} target The position to look at
        * @param {Vec3} up The up vector of the camera
        * @returns {Matrix4}
        */
        Matrix4.prototype.lookAt = function (eye, target, up) {
            var te = this.elements;
            var x = Matrix4._t1;
            var y = Matrix4._t2;
            var z = Matrix4._t3;
            z.subVectors(eye, target).normalize();
            if (z.length() === 0) {
                z.z = 1;
            }
            x.crossVectors(up, z).normalize();
            if (x.length() === 0) {
                z.x += 0.0001;
                x.crossVectors(up, z).normalize();
            }
            y.crossVectors(z, x);
            te[0] = x.x;
            te[4] = y.x;
            te[8] = z.x;
            te[1] = x.y;
            te[5] = y.y;
            te[9] = z.y;
            te[2] = x.z;
            te[6] = y.z;
            te[10] = z.z;
            return this;
        };
        /**
        * Multiplies this matrix by m
        * @param {Matrix4} m
        * @returns {Matrix4}
        */
        Matrix4.prototype.multiply = function (m) {
            return this.multiplyMatrices(this, m);
        };
        /**
        * Multiplies matrix a by b and assigns it to this
        * @param {Matrix4} a The first matrix
        * @param {Matrix4} b The second matrix
        * @returns {Matrix4}
        */
        Matrix4.prototype.multiplyMatrices = function (a, b) {
            var ae = a.elements;
            var be = b.elements;
            var te = this.elements;
            var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
            var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
            var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
            var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
            var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
            var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
            var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
            var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
            te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
            te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
            te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
            te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
            te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
            te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
            te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
            te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
            te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
            te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
            te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
            te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
            te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
            te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
            te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
            te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
            return this;
        };
        /**
        * Multiplies matrix a by b and flattens to r
        * @param {Matrix4} a The first matrix
        * @param {Matrix4} b The second matrix
        * @param {Array<number>} r The array to flatten to
        * @returns {Matrix4}
        */
        Matrix4.prototype.multiplyToArray = function (a, b, r) {
            var te = this.elements;
            this.multiplyMatrices(a, b);
            r[0] = te[0];
            r[1] = te[1];
            r[2] = te[2];
            r[3] = te[3];
            r[4] = te[4];
            r[5] = te[5];
            r[6] = te[6];
            r[7] = te[7];
            r[8] = te[8];
            r[9] = te[9];
            r[10] = te[10];
            r[11] = te[11];
            r[12] = te[12];
            r[13] = te[13];
            r[14] = te[14];
            r[15] = te[15];
            return this;
        };
        /**
        * Multiplies this matrix by a scale
        * @param {number} s The number to scale by
        * @returns {Matrix4}
        */
        Matrix4.prototype.multiplyScalar = function (s) {
            var te = this.elements;
            te[0] *= s;
            te[4] *= s;
            te[8] *= s;
            te[12] *= s;
            te[1] *= s;
            te[5] *= s;
            te[9] *= s;
            te[13] *= s;
            te[2] *= s;
            te[6] *= s;
            te[10] *= s;
            te[14] *= s;
            te[3] *= s;
            te[7] *= s;
            te[11] *= s;
            te[15] *= s;
            return this;
        };
        /**
        * Multiplies this matrix by a vector array
        * @param {Array<number>} a The array to multiply with
        * @returns {Array<number>}
        */
        Matrix4.prototype.multiplyVector3Array = function (a) {
            var v1 = Matrix4._t1;
            for (var i = 0, il = a.length; i < il; i += 3) {
                v1.x = a[i];
                v1.y = a[i + 1];
                v1.z = a[i + 2];
                v1.applyProjection(this);
                a[i] = v1.x;
                a[i + 1] = v1.y;
                a[i + 2] = v1.z;
            }
            return a;
        };
        /**
        * Gets the determinant of this matrix
        * @returns {number}
        */
        Matrix4.prototype.determinant = function () {
            var te = this.elements;
            var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
            var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
            var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
            var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
            return (n41 * (+n14 * n23 * n32
                - n13 * n24 * n32
                - n14 * n22 * n33
                + n12 * n24 * n33
                + n13 * n22 * n34
                - n12 * n23 * n34) +
                n42 * (+n11 * n23 * n34
                    - n11 * n24 * n33
                    + n14 * n21 * n33
                    - n13 * n21 * n34
                    + n13 * n24 * n31
                    - n14 * n23 * n31) +
                n43 * (+n11 * n24 * n32
                    - n11 * n22 * n34
                    - n14 * n21 * n32
                    + n12 * n21 * n34
                    + n14 * n22 * n31
                    - n12 * n24 * n31) +
                n44 * (-n13 * n22 * n31
                    - n11 * n23 * n32
                    + n11 * n22 * n33
                    + n13 * n21 * n32
                    - n12 * n21 * n33
                    + n12 * n23 * n31));
        };
        /**
        * Transposes this matrix
        * @returns {Matrix4}
        */
        Matrix4.prototype.transpose = function () {
            var te = this.elements;
            var tmp;
            tmp = te[1];
            te[1] = te[4];
            te[4] = tmp;
            tmp = te[2];
            te[2] = te[8];
            te[8] = tmp;
            tmp = te[6];
            te[6] = te[9];
            te[9] = tmp;
            tmp = te[3];
            te[3] = te[12];
            te[12] = tmp;
            tmp = te[7];
            te[7] = te[13];
            te[13] = tmp;
            tmp = te[11];
            te[11] = te[14];
            te[14] = tmp;
            return this;
        };
        /**
        * Flattens this matrix to an array
        * @param {Array<number>} flat The array to set values on
        * @returns {Array<number>}
        */
        Matrix4.prototype.flattenToArray = function (flat) {
            var te = this.elements;
            flat[0] = te[0];
            flat[1] = te[1];
            flat[2] = te[2];
            flat[3] = te[3];
            flat[4] = te[4];
            flat[5] = te[5];
            flat[6] = te[6];
            flat[7] = te[7];
            flat[8] = te[8];
            flat[9] = te[9];
            flat[10] = te[10];
            flat[11] = te[11];
            flat[12] = te[12];
            flat[13] = te[13];
            flat[14] = te[14];
            flat[15] = te[15];
            return flat;
        };
        /**
        * Flattens the data of this matrix into a float array
        * @param {Float32Array} flat The flattened array
        * @param {number} offset The index offset to start from
        * @returns {Float32Array}
        */
        Matrix4.prototype.flattenToArrayOffset = function (flat, offset) {
            var te = this.elements;
            flat[offset] = te[0];
            flat[offset + 1] = te[1];
            flat[offset + 2] = te[2];
            flat[offset + 3] = te[3];
            flat[offset + 4] = te[4];
            flat[offset + 5] = te[5];
            flat[offset + 6] = te[6];
            flat[offset + 7] = te[7];
            flat[offset + 8] = te[8];
            flat[offset + 9] = te[9];
            flat[offset + 10] = te[10];
            flat[offset + 11] = te[11];
            flat[offset + 12] = te[12];
            flat[offset + 13] = te[13];
            flat[offset + 14] = te[14];
            flat[offset + 15] = te[15];
            return flat;
        };
        /**
        * Sets the translation indices of this matrix
        * @param {Vec3} v The position to set
        * @returns {Matrix4}
        */
        Matrix4.prototype.setPosition = function (v) {
            var te = this.elements;
            te[12] = v.x;
            te[13] = v.y;
            te[14] = v.z;
            return this;
        };
        /**
        * Gets the inverse of a matrix m and sets it to this
        * @param {Vec3} m The matrix to extract from
        * @param {boolean} throwOnInvertible If true, an error is thrown for bad values
        * @returns {Matrix4}
        */
        Matrix4.prototype.getInverse = function (m, throwOnInvertible) {
            if (throwOnInvertible === void 0) { throwOnInvertible = false; }
            // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
            var te = this.elements;
            var me = m.elements;
            var n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];
            var n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];
            var n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];
            var n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];
            te[0] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
            te[4] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
            te[8] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
            te[12] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
            te[1] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
            te[5] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
            te[9] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
            te[13] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
            te[2] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
            te[6] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
            te[10] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
            te[14] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
            te[3] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
            te[7] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
            te[11] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
            te[15] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;
            var det = n11 * te[0] + n21 * te[4] + n31 * te[8] + n41 * te[12];
            if (det === 0) {
                var msg = 'Matrix4.getInverse(): can\'t invert matrix, determinant is 0';
                if (throwOnInvertible || false) {
                    throw new Error(msg);
                }
                else {
                    console.warn(msg);
                }
                this.identity();
                return this;
            }
            this.multiplyScalar(1 / det);
            return this;
        };
        /**
        * Scales this matrix by a vector v
        * @param {Vec3} v The vector to scale with
        * @returns {Matrix4}
        */
        Matrix4.prototype.scale = function (v) {
            var te = this.elements;
            var x = v.x, y = v.y, z = v.z;
            te[0] *= x;
            te[4] *= y;
            te[8] *= z;
            te[1] *= x;
            te[5] *= y;
            te[9] *= z;
            te[2] *= x;
            te[6] *= y;
            te[10] *= z;
            te[3] *= x;
            te[7] *= y;
            te[11] *= z;
            return this;
        };
        /**
        * Gets the maximum scale of the matrix
        * @returns {number}
        */
        Matrix4.prototype.getMaxScaleOnAxis = function () {
            var te = this.elements;
            var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
            var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
            var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
            return Math.sqrt(Math.max(scaleXSq, Math.max(scaleYSq, scaleZSq)));
        };
        /**
        * Builds a translation matrix from x, y, and z
        * @param {number} theta The x position
        * @param {number} theta The y position
        * @param {number} theta The z position
        * @returns {Matrix4}
        */
        Matrix4.prototype.makeTranslation = function (x, y, z) {
            this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
            return this;
        };
        /**
        * Builds a X axis rotation matrix
        * @param {number} theta The angle in radians
        * @returns {Matrix4}
        */
        Matrix4.prototype.makeRotationX = function (theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
            return this;
        };
        /**
        * Builds a Y axis rotation matrix
        * @param {number} theta The angle in radians
        * @returns {Matrix4}
        */
        Matrix4.prototype.makeRotationY = function (theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
            return this;
        };
        /**
        * Builds a Z axis rotation matrix
        * @param {number} theta The angle in radians
        * @returns {Matrix4}
        */
        Matrix4.prototype.makeRotationZ = function (theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
        };
        /**
        * Builds a rotation matrix
        * @param {Vec3} axis The reference
        * @param {number} y The angle in radians
        * @returns {Matrix4}
        */
        Matrix4.prototype.makeRotationAxis = function (axis, angle) {
            // Based on http://www.gamedev.net/reference/articles/article1199.asp
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var t = 1 - c;
            var x = axis.x, y = axis.y, z = axis.z;
            var tx = t * x, ty = t * y;
            this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
            return this;
        };
        /**
        * Builds a scale matrix
        * @param {number} x The x scale
        * @param {number} y The y scale
        * @param {number} z The z scale
        * @returns {Matrix4}
        */
        Matrix4.prototype.makeScale = function (x, y, z) {
            this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
            return this;
        };
        /**
        * Composes a matrix from a position, scale and rotation
        * @param {Vec3} position The position to build from
        * @param {Quat} quaternion The rotation to build from
        * @param {Vec3} scale The scale to build from
        * @returns {Matrix4}
        */
        Matrix4.prototype.compose = function (position, quaternion, scale) {
            this.makeRotationFromQuaternion(quaternion);
            this.scale(scale);
            this.setPosition(position);
            return this;
        };
        /**
        * Decomposes a matrix into its position, scale and rotation
        * @param {Vec3} position The position to output to
        * @param {Quat} quaternion The rotation to extract to
        * @param {Vec3} scale The scale to extract to
        * @returns {Matrix4}
        */
        Matrix4.prototype.decompose = function (position, quaternion, scale) {
            var vector = Matrix4._t1;
            var matrix = new Matrix4();
            var te = this.elements;
            var sx = vector.set(te[0], te[1], te[2]).length();
            var sy = vector.set(te[4], te[5], te[6]).length();
            var sz = vector.set(te[8], te[9], te[10]).length();
            // if determine is negative, we need to invert one scale
            var det = this.determinant();
            if (det < 0)
                sx = -sx;
            position.x = te[12];
            position.y = te[13];
            position.z = te[14];
            // scale the rotation part
            matrix.elements.set(this.elements); // at this point matrix is incomplete so we can't use .copy()
            var invSX = 1 / sx;
            var invSY = 1 / sy;
            var invSZ = 1 / sz;
            matrix.elements[0] *= invSX;
            matrix.elements[1] *= invSX;
            matrix.elements[2] *= invSX;
            matrix.elements[4] *= invSY;
            matrix.elements[5] *= invSY;
            matrix.elements[6] *= invSY;
            matrix.elements[8] *= invSZ;
            matrix.elements[9] *= invSZ;
            matrix.elements[10] *= invSZ;
            quaternion.setFromRotationMatrix(matrix);
            scale.x = sx;
            scale.y = sy;
            scale.z = sz;
            return this;
        };
        /**
        * Creates a frustum matrix
        * @param {number} left
        * @param {number} right
        * @param {number} top
        * @param {number} bottom
        * @param {number} near The near distance of the camera
        * @param {number} far The far distance of the camera
        * @returns {Matrix4}
        */
        Matrix4.prototype.makeFrustum = function (left, right, bottom, top, near, far) {
            var te = this.elements;
            var x = 2 * near / (right - left);
            var y = 2 * near / (top - bottom);
            var a = (right + left) / (right - left);
            var b = (top + bottom) / (top - bottom);
            var c = -(far + near) / (far - near);
            var d = -2 * far * near / (far - near);
            te[0] = x;
            te[4] = 0;
            te[8] = a;
            te[12] = 0;
            te[1] = 0;
            te[5] = y;
            te[9] = b;
            te[13] = 0;
            te[2] = 0;
            te[6] = 0;
            te[10] = c;
            te[14] = d;
            te[3] = 0;
            te[7] = 0;
            te[11] = -1;
            te[15] = 0;
            return this;
        };
        /**
        * Creates a camera perspective matrix
        * @param {number} fov Field of view
        * @param {number} aspect The aspect ratio to use. Typically width  / height
        * @param {number} near The near distance of the camera
        * @param {number} far The far distance of the camera
        * @returns {Matrix4}
        */
        Matrix4.prototype.makePerspective = function (fov, aspect, near, far) {
            var ymax = near * Math.tan(Trike.MathUtils.degToRad(fov * 0.5));
            var ymin = -ymax;
            var xmin = ymin * aspect;
            var xmax = ymax * aspect;
            return this.makeFrustum(xmin, xmax, ymin, ymax, near, far);
        };
        /**
        * Creates a camera orthographic matrix
        * @param {number} left
        * @param {number} right
        * @param {number} top
        * @param {number} bottom
        * @param {number} near The near distance of the camera
        * @param {number} far The far distance of the camera
        * @returns {Matrix4}
        */
        Matrix4.prototype.makeOrthographic = function (left, right, top, bottom, near, far) {
            var te = this.elements;
            var w = right - left;
            var h = top - bottom;
            var p = far - near;
            var x = (right + left) / w;
            var y = (top + bottom) / h;
            var z = (far + near) / p;
            te[0] = 2 / w;
            te[4] = 0;
            te[8] = 0;
            te[12] = -x;
            te[1] = 0;
            te[5] = 2 / h;
            te[9] = 0;
            te[13] = -y;
            te[2] = 0;
            te[6] = 0;
            te[10] = -2 / p;
            te[14] = -z;
            te[3] = 0;
            te[7] = 0;
            te[11] = 0;
            te[15] = 1;
            return this;
        };
        /**
        * Converts a 16 index array to a matrix
        * @param {Array<number>} array
        * @returns {Matrix4}
        */
        Matrix4.prototype.fromArray = function (array) {
            this.elements.set(array);
            return this;
        };
        /**
        * Converts this matrix to an array of numbers
        * @returns {Array<number>}
        */
        Matrix4.prototype.toArray = function () {
            var te = this.elements;
            return [
                te[0], te[1], te[2], te[3],
                te[4], te[5], te[6], te[7],
                te[8], te[9], te[10], te[11],
                te[12], te[13], te[14], te[15]
            ];
        };
        /**
        * Creates a cloned copy of this matrix
        * @returns {Matrix4}
        */
        Matrix4.prototype.clone = function () {
            var te = this.elements;
            return new Matrix4(te[0], te[4], te[8], te[12], te[1], te[5], te[9], te[13], te[2], te[6], te[10], te[14], te[3], te[7], te[11], te[15]);
        };
        Object.defineProperty(Matrix4.prototype, "getElements", {
            /**
            * Gets the Float32Array representation of this vector
            * @returns {Float32Array}
            */
            get: function () {
                return this.elements;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Checks if this matrxi is equal to ref by checking each element
        * @param {Matrix4} ref
        * @returns {boolean}
        */
        Matrix4.prototype.equals = function (ref) {
            var te = this.elements;
            var re = ref.elements;
            if (te[0] !== re[0])
                return false;
            if (te[1] !== re[1])
                return false;
            if (te[2] !== re[2])
                return false;
            if (te[3] !== re[3])
                return false;
            if (te[4] !== re[4])
                return false;
            if (te[5] !== re[5])
                return false;
            if (te[6] !== re[6])
                return false;
            if (te[7] !== re[7])
                return false;
            if (te[8] !== re[8])
                return false;
            if (te[9] !== re[9])
                return false;
            if (te[10] !== re[10])
                return false;
            if (te[11] !== re[11])
                return false;
            if (te[12] !== re[12])
                return false;
            if (te[13] !== re[13])
                return false;
            if (te[14] !== re[14])
                return false;
            if (te[15] !== re[15])
                return false;
            return true;
        };
        return Matrix4;
    }());
    Trike.Matrix4 = Matrix4;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    var Vec2 = (function () {
        function Vec2(x, y) {
            this.x = x || 0;
            this.y = y || 0;
            this.elements = new Float32Array(2);
        }
        Object.defineProperty(Vec2.prototype, "getElements", {
            /**
            * Gets the Float32Array representation of this vector
            * @returns {Float32Array}
            */
            get: function () {
                var elm = this.elements;
                elm[0] = this.x;
                elm[1] = this.y;
                return elm;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Sets the x and y component of this vector
        * @param {number} x The x component
        * @param {number} y The y component
        * @returns {Vec2}
        */
        Vec2.prototype.set = function (x, y) {
            this.x = x;
            this.y = y;
            return this;
        };
        /**
        * Sets the x
        * @param {number} x The x component
        * @returns {Vec2}
        */
        Vec2.prototype.setX = function (x) {
            this.x = x;
            return this;
        };
        /**
        * Sets y component of this vector
        * @param {number} y The y component
        * @returns {Vec2}
        */
        Vec2.prototype.setY = function (y) {
            this.y = y;
            return this;
        };
        /**
        * Sets the x and y component of this vector by index
        * @param {number} index An index number representing the component's x or y
        * @param {number} y The new value to set the component
        * @returns {Vec2}
        */
        Vec2.prototype.setComponent = function (index, value) {
            switch (index) {
                case 0:
                    this.x = value;
                    break;
                case 1:
                    this.y = value;
                    break;
                default: throw new Error('index is out of range: ' + index);
            }
            return this;
        };
        /**
        * Gets a value of this vector by its index
        * @param {number} index The index of the component to get
        * @returns {number}
        */
        Vec2.prototype.getComponent = function (index) {
            switch (index) {
                case 0: return this.x;
                case 1: return this.y;
                default: throw new Error('index is out of range: ' + index);
            }
        };
        /**
        * Sets the x and y component of this vector by copying it from another vector
        * @param {Vec2} v The vector to copy from
        * @returns {Vec2}
        */
        Vec2.prototype.copy = function (v) {
            this.x = v.x;
            this.y = v.y;
            return this;
        };
        /**
        * Adds the x and y component of a separate vector
        * @param {Vec2} v The vector to get values from
        * @returns {Vec2}
        */
        Vec2.prototype.add = function (v) {
            this.x += v.x;
            this.y += v.y;
            return this;
        };
        /**
        * Adds the values of 2 vectors and assigns it to this vector
        * @param {Vec2} a The first vector
        * @param {Vec2} b The second vector
        * @returns {Vec2}
        */
        Vec2.prototype.addVectors = function (a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            return this;
        };
        /**
        * Adds a number to both components
        * @param {number} s The number to add
        * @returns {Vec2}
        */
        Vec2.prototype.addScalar = function (s) {
            this.x += s;
            this.y += s;
            return this;
        };
        /**
        * Subtracts the components from a separate vector
        * @param {Vec2} v The vector we are subtracting
        * @returns {Vec2}
        */
        Vec2.prototype.sub = function (v) {
            this.x -= v.x;
            this.y -= v.y;
            return this;
        };
        /**
        * Subtracts the vector a with b and assigngs the result to this vector
        * @param {Vec2} a  The first vector
        * @param {Vec2} b The second vector
        * @returns {Vec2}
        */
        Vec2.prototype.subVectors = function (a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            return this;
        };
        /**
        * Multiples the components of this vector with a number s
        * @param {number} s The scalar to multiple with
        * @returns {Vec2}
        */
        Vec2.prototype.multiplyScalar = function (s) {
            this.x *= s;
            this.y *= s;
            return this;
        };
        /**
        * Multiplies the vector v with this vector
        * @param {Vec2} v The vector to multiple with
        * @returns {Vec2}
        */
        Vec2.prototype.multiply = function (v) {
            this.x *= v.x;
            this.y *= v.y;
            return this;
        };
        /**
        * Multiplies a and b with x and y respectively. Same as multiply but with numbers instead of a vector
        * @param {number} a The first number
        * @param {number} b The second number
        * @returns {Vec2}
        */
        Vec2.prototype.multiply2 = function (a, b) {
            this.x *= a;
            this.y *= b;
            return this;
        };
        /**
        * Multiplies the vector a with b and assigns the result to this vector
        * @param {number} a The first vector
        * @param {number} b The second vector
        * @returns {Vec2}
        */
        Vec2.prototype.multiplyVectors = function (a, b) {
            this.x = a.x * b.x;
            this.y = a.y * b.y;
            return this;
        };
        /**
        * Multiplies the vector with a number s
        * @param {number} s The number to multiple with
        * @returns {Vec2}
        */
        Vec2.prototype.divideScalar = function (s) {
            if (s !== 0) {
                var invScalar = 1 / s;
                this.x *= invScalar;
                this.y *= invScalar;
            }
            else {
                this.x = 0;
                this.y = 0;
            }
            return this;
        };
        /**
        * Finds the lowest values from Vector v or this vector and applies it to x and y
        * @param {Vec2} v The vector we are checking against
        * @returns {Vec2}
        */
        Vec2.prototype.min = function (v) {
            if (this.x > v.x)
                this.x = v.x;
            if (this.y > v.y)
                this.y = v.y;
            return this;
        };
        /**
        * Finds the highest values from Vector v or this vector and applies it to x and y
        * @param {Vec2} v The vector we are checking against
        * @returns {Vec2}
        */
        Vec2.prototype.max = function (v) {
            if (this.x < v.x)
                this.x = v.x;
            if (this.y < v.y)
                this.y = v.y;
            return this;
        };
        /**
        * Clamps the lowest and highest values from Vector min and max and applies it to x and y if
        * the components of this vector are outside either's range
        * @param {Vec2} min The minimum values
        * @param {Vec2} max The maximum values
        * @returns {Vec2}
        */
        Vec2.prototype.clamp = function (min, max) {
            // This function assumes min < max, if this assumption isn't true it will not operate correctly
            if (this.x < min.x)
                this.x = min.x;
            else if (this.x > max.x)
                this.x = max.x;
            if (this.y < min.y)
                this.y = min.y;
            else if (this.y > max.y)
                this.y = max.y;
            return this;
        };
        /**
        * Multiples this vector by a negative scalar
        * @returns {Vec2}
        */
        Vec2.prototype.negate = function () {
            return this.multiplyScalar(-1);
        };
        /**
        * Returns the dot product of this vector with vector v
        * @param {Vec2} v The vector to dot with
        * @returns {Vec2}
        */
        Vec2.prototype.dot = function (v) {
            return this.x * v.x + this.y * v.y;
        };
        /**
        * Returns the square of each component added together
        * @returns {number}
        */
        Vec2.prototype.lengthSq = function () {
            return this.x * this.x + this.y * this.y;
        };
        /**
        * Returns the length of this vector
        * @returns {number}
        */
        Vec2.prototype.length = function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        };
        /**
        * Normalizes the values of this vector so they are between 0 and 1
        * @returns {Vec2}
        */
        Vec2.prototype.normalize = function () {
            return this.divideScalar(this.length());
        };
        /**
        * Returns the distance to a vector v
        * @param {Vec2} v The target vector
        * @returns {number}
        */
        Vec2.prototype.distanceTo = function (v) {
            return Math.sqrt(this.distanceToSquared(v));
        };
        /**
        * Returns the distance to a vector v squared
        * @param {Vec2} v The target vector
        * @returns {number}
        */
        Vec2.prototype.distanceToSquared = function (v) {
            var dx = this.x - v.x, dy = this.y - v.y;
            return dx * dx + dy * dy;
        };
        /**
        * Sets the length of this vector
        * @param {number} l The new vector size
        * @returns {Vec2}
        */
        Vec2.prototype.setLength = function (l) {
            var oldLength = this.length();
            if (oldLength !== 0 && l !== oldLength)
                this.multiplyScalar(l / oldLength);
            return this;
        };
        /**
        * Linear interpolation of the vector v at point a. The result is applied to this vector
        * @param {Vec2} v The vector to interpolate
        * @param {number} a The alpha value (between 0 and 1)
        * @returns {Vec2}
        */
        Vec2.prototype.lerp = function (v, a) {
            this.x += (v.x - this.x) * a;
            this.y += (v.y - this.y) * a;
            return this;
        };
        /**
        * Tests for equality with vector v
        * @param {Vec2} v The vector to test
        * @returns {boolean}
        */
        Vec2.prototype.equals = function (v) {
            return ((v.x === this.x) && (v.y === this.y));
        };
        /**
        * Sets the components of this vector from an array
        * @param {Array<number>} v The array to get values from
        * @returns {Vec2}
        */
        Vec2.prototype.fromArray = function (array) {
            this.x = array[0];
            this.y = array[1];
            return this;
        };
        /**
        * Creates an array from this vector
        * @returns {Array<number>}
        */
        Vec2.prototype.toArray = function () {
            return [this.x, this.y];
        };
        /**
        * Gets an angle to a vector v
        * @param {Vec2} v The target vector
        * @param {boolean} signed If true, the returned angle's sign is intact. If not the angle is always between 0 - 180
        * @returns {number}
        */
        Vec2.prototype.angleTo = function (v, signed) {
            if (signed)
                return Math.atan2(this.x * v.y - this.y * v.x, this.dot(v));
            return Math.acos(this.dot(v) / (this.length() * v.length()));
        };
        /**
        * Clones this vector
        * @returns {Vec2}
        */
        Vec2.prototype.clone = function () {
            return new Vec2(this.x, this.y);
        };
        return Vec2;
    }());
    Trike.Vec2 = Vec2;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A simple 3D Vector
    */
    var Vec3 = (function () {
        /**
        * Creates a new vector instance
        * @param {number} x [Optional] The x value
        * @param {number} y [Optional] The y value
        * @param {number} z [Optional] The z value
        */
        function Vec3(x, y, z) {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.elements = new Float32Array(3);
            if (!Vec3._quat) {
                Vec3._quat = new Trike.Quat();
                Vec3._m = new Trike.Matrix4();
                Vec3._v1 = new Vec3();
                Vec3.UP = new Vec3(0, 1, 0);
                Vec3.X = new Vec3(1, 0, 0);
                Vec3.Y = new Vec3(0, 1, 0);
                Vec3.Z = new Vec3(0, 0, 1);
            }
        }
        Object.defineProperty(Vec3.prototype, "getElements", {
            /**
            * Gets the Float32Array representation of this vector
            * @returns {Float32Array}
            */
            get: function () {
                var elm = this.elements;
                elm[0] = this.x;
                elm[1] = this.y;
                elm[2] = this.z;
                return elm;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Sets the components of this vector
        * @param {number} x The x value
        * @param {number} y The y value
        * @param {number} z The z value
        * @returns {Vec3}
        */
        Vec3.prototype.set = function (x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        };
        /**
        * Sets the x component of this vector
        * @param {number} x The x value
        * @returns {Vec3}
        */
        Vec3.prototype.setX = function (x) {
            this.x = x;
            return this;
        };
        /**
        * Sets the y component of this vector
        * @param {number} y The y value
        * @returns {Vec3}
        */
        Vec3.prototype.setY = function (y) {
            this.y = y;
            return this;
        };
        /**
        * Sets the z component of this vector
        * @param {number} z The z value
        * @returns {Vec3}
        */
        Vec3.prototype.setZ = function (z) {
            this.z = z;
            return this;
        };
        /**
        * Sets one of the vectors values by index.
        * @param {number} index The index to set, 0 = x, 1 = y, 2 = z
        * @param {number} value The new value
        * @returns {Vec3}
        */
        Vec3.prototype.setComponent = function (index, value) {
            switch (index) {
                case 0:
                    this.x = value;
                    break;
                case 1:
                    this.y = value;
                    break;
                case 2:
                    this.z = value;
                    break;
                default: throw new Error('index is out of range: ' + index);
            }
            return this;
        };
        /**
        * Gets one of the vectors values by index.
        * @param {number} index The index to get, 0 = x, 1 = y, 2 = z
        * @returns {number}
        */
        Vec3.prototype.getComponent = function (index) {
            switch (index) {
                case 0: return this.x;
                case 1: return this.y;
                case 2: return this.z;
                default: throw new Error('index is out of range: ' + index);
            }
        };
        /**
        * Copies the values of v into this vector
        * @param {Vec3} v The vector to copy from
        * @returns {Vec3}
        */
        Vec3.prototype.copy = function (v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            return this;
        };
        /**
        * Add the vector v and sets the result on this vector's components
        * @param {Vec3} v The vector to add from
        * @returns {Vec3}
        */
        Vec3.prototype.add = function (v) {
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            return this;
        };
        /**
        * Add the scalar s and sets the result on this vector
        * @param {number} s The scalar value to add
        * @returns {Vec3}
        */
        Vec3.prototype.addScalar = function (s) {
            this.x += s;
            this.y += s;
            this.z += s;
            return this;
        };
        /**
        * Adds the vectors a and b and sets the result on this vector
        * @param {Vec3} a The first vector
        * @param {Vec3} b The second vector
        * @returns {Vec3}
        */
        Vec3.prototype.addVectors = function (a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            return this;
        };
        /**
        * Subtracts the vectors v and sets the result on this vector
        * @param {Vec3} v The vector to subtract
        * @returns {Vec3}
        */
        Vec3.prototype.sub = function (v) {
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            return this;
        };
        /**
        * Subtracts the vectors a and b and sets the result on this vector
        * @param {Vec3} a The first vector
        * @param {Vec3} b The second vector
        * @returns {Vec3}
        */
        Vec3.prototype.subVectors = function (a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            return this;
        };
        /**
        * Multiplies the vector v with this vector
        * @param {Vec3} v The vector
        * @returns {Vec3}
        */
        Vec3.prototype.multiply = function (v) {
            this.x *= v.x;
            this.y *= v.y;
            this.z *= v.z;
            return this;
        };
        /**
        * Multiplies the scalar s with this vector
        * @param {number} s The scalar to multiply
        * @returns {Vec3}
        */
        Vec3.prototype.multiplyScalar = function (s) {
            this.x *= s;
            this.y *= s;
            this.z *= s;
            return this;
        };
        /**
        * Multiplies the vectors a and b and sets the result on this vector
        * @param {Vec3} a The first vector
        * @param {Vec3} b The second vector
        * @returns {Vec3}
        */
        Vec3.prototype.multiplyVectors = function (a, b) {
            this.x = a.x * b.x;
            this.y = a.y * b.y;
            this.z = a.z * b.z;
            return this;
        };
        /**
        * Transforms this point with the matrix m.
        * @param {Matrix3} m The matrix to apply
        * @returns {Vec3}
        */
        Vec3.prototype.applyMatrix3 = function (m) {
            var x = this.x;
            var y = this.y;
            var z = this.z;
            var e = m.elements;
            this.x = e[0] * x + e[3] * y + e[6] * z;
            this.y = e[1] * x + e[4] * y + e[7] * z;
            this.z = e[2] * x + e[5] * y + e[8] * z;
            return this;
        };
        /**
        * Transforms this point with the matrix m
        * @param {Matrix4} m The matrix to apply
        * @returns {Vec3}
        */
        Vec3.prototype.applyMatrix4 = function (m) {
            // input: THREE.Matrix4 affine matrix
            var x = this.x, y = this.y, z = this.z;
            var e = m.elements;
            this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
            this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
            return this;
        };
        /**
        * Projects a 3d vector to homogenized screen space. I.e. the point will be from
        * x: { -1 to 1 ) and y { -1 to 1 }.
        * @param {Camera} camera The camera we are projecting the vector with
        * @param {boolean} rebuildCameraMatrices If true, the matrices will be built and not use the cache variables of the camera
        * @returns {Vec3}
        */
        Vec3.prototype.project = function (camera, rebuildCameraMatrices) {
            if (rebuildCameraMatrices === void 0) { rebuildCameraMatrices = false; }
            var m = Vec3._m;
            // Get the projection matrix of the object
            if (rebuildCameraMatrices)
                m.multiplyMatrices(camera.projectionMatrix, m.getInverse(camera.worldMatrix));
            else
                m.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            return this.applyProjection(m);
        };
        /**
        * Unprojects a 2d vector from homogenized screen space back to 3D. I.e. the point will be from
        * x: { -1 to 1 ) and y { -1 to 1 } to Vec3
        * @param {Camera} camera The camera we are projecting the vector with
        * @param {boolean} rebuildCameraMatrices If true, the matrices will be built and not use the cache variables of the camera
        * @returns {Vec3}
        */
        Vec3.prototype.unproject = function (camera) {
            var m = Vec3._m;
            m.multiplyMatrices(camera.worldMatrix, camera.projectionInverseMatrix);
            return this.applyProjection(m);
        };
        /**
        * Projects a 3d vector to homogenized screen space. I.e. the point will be from
        * x: { -1 to 1 ) and y { -1 to 1 }.
        * @param {Matrix4} m A projection matrix to apply
        * @returns {Vec3}
        */
        Vec3.prototype.applyProjection = function (m) {
            var x = this.x, y = this.y, z = this.z;
            var e = m.elements;
            var d = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]); // perspective divide
            this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * d;
            this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * d;
            this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * d;
            return this;
        };
        /**
        * Multiplies this vector with a quaternian q
        * @param {Quat} q The quaternian to apply
        * @returns {Vec3}
        */
        Vec3.prototype.applyQuaternion = function (q) {
            var x = this.x;
            var y = this.y;
            var z = this.z;
            var qx = q.x;
            var qy = q.y;
            var qz = q.z;
            var qw = q.w;
            // calculate quat * vector
            var ix = qw * x + qy * z - qz * y;
            var iy = qw * y + qz * x - qx * z;
            var iz = qw * z + qx * y - qy * x;
            var iw = -qx * x - qy * y - qz * z;
            // calculate result * inverse quat
            this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return this;
        };
        /**
        * Transforms this vector by the rotation values in the Matrix m.
        * This should only be used to translate directions - to transform a position point use applyMatrix4
        * @param {Matrix4} m The matrix we are using to transform this direction
        * @returns {Vec3}
        */
        Vec3.prototype.transformDirection = function (m) {
            // input: THREE.Matrix4 affine matrix
            // vector interpreted as a direction
            var x = this.x, y = this.y, z = this.z;
            var e = m.elements;
            this.x = e[0] * x + e[4] * y + e[8] * z;
            this.y = e[1] * x + e[5] * y + e[9] * z;
            this.z = e[2] * x + e[6] * y + e[10] * z;
            this.normalize();
            return this;
        };
        /**
        * Divides this vector by the vector v
        * @param {Vec3} v The vector to divide by
        * @returns {Vec3}
        */
        Vec3.prototype.divide = function (v) {
            this.x /= v.x;
            this.y /= v.y;
            this.z /= v.z;
            return this;
        };
        /**
        * Divides this vector by the scalar s
        * @param {number} s The scalar to divide by
        * @returns {Vec3}
        */
        Vec3.prototype.divideScalar = function (s) {
            if (s) {
                this.x /= s;
                this.y /= s;
                this.z /= s;
            }
            else {
                this.x = 0;
                this.y = 0;
                this.z = 0;
            }
            return this;
        };
        /**
        * Sets this vector's values to the lowest between itself and the reference vector v
        * @param {Vec3} v The reference vector
        * @returns {Vec3}
        */
        Vec3.prototype.min = function (v) {
            if (this.x > v.x)
                this.x = v.x;
            if (this.y > v.y)
                this.y = v.y;
            if (this.z > v.z)
                this.z = v.z;
            return this;
        };
        /**
        * Sets this vector's values to the highest between itself and the reference vector v
        * @param {Vec3} v The reference vector
        * @returns {Vec3}
        */
        Vec3.prototype.max = function (v) {
            if (this.x < v.x)
                this.x = v.x;
            if (this.y < v.y)
                this.y = v.y;
            if (this.z < v.z)
                this.z = v.z;
            return this;
        };
        /**
        * Clamps this vector to a min and max set of values. This function assumes min < max, if this assumption isn't true it will not operate correctly
        * @param {Vec3} min The min reference vector
        * @param {Vec3} max The max reference vector
        * @returns {Vec3}
        */
        Vec3.prototype.clamp = function (min, max) {
            if (this.x < min.x)
                this.x = min.x;
            else if (this.x > max.x)
                this.x = max.x;
            if (this.y < min.y)
                this.y = min.y;
            else if (this.y > max.y)
                this.y = max.y;
            if (this.z < min.z)
                this.z = min.z;
            else if (this.z > max.z)
                this.z = max.z;
            return this;
        };
        /**
        * Inverts this vector, essentially multiplying it by -1
        * @returns {Vec3}
        */
        Vec3.prototype.negate = function () {
            return this.multiplyScalar(-1);
        };
        /**
        * Returns the dot product, or scalar value, of this vector and the one passed to it. You can think of the dot as a projection
        * of the one vector onto the other. See here for a visualization: http://www.falstad.com/dotproduct/
        * @param {Vec3} v The vector to dot against
        * @returns {number}
        */
        Vec3.prototype.dot = function (v) {
            return this.x * v.x + this.y * v.y + this.z * v.z;
        };
        /**
        * Returns the length squared of this vector
        * @returns {number}
        */
        Vec3.prototype.lengthSq = function () {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        };
        /**
        * Returns the length of this vector
        * @returns {number}
        */
        Vec3.prototype.length = function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        };
        Vec3.prototype.lengthManhattan = function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        };
        /**
        * Normalizes this vector. This essentially makes each component of the vector a value between 0 and 1
        * @returns {Vec3}
        */
        Vec3.prototype.normalize = function () {
            return this.divideScalar(this.length());
        };
        /**
        * Enlarges the vector by the scalar value l
        * @param {number} l The scalar value
        * @returns {Vec3}
        */
        Vec3.prototype.setLength = function (l) {
            var oldLength = this.length();
            if (oldLength !== 0 && l !== oldLength)
                this.multiplyScalar(l / oldLength);
            return this;
        };
        /**
        * Interpolates the values of this vector towards its reference v. The interpolation is calculated by
        * the weight value of alpha
        * @param {Vec3} v The vector to interpolate towards
        * @param {number} alpha The weight (typically from 0 to 1)
        * @returns {Vec3}
        */
        Vec3.prototype.lerp = function (v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            return this;
        };
        /**
        * Returns the cross product of this vector with the vector v. Cross product vectors are typically at perpendicular to both components of the
        * vectors you provide.
        * @param {Vec3} v The vector to cross with
        * @returns {Vec3}
        */
        Vec3.prototype.cross = function (v) {
            var x = this.x, y = this.y, z = this.z;
            this.x = y * v.z - z * v.y;
            this.y = z * v.x - x * v.z;
            this.z = x * v.y - y * v.x;
            return this;
        };
        /**
        * Sets the cross product of two vectors on this vector and returns the result.
        * Cross product vectors are typically at perpendicular to both components of the
        * vectors you provide.
        * @param {Vec3} a The first vector to cross with
        * @param {Vec3} b The second vector to cross with
        * @returns {Vec3}
        */
        Vec3.prototype.crossVectors = function (a, b) {
            var ax = a.x, ay = a.y, az = a.z;
            var bx = b.x, by = b.y, bz = b.z;
            this.x = ay * bz - az * by;
            this.y = az * bx - ax * bz;
            this.z = ax * by - ay * bx;
            return this;
        };
        /**
        * Calculates the angle between this vector and the reference v
        * @param {Vec3} v The vector reference
        * @returns {number}
        */
        Vec3.prototype.angleTo = function (v) {
            var theta = this.dot(v) / (this.length() * v.length());
            // clamp, to handle numerical problems
            return Math.acos(Math.min(Math.max(theta, -1), 1));
        };
        /**
        * Returns the distance from this vector to the one reference v
        * @param {Vec3} v The vector reference
        * @returns {number}
        */
        Vec3.prototype.distanceTo = function (v) {
            return Math.sqrt(this.distanceToSquared(v));
        };
        /**
        * Returns the distance squared from this vector to the reference v
        * @param {Vec3} v The vector reference
        * @returns {number}
        */
        Vec3.prototype.distanceToSquared = function (v) {
            var dx = this.x - v.x;
            var dy = this.y - v.y;
            var dz = this.z - v.z;
            return dx * dx + dy * dy + dz * dz;
        };
        /**
        * Extracts the position data from a matrix 4 and sets those values on this vector
        * @param {Matrix4} m The matrix to extract from
        * @returns {Vec3}
        */
        Vec3.prototype.getPositionFromMatrix = function (m) {
            this.x = m.elements[12];
            this.y = m.elements[13];
            this.z = m.elements[14];
            return this;
        };
        /**
        * Extracts the scale data from a matrix 4 and sets those values on this vector
        * @param {Matrix4} m The matrix to extract from
        * @returns {Vec3}
        */
        Vec3.prototype.getScaleFromMatrix = function (m) {
            var sx = this.set(m.elements[0], m.elements[1], m.elements[2]).length();
            var sy = this.set(m.elements[4], m.elements[5], m.elements[6]).length();
            var sz = this.set(m.elements[8], m.elements[9], m.elements[10]).length();
            this.x = sx;
            this.y = sy;
            this.z = sz;
            return this;
        };
        Vec3.prototype.getColumnFromMatrix = function (index, matrix) {
            var offset = index * 4;
            var me = matrix.elements;
            this.x = me[offset];
            this.y = me[offset + 1];
            this.z = me[offset + 2];
            return this;
        };
        /**
        * Checks if one vector's values equals anothers
        * @param {Vec3} v The reference to check against
        * @returns {boolean}
        */
        Vec3.prototype.equals = function (v) {
            return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));
        };
        /**
        * Extracts the data from an array and sets those values on this vector
        * @param {Array<number>} array The array to fetch from
        * @returns {Vec3}
        */
        Vec3.prototype.fromArray = function (array) {
            this.x = array[0];
            this.y = array[1];
            this.z = array[2];
            return this;
        };
        /**
        * Returns a new array with the values of this vector
        * @returns {Array<number>}
        */
        Vec3.prototype.toArray = function () {
            return [this.x, this.y, this.z];
        };
        /**
        * Clones this Vector
        * @returns {Vec3}
        */
        Vec3.prototype.clone = function () {
            return new Vec3(this.x, this.y, this.z);
        };
        /**
        * Applies an Euler to this vector
        * @param {Euler} euler The euler to apply
        * @returns {Vec3}
        */
        Vec3.prototype.applyEuler = function (euler) {
            var quaternion = Vec3._quat;
            this.applyQuaternion(quaternion.setFromEuler(euler));
            return this;
        };
        /**
        * Transforms this vector by an angle on a specified axis
        * @param {Vec3} axis A reference vector of which set of axes to transform
        * @param {number} angle The angle in radians
        * @returns {Vec3}
        */
        Vec3.prototype.applyAxisAngle = function (axis, angle) {
            var quaternion = Vec3._quat;
            this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
            return this;
        };
        /**
        * Sets the direction and length of this vector by projecting it onto a reference vector r
        * @param {Vec3} r A the reference vector
        * @returns {Vec3}
        */
        Vec3.prototype.projectOnVector = function (r) {
            var v1 = Vec3._v1;
            v1.copy(r).normalize();
            var d = this.dot(v1);
            return this.copy(v1).multiplyScalar(d);
        };
        /**
        * Sets the direction and length of this vector by projecting it onto a vector representing a plane's normal
        * @param {Vec3} planeNormal The normal of the plane we are projecting onto
        * @returns {Vec3}
        */
        Vec3.prototype.projectOnPlane = function (planeNormal) {
            var v1 = Vec3._v1;
            v1.copy(this).projectOnVector(planeNormal);
            return this.sub(v1);
        };
        /**
        * Reflects this vector against a plane orthogonal to normal
        * @param {Vec3} normal The reference vector
        * @returns {Vec3}
        */
        Vec3.prototype.reflect = function (normal) {
            var v1 = Vec3._v1;
            return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
        };
        return Vec3;
    }());
    Trike.Vec3 = Vec3;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A simple 4D Vector
    */
    var Vec4 = (function () {
        /**
        * Creates a new vector instance
        * @param {number} x [Optional] The x value
        * @param {number} y [Optional] The y value
        * @param {number} z [Optional] The z value
        * @param {number} w [Optional] The w value
        */
        function Vec4(x, y, z, w) {
            this.x = x || 0;
            this.y = y || 0;
            this.z = z || 0;
            this.w = (w !== undefined) ? w : 1;
            this.elements = new Float32Array(4);
        }
        Object.defineProperty(Vec4.prototype, "getElements", {
            /**
            * Gets the Float32Array representation of this vector
            * @returns {Float32Array}
            */
            get: function () {
                var elm = this.elements;
                elm[0] = this.x;
                elm[1] = this.y;
                elm[2] = this.z;
                elm[3] = this.w;
                return elm;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Sets the components of this vector
        * @param {number} x The x value
        * @param {number} y The y value
        * @param {number} z The z value
        * @param {number} w The w value
        * @returns {Vec4}
        */
        Vec4.prototype.set = function (x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        };
        /**
        * Sets the x component of this vector
        * @param {number} x The x value
        * @returns {Vec4}
        */
        Vec4.prototype.setX = function (x) {
            this.x = x;
            return this;
        };
        /**
        * Sets the y component of this vector
        * @param {number} y The y value
        * @returns {Vec4}
        */
        Vec4.prototype.setY = function (y) {
            this.y = y;
            return this;
        };
        /**
        * Sets the z component of this vector
        * @param {number} z The z value
        * @returns {Vec4}
        */
        Vec4.prototype.setZ = function (z) {
            this.z = z;
            return this;
        };
        /**
        * Sets the w component of this vector
        * @param {number} w The w value
        * @returns {Vec4}
        */
        Vec4.prototype.setW = function (w) {
            this.w = w;
            return this;
        };
        /**
        * Sets one of the vectors values by index.
        * @param {number} index The index to set, 0 = x, 1 = y, 2 = z, 3 = w
        * @param {number} value The new value
        * @returns {Vec4}
        */
        Vec4.prototype.setComponent = function (index, value) {
            switch (index) {
                case 0:
                    this.x = value;
                    break;
                case 1:
                    this.y = value;
                    break;
                case 2:
                    this.z = value;
                    break;
                case 3:
                    this.w = value;
                    break;
                default: throw new Error('index is out of range: ' + index);
            }
        };
        /**
        * Gets one of the vectors values by index.
        * @param {number} index The index to get, 0 = x, 1 = y, 2 = z, 3 = w
        * @returns {number}
        */
        Vec4.prototype.getComponent = function (index) {
            switch (index) {
                case 0: return this.x;
                case 1: return this.y;
                case 2: return this.z;
                case 3: return this.w;
                default: throw new Error('index is out of range: ' + index);
            }
        };
        /**
        * Copies the values of v into this vector
        * @param {Vec4} v The vector to copy from
        * @returns {Vec4}
        */
        Vec4.prototype.copy = function (v) {
            this.x = v.x;
            this.y = v.y;
            this.z = v.z;
            this.w = (v.w !== undefined) ? v.w : 1;
            return this;
        };
        /**
        * Add the vector v and sets the result on this vector's components
        * @param {Vec4} v The vector to add from
        * @returns {Vec4}
        */
        Vec4.prototype.add = function (v) {
            this.x += v.x;
            this.y += v.y;
            this.z += v.z;
            this.w += v.w;
            return this;
        };
        /**
        * Add the scalar s and sets the result on this vector
        * @param {number} s The scalar value to add
        * @returns {Vec4}
        */
        Vec4.prototype.addScalar = function (s) {
            this.x += s;
            this.y += s;
            this.z += s;
            this.w += s;
            return this;
        };
        /**
        * Adds the vectors a and b and sets the result on this vector
        * @param {Vec4} a The first vector
        * @param {Vec4} b The second vector
        * @returns {Vec4}
        */
        Vec4.prototype.addVectors = function (a, b) {
            this.x = a.x + b.x;
            this.y = a.y + b.y;
            this.z = a.z + b.z;
            this.w = a.w + b.w;
            return this;
        };
        /**
        * Subtracts the vectors v and sets the result on this vector
        * @param {Vec4} v The vector to subtract
        * @returns {Vec4}
        */
        Vec4.prototype.sub = function (v) {
            this.x -= v.x;
            this.y -= v.y;
            this.z -= v.z;
            this.w -= v.w;
            return this;
        };
        /**
        * Subtracts the vectors a and b and sets the result on this vector
        * @param {Vec4} a The first vector
        * @param {Vec4} b The second vector
        * @returns {Vec4}
        */
        Vec4.prototype.subVectors = function (a, b) {
            this.x = a.x - b.x;
            this.y = a.y - b.y;
            this.z = a.z - b.z;
            this.w = a.w - b.w;
            return this;
        };
        /**
        * Multiplies the vector v with this vector
        * @param {Vec4} v The vector
        * @returns {Vec4}
        */
        Vec4.prototype.multiply = function (v) {
            this.x *= v.x;
            this.y *= v.y;
            this.z *= v.z;
            this.w *= v.w;
            return this;
        };
        /**
        * Multiplies the scalar s with this vector
        * @param {number} s The scalar to multiply
        * @returns {Vec4}
        */
        Vec4.prototype.multiplyScalar = function (s) {
            this.x *= s;
            this.y *= s;
            this.z *= s;
            this.w *= s;
            return this;
        };
        /**
        * Multiplies the vectors a and b and sets the result on this vector
        * @param {Vec4} a The first vector
        * @param {Vec4} b The second vector
        * @returns {Vec4}
        */
        Vec4.prototype.multiplyVectors = function (a, b) {
            this.x = a.x * b.x;
            this.y = a.y * b.y;
            this.z = a.z * b.z;
            this.z = a.w * b.w;
            return this;
        };
        /**
        * Transforms this point with the matrix m
        * @param {Matrix4} m The matrix to apply
        * @returns {Vec4}
        */
        Vec4.prototype.applyMatrix4 = function (m) {
            var x = this.x;
            var y = this.y;
            var z = this.z;
            var w = this.w;
            var e = m.elements;
            this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
            this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
            this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
            this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
            return this;
        };
        /**
        * Divides this vector by the vector v
        * @param {Vec4} v The vector to divide by
        * @returns {Vec4}
        */
        Vec4.prototype.divide = function (v) {
            this.x /= v.x;
            this.y /= v.y;
            this.z /= v.z;
            this.w /= v.w;
            return this;
        };
        /**
        * Divides this vector by the scalar s
        * @param {number} s The scalar to divide by
        * @returns {Vec4}
        */
        Vec4.prototype.divideScalar = function (s) {
            if (s !== 0) {
                var invScalar = 1 / s;
                this.x *= invScalar;
                this.y *= invScalar;
                this.z *= invScalar;
                this.w *= invScalar;
            }
            else {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.w = 1;
            }
            return this;
        };
        Vec4.prototype.setAxisAngleFromQuaternion = function (q) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
            // q is assumed to be normalized
            this.w = 2 * Math.acos(q.w);
            var s = Math.sqrt(1 - q.w * q.w);
            if (s < 0.0001) {
                this.x = 1;
                this.y = 0;
                this.z = 0;
            }
            else {
                this.x = q.x / s;
                this.y = q.y / s;
                this.z = q.z / s;
            }
            return this;
        };
        Vec4.prototype.setAxisAngleFromRotationMatrix = function (m) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            var angle, x, y, z, // variables for result
            epsilon = 0.01, // margin to allow for rounding errors
            epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees
            te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
            if ((Math.abs(m12 - m21) < epsilon)
                && (Math.abs(m13 - m31) < epsilon)
                && (Math.abs(m23 - m32) < epsilon)) {
                // singularity found
                // first check for identity matrix which must have +1 for all terms
                // in leading diagonal and zero in other terms
                if ((Math.abs(m12 + m21) < epsilon2)
                    && (Math.abs(m13 + m31) < epsilon2)
                    && (Math.abs(m23 + m32) < epsilon2)
                    && (Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {
                    // this singularity is identity matrix so angle = 0
                    this.set(1, 0, 0, 0);
                    return this; // zero angle, arbitrary axis
                }
                // otherwise this singularity is angle = 180
                angle = Math.PI;
                var xx = (m11 + 1) / 2;
                var yy = (m22 + 1) / 2;
                var zz = (m33 + 1) / 2;
                var xy = (m12 + m21) / 4;
                var xz = (m13 + m31) / 4;
                var yz = (m23 + m32) / 4;
                if ((xx > yy) && (xx > zz)) {
                    // m11 is the largest diagonal term
                    if (xx < epsilon) {
                        x = 0;
                        y = 0.707106781;
                        z = 0.707106781;
                    }
                    else {
                        x = Math.sqrt(xx);
                        y = xy / x;
                        z = xz / x;
                    }
                }
                else if (yy > zz) {
                    // m22 is the largest diagonal term
                    if (yy < epsilon) {
                        x = 0.707106781;
                        y = 0;
                        z = 0.707106781;
                    }
                    else {
                        y = Math.sqrt(yy);
                        x = xy / y;
                        z = yz / y;
                    }
                }
                else {
                    // m33 is the largest diagonal term so base result on this
                    if (zz < epsilon) {
                        x = 0.707106781;
                        y = 0.707106781;
                        z = 0;
                    }
                    else {
                        z = Math.sqrt(zz);
                        x = xz / z;
                        y = yz / z;
                    }
                }
                this.set(x, y, z, angle);
                return this; // return 180 deg rotation
            }
            // as we have reached here there are no singularities so we can handle normally
            var s = Math.sqrt((m32 - m23) * (m32 - m23)
                + (m13 - m31) * (m13 - m31)
                + (m21 - m12) * (m21 - m12)); // used to normalize
            if (Math.abs(s) < 0.001)
                s = 1;
            // prevent divide by zero, should not happen if matrix is orthogonal and should be
            // caught by singularity test above, but I've left it in just in case
            this.x = (m32 - m23) / s;
            this.y = (m13 - m31) / s;
            this.z = (m21 - m12) / s;
            this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
            return this;
        };
        /**
        * Sets this vector's values to the lowest between itself and the reference vector v
        * @param {Vec4} v The reference vector
        * @returns {Vec4}
        */
        Vec4.prototype.min = function (v) {
            if (this.x > v.x)
                this.x = v.x;
            if (this.y > v.y)
                this.y = v.y;
            if (this.z > v.z)
                this.z = v.z;
            if (this.w > v.w)
                this.w = v.w;
            return this;
        };
        /**
        * Sets this vector's values to the highest between itself and the reference vector v
        * @param {Vec4} v The reference vector
        * @returns {Vec4}
        */
        Vec4.prototype.max = function (v) {
            if (this.x < v.x)
                this.x = v.x;
            if (this.y < v.y)
                this.y = v.y;
            if (this.z < v.z)
                this.z = v.z;
            if (this.w < v.w)
                this.w = v.w;
            return this;
        };
        /**
        * Clamps this vector to a min and max set of values. This function assumes min < max, if this assumption isn't true it will not operate correctly
        * @param {Vec4} min The min reference vector
        * @param {Vec4} max The max reference vector
        * @returns {Vec4}
        */
        Vec4.prototype.clamp = function (min, max) {
            // This function assumes min < max, if this assumption isn't true it will not operate correctly
            if (this.x < min.x)
                this.x = min.x;
            else if (this.x > max.x)
                this.x = max.x;
            if (this.y < min.y)
                this.y = min.y;
            else if (this.y > max.y)
                this.y = max.y;
            if (this.z < min.z)
                this.z = min.z;
            else if (this.z > max.z)
                this.z = max.z;
            if (this.w < min.w)
                this.w = min.w;
            else if (this.w > max.w)
                this.w = max.w;
            return this;
        };
        /**
        * Inverts this vector, essentially multiplying it by -1
        * @returns {Vec4}
        */
        Vec4.prototype.negate = function () {
            return this.multiplyScalar(-1);
        };
        /**
        * Returns the dot product, or scalar value, of this vector and the one passed to it. You can think of the dot as a projection
        * of the one vector onto the other. See here for a visualization: http://www.falstad.com/dotproduct/
        * @param {Vec4} v The vector to dot against
        * @returns {number}
        */
        Vec4.prototype.dot = function (v) {
            return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
        };
        /**
        * Returns the length squared of this vector
        * @returns {number}
        */
        Vec4.prototype.lengthSq = function () {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        };
        /**
        * Returns the length of this vector
        * @returns {number}
        */
        Vec4.prototype.length = function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        };
        Vec4.prototype.lengthManhattan = function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        };
        /**
        * Normalizes this vector. This essentially makes each component of the vector a value between 0 and 1
        * @returns {Vec4}
        */
        Vec4.prototype.normalize = function () {
            return this.divideScalar(this.length());
        };
        /**
        * Enlarges the vector by the scalar value l
        * @param {number} l The scalar value
        * @returns {Vec4}
        */
        Vec4.prototype.setLength = function (l) {
            var oldLength = this.length();
            if (oldLength !== 0 && l !== oldLength)
                this.multiplyScalar(l / oldLength);
            return this;
        };
        /**
        * Interpolates the values of this vector towards its reference v. The interpolation is calculated by
        * the weight value of alpha
        * @param {Vec4} v The vector to interpolate towards
        * @param {number} alpha The weight (typically from 0 to 1)
        * @returns {Vec4}
        */
        Vec4.prototype.lerp = function (v, alpha) {
            this.x += (v.x - this.x) * alpha;
            this.y += (v.y - this.y) * alpha;
            this.z += (v.z - this.z) * alpha;
            this.w += (v.w - this.w) * alpha;
            return this;
        };
        /**
        * Returns the distance from this vector to the one reference v
        * @param {Vec4} v The vector reference
        * @returns {number}
        */
        Vec4.prototype.distanceTo = function (v) {
            return Math.sqrt(this.distanceToSquared(v));
        };
        /**
        * Returns the distance squared from this vector to the reference v
        * @param {Vec4} v The vector reference
        * @returns {number}
        */
        Vec4.prototype.distanceToSquared = function (v) {
            var dx = this.x - v.x;
            var dy = this.y - v.y;
            var dz = this.z - v.z;
            var dw = this.w - v.w;
            return dx * dx + dy * dy + dz * dz + dw * dw;
        };
        /**
        * Checks if one vector's values equals anothers
        * @param {Vec4} v The reference to check against
        * @returns {boolean}
        */
        Vec4.prototype.equals = function (v) {
            return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));
        };
        /**
        * Extracts the data from an array and sets those values on this vector
        * @param {Array<number>} array The array to fetch from
        * @returns {Vec4}
        */
        Vec4.prototype.fromArray = function (array) {
            this.x = array[0];
            this.y = array[1];
            this.z = array[2];
            this.w = array[3];
            return this;
        };
        /**
        * Returns a new array with the values of this vector
        * @returns {Array<number>}
        */
        Vec4.prototype.toArray = function () {
            return [this.x, this.y, this.z, this.w];
        };
        /**
        * Clones this Vector
        * @returns {Vec4}
        */
        Vec4.prototype.clone = function () {
            return new Vec4(this.x, this.y, this.z, this.w);
        };
        return Vec4;
    }());
    Trike.Vec4 = Vec4;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A simple container that stores an array of Vec3's
    */
    var UniformArray = (function () {
        function UniformArray(values, componentSize) {
            this.values = values;
            this.componentSize = componentSize;
            this.elements = new Float32Array(componentSize * values.length);
        }
        Object.defineProperty(UniformArray.prototype, "getElements", {
            /**
            * Gets the Float32Array representation of this array
            * @returns {Float32Array}
            */
            get: function () {
                var elm = this.elements;
                var values = this.values;
                var offset = 0;
                var componentSize = this.componentSize;
                var elms;
                var ii, il;
                for (var i = 0, l = values.length; i < l; i++) {
                    offset = i * componentSize;
                    elms = values[i].getElements;
                    for (ii = 0, il = componentSize; ii < il; ii++)
                        elm[offset + ii] = elms[ii];
                }
                return elm;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Sets the points for this array container
        * @param {Array<T>} values
        * @returns {UniformArray<T>}
        */
        UniformArray.prototype.set = function (values) {
            if (values === void 0) { values = []; }
            this.values = values;
            this.elements = new Float32Array(this.componentSize * values.length);
            return this;
        };
        return UniformArray;
    }());
    Trike.UniformArray = UniformArray;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Color class that represents the typical RGB values of a color. This class does not manipulate an alpha value.
    */
    var Color = (function () {
        /**
        * Creates an instance of the color class
        */
        function Color(value) {
            if (value !== undefined)
                this.set(value);
            this.elements = new Float32Array(3);
        }
        Object.defineProperty(Color.prototype, "getElements", {
            /**
            * Gets the elements array for use in buffers and uniforms
            * @returns {Float32Array}
            */
            get: function () {
                var elm = this.elements;
                elm[0] = this.r;
                elm[1] = this.g;
                elm[2] = this.b;
                return elm;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Sets the color values of this color from either a hex number, rgb string, or source color
        * @param {any} value
        * @returns {Color}
        */
        Color.prototype.set = function (value) {
            if (value instanceof Color) {
                this.copy(value);
                return this;
            }
            switch (typeof value) {
                case 'number':
                    this.setHex(value);
                    break;
                case 'string':
                    this.setStyle(value);
                    break;
            }
            return this;
        };
        /**
        * Generates a random color
        * @returns {Color}
        */
        Color.prototype.randomColor = function () {
            return this.setRGB(Math.random() * 255, Math.random() * 255, Math.random() * 255);
        };
        /**
        * Sets the color values of this color from a hex
        * @param {number} hex
        * @returns {Color}
        */
        Color.prototype.setHex = function (hex) {
            hex = Math.floor(hex);
            this.r = (hex >> 16 & 255) / 255;
            this.g = (hex >> 8 & 255) / 255;
            this.b = (hex & 255) / 255;
            return this;
        };
        /**
        * Sets the color values of this color
        * @param {number} r
        * @param {number} g
        * @param {number} b
        * @returns {Color}
        */
        Color.prototype.setRGB = function (r, g, b) {
            this.r = r;
            this.g = g;
            this.b = b;
            return this;
        };
        /**
        * Sets the hue, saturation and lightness of this color
        * @param {number} h
        * @param {number} s
        * @param {number} l
        * @returns {Color}
        */
        Color.prototype.setHSL = function (h, s, l) {
            // h,s,l ranges are in 0.0 - 1.0
            if (s === 0) {
                this.r = this.g = this.b = l;
            }
            else {
                var hue2rgb = function (p, q, t) {
                    if (t < 0)
                        t += 1;
                    if (t > 1)
                        t -= 1;
                    if (t < 1 / 6)
                        return p + (q - p) * 6 * t;
                    if (t < 1 / 2)
                        return q;
                    if (t < 2 / 3)
                        return p + (q - p) * 6 * (2 / 3 - t);
                    return p;
                };
                var p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
                var q = (2 * l) - p;
                this.r = hue2rgb(q, p, h + 1 / 3);
                this.g = hue2rgb(q, p, h);
                this.b = hue2rgb(q, p, h - 1 / 3);
            }
            return this;
        };
        /**
        * Parses a style string and assignes the values to this.
        * @param {string} style eg: rgb(255,255,255)
        * @returns {Color}
        */
        Color.prototype.setStyle = function (style) {
            // rgb(255,0,0)
            if (/^rgb\((\d+),(\d+),(\d+)\)$/i.test(style)) {
                var color = /^rgb\((\d+),(\d+),(\d+)\)$/i.exec(style);
                this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                return this;
            }
            // rgb(100%,0%,0%)
            if (/^rgb\((\d+)\%,(\d+)\%,(\d+)\%\)$/i.test(style)) {
                var color = /^rgb\((\d+)\%,(\d+)\%,(\d+)\%\)$/i.exec(style);
                this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                return this;
            }
            // #ff0000
            if (/^\#([0-9a-f]{6})$/i.test(style)) {
                var color = /^\#([0-9a-f]{6})$/i.exec(style);
                this.setHex(parseInt(color[1], 16));
                return this;
            }
            // #f00
            if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(style)) {
                var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(style);
                this.setHex(parseInt(color[1] + color[1] + color[2] + color[2] + color[3] + color[3], 16));
                return this;
            }
            // red
            if (/^(\w+)$/i.test(style)) {
                this.setHex(Color[style]);
                return this;
            }
        };
        /**
        * Copies the values of color to this
        * @returns {Color}
        */
        Color.prototype.copy = function (color) {
            this.r = color.r;
            this.g = color.g;
            this.b = color.b;
            return this;
        };
        /**
        * Copies the gama to linear values of color into this ( each component of color is squared and assigned to this )
        * @param {Color} color
        * @returns {Color}
        */
        Color.prototype.copyGammaToLinear = function (color) {
            this.r = color.r * color.r;
            this.g = color.g * color.g;
            this.b = color.b * color.b;
            return this;
        };
        /**
        * Copies the linear to gama values of color into this ( each component of color is square rooted and assigned to this )
        * @param {Color} color
        * @returns {Color}
        */
        Color.prototype.copyLinearToGamma = function (color) {
            this.r = Math.sqrt(color.r);
            this.g = Math.sqrt(color.g);
            this.b = Math.sqrt(color.b);
            return this;
        };
        /**
        * Converts the values of this color from gama to linear (each component is squared)
        * @returns {Color}
        */
        Color.prototype.convertGammaToLinear = function () {
            var r = this.r, g = this.g, b = this.b;
            this.r = r * r;
            this.g = g * g;
            this.b = b * b;
            return this;
        };
        /**
        * Converts the values of this color from linear to gama (each component is square rooted)
        * @returns {Color}
        */
        Color.prototype.convertLinearToGamma = function () {
            this.r = Math.sqrt(this.r);
            this.g = Math.sqrt(this.g);
            this.b = Math.sqrt(this.b);
            return this;
        };
        /**
        * Gets the hex value of this color as a number
        * @returns {number}
        */
        Color.prototype.getHex = function () {
            return (this.r * 255) << 16 ^ (this.g * 255) << 8 ^ (this.b * 255) << 0;
        };
        /**
        * Gets the hex string of this color
        * @returns {string}
        */
        Color.prototype.getHexString = function () {
            return ('000000' + this.getHex().toString(16)).slice(-6);
        };
        /**
        * Gets the Hue, Saturation and Lightness
        * @returns { h: number; s: number; l: number;}
        */
        Color.prototype.getHSL = function () {
            var hsl = { h: 0, s: 0, l: 0 };
            // h,s,l ranges are in 0.0 - 1.0
            var r = this.r, g = this.g, b = this.b;
            var max = Math.max(r, g, b);
            var min = Math.min(r, g, b);
            var hue, saturation;
            var lightness = (min + max) / 2.0;
            if (min === max) {
                hue = 0;
                saturation = 0;
            }
            else {
                var delta = max - min;
                saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
                switch (max) {
                    case r:
                        hue = (g - b) / delta + (g < b ? 6 : 0);
                        break;
                    case g:
                        hue = (b - r) / delta + 2;
                        break;
                    case b:
                        hue = (r - g) / delta + 4;
                        break;
                }
                hue /= 6;
            }
            hsl.h = hue;
            hsl.s = saturation;
            hsl.l = lightness;
            return hsl;
        };
        /**
        * Gets the color as an HTML style eg 'rgb(255,255,255)'
        * @returns {string}
        */
        Color.prototype.getStyle = function () {
            return 'rgb(' + ((this.r * 255) | 0) + ',' + ((this.g * 255) | 0) + ',' + ((this.b * 255) | 0) + ')';
        };
        /**
        * Offsets (adds to) the Hue Saturation and lightness of this colour
        * @param {number} h
        * @param {number} s
        * @param {number} l
        * @returns {Color}
        */
        Color.prototype.offsetHSL = function (h, s, l) {
            var hsl = this.getHSL();
            hsl.h += h;
            hsl.s += s;
            hsl.l += l;
            this.setHSL(hsl.h, hsl.s, hsl.l);
            return this;
        };
        /**
        * Adds the color components to this
        * @param {Color} color
        * @returns {Color}
        */
        Color.prototype.add = function (color) {
            this.r += color.r;
            this.g += color.g;
            this.b += color.b;
            return this;
        };
        /**
        * Adds the two colors and assigns the values to this
        * @param {Color} color1
        * @param {Color} color2
        * @returns {Color}
        */
        Color.prototype.addColors = function (color1, color2) {
            this.r = color1.r + color2.r;
            this.g = color1.g + color2.g;
            this.b = color1.b + color2.b;
            return this;
        };
        /**
        * Adds the values of the given color to this color
        * @param {Color} s
        * @returns {Color}
        */
        Color.prototype.addScalar = function (s) {
            this.r += s;
            this.g += s;
            this.b += s;
            return this;
        };
        /**
        * Multiplies this color with given color
        * @param {Color} color
        * @returns {Color}
        */
        Color.prototype.multiply = function (color) {
            this.r *= color.r;
            this.g *= color.g;
            this.b *= color.b;
            return this;
        };
        /**
        * Multiplies this color by the given scalar
        * @param {number} s
        * @returns {Color}
        */
        Color.prototype.multiplyScalar = function (s) {
            this.r *= s;
            this.g *= s;
            this.b *= s;
            return this;
        };
        /**
        * Interpolates this with the color parameter at weight w
        * @param {Color} color The color to interpolate to
        * @param {number} w The weight of the interpolation
        * @returns {Color}
        */
        Color.prototype.lerp = function (color, w) {
            this.r += (color.r - this.r) * w;
            this.g += (color.g - this.g) * w;
            this.b += (color.b - this.b) * w;
            return this;
        };
        /**
        * Gets a clone of this color
        * @returns {Color}
        */
        Color.prototype.clone = function () {
            return new Color().setRGB(this.r, this.g, this.b);
        };
        Color.aliceblue = function (c) {
            if (c === void 0) { c = 0xF0F8FF; }
            return new Color(c);
        };
        Color.antiquewhite = function (c) {
            if (c === void 0) { c = 0xFAEBD7; }
            return new Color(c);
        };
        Color.aqua = function (c) {
            if (c === void 0) { c = 0x00FFFF; }
            return new Color(c);
        };
        Color.aquamarine = function (c) {
            if (c === void 0) { c = 0x7FFFD4; }
            return new Color(c);
        };
        Color.azure = function (c) {
            if (c === void 0) { c = 0xF0FFFF; }
            return new Color(c);
        };
        Color.beige = function (c) {
            if (c === void 0) { c = 0xF5F5DC; }
            return new Color(c);
        };
        Color.bisque = function (c) {
            if (c === void 0) { c = 0xFFE4C4; }
            return new Color(c);
        };
        Color.black = function (c) {
            if (c === void 0) { c = 0x000000; }
            return new Color(c);
        };
        Color.blanchedalmond = function (c) {
            if (c === void 0) { c = 0xFFEBCD; }
            return new Color(c);
        };
        Color.blue = function (c) {
            if (c === void 0) { c = 0x0000FF; }
            return new Color(c);
        };
        Color.blueviolet = function (c) {
            if (c === void 0) { c = 0x8A2BE2; }
            return new Color(c);
        };
        Color.brown = function (c) {
            if (c === void 0) { c = 0xA52A2A; }
            return new Color(c);
        };
        Color.burlywood = function (c) {
            if (c === void 0) { c = 0xDEB887; }
            return new Color(c);
        };
        Color.cadetblue = function (c) {
            if (c === void 0) { c = 0x5F9EA0; }
            return new Color(c);
        };
        Color.chartreuse = function (c) {
            if (c === void 0) { c = 0x7FFF00; }
            return new Color(c);
        };
        Color.chocolate = function (c) {
            if (c === void 0) { c = 0xD2691E; }
            return new Color(c);
        };
        Color.coral = function (c) {
            if (c === void 0) { c = 0xFF7F50; }
            return new Color(c);
        };
        Color.cornflowerblue = function (c) {
            if (c === void 0) { c = 0x6495ED; }
            return new Color(c);
        };
        Color.cornsilk = function (c) {
            if (c === void 0) { c = 0xFFF8DC; }
            return new Color(c);
        };
        Color.crimson = function (c) {
            if (c === void 0) { c = 0xDC143C; }
            return new Color(c);
        };
        Color.cyan = function (c) {
            if (c === void 0) { c = 0x00FFFF; }
            return new Color(c);
        };
        Color.darkblue = function (c) {
            if (c === void 0) { c = 0x00008B; }
            return new Color(c);
        };
        Color.darkcyan = function (c) {
            if (c === void 0) { c = 0x008B8B; }
            return new Color(c);
        };
        Color.darkgoldenrod = function (c) {
            if (c === void 0) { c = 0xB8860B; }
            return new Color(c);
        };
        Color.darkgray = function (c) {
            if (c === void 0) { c = 0xA9A9A9; }
            return new Color(c);
        };
        Color.darkgreen = function (c) {
            if (c === void 0) { c = 0x006400; }
            return new Color(c);
        };
        Color.darkgrey = function (c) {
            if (c === void 0) { c = 0xA9A9A9; }
            return new Color(c);
        };
        Color.darkkhaki = function (c) {
            if (c === void 0) { c = 0xBDB76B; }
            return new Color(c);
        };
        Color.darkmagenta = function (c) {
            if (c === void 0) { c = 0x8B008B; }
            return new Color(c);
        };
        Color.darkolivegreen = function (c) {
            if (c === void 0) { c = 0x556B2F; }
            return new Color(c);
        };
        Color.darkorange = function (c) {
            if (c === void 0) { c = 0xFF8C00; }
            return new Color(c);
        };
        Color.darkorchid = function (c) {
            if (c === void 0) { c = 0x9932CC; }
            return new Color(c);
        };
        Color.darkred = function (c) {
            if (c === void 0) { c = 0x8B0000; }
            return new Color(c);
        };
        Color.darksalmon = function (c) {
            if (c === void 0) { c = 0xE9967A; }
            return new Color(c);
        };
        Color.darkseagreen = function (c) {
            if (c === void 0) { c = 0x8FBC8F; }
            return new Color(c);
        };
        Color.darkslateblue = function (c) {
            if (c === void 0) { c = 0x483D8B; }
            return new Color(c);
        };
        Color.darkslategray = function (c) {
            if (c === void 0) { c = 0x2F4F4F; }
            return new Color(c);
        };
        Color.darkslategrey = function (c) {
            if (c === void 0) { c = 0x2F4F4F; }
            return new Color(c);
        };
        Color.darkturquoise = function (c) {
            if (c === void 0) { c = 0x00CED1; }
            return new Color(c);
        };
        Color.darkviolet = function (c) {
            if (c === void 0) { c = 0x9400D3; }
            return new Color(c);
        };
        Color.deeppink = function (c) {
            if (c === void 0) { c = 0xFF1493; }
            return new Color(c);
        };
        Color.deepskyblue = function (c) {
            if (c === void 0) { c = 0x00BFFF; }
            return new Color(c);
        };
        Color.dimgray = function (c) {
            if (c === void 0) { c = 0x696969; }
            return new Color(c);
        };
        Color.dimgrey = function (c) {
            if (c === void 0) { c = 0x696969; }
            return new Color(c);
        };
        Color.dodgerblue = function (c) {
            if (c === void 0) { c = 0x1E90FF; }
            return new Color(c);
        };
        Color.firebrick = function (c) {
            if (c === void 0) { c = 0xB22222; }
            return new Color(c);
        };
        Color.floralwhite = function (c) {
            if (c === void 0) { c = 0xFFFAF0; }
            return new Color(c);
        };
        Color.forestgreen = function (c) {
            if (c === void 0) { c = 0x228B22; }
            return new Color(c);
        };
        Color.fuchsia = function (c) {
            if (c === void 0) { c = 0xFF00FF; }
            return new Color(c);
        };
        Color.gainsboro = function (c) {
            if (c === void 0) { c = 0xDCDCDC; }
            return new Color(c);
        };
        Color.ghostwhite = function (c) {
            if (c === void 0) { c = 0xF8F8FF; }
            return new Color(c);
        };
        Color.gold = function (c) {
            if (c === void 0) { c = 0xFFD700; }
            return new Color(c);
        };
        Color.goldenrod = function (c) {
            if (c === void 0) { c = 0xDAA520; }
            return new Color(c);
        };
        Color.gray = function (c) {
            if (c === void 0) { c = 0x808080; }
            return new Color(c);
        };
        Color.green = function (c) {
            if (c === void 0) { c = 0x008000; }
            return new Color(c);
        };
        Color.greenyellow = function (c) {
            if (c === void 0) { c = 0xADFF2F; }
            return new Color(c);
        };
        Color.grey = function (c) {
            if (c === void 0) { c = 0x808080; }
            return new Color(c);
        };
        Color.honeydew = function (c) {
            if (c === void 0) { c = 0xF0FFF0; }
            return new Color(c);
        };
        Color.hotpink = function (c) {
            if (c === void 0) { c = 0xFF69B4; }
            return new Color(c);
        };
        Color.indianred = function (c) {
            if (c === void 0) { c = 0xCD5C5C; }
            return new Color(c);
        };
        Color.indigo = function (c) {
            if (c === void 0) { c = 0x4B0082; }
            return new Color(c);
        };
        Color.ivory = function (c) {
            if (c === void 0) { c = 0xFFFFF0; }
            return new Color(c);
        };
        Color.khaki = function (c) {
            if (c === void 0) { c = 0xF0E68C; }
            return new Color(c);
        };
        Color.lavender = function (c) {
            if (c === void 0) { c = 0xE6E6FA; }
            return new Color(c);
        };
        Color.lavenderblush = function (c) {
            if (c === void 0) { c = 0xFFF0F5; }
            return new Color(c);
        };
        Color.lawngreen = function (c) {
            if (c === void 0) { c = 0x7CFC00; }
            return new Color(c);
        };
        Color.lemonchiffon = function (c) {
            if (c === void 0) { c = 0xFFFACD; }
            return new Color(c);
        };
        Color.lightblue = function (c) {
            if (c === void 0) { c = 0xADD8E6; }
            return new Color(c);
        };
        Color.lightcoral = function (c) {
            if (c === void 0) { c = 0xF08080; }
            return new Color(c);
        };
        Color.lightcyan = function (c) {
            if (c === void 0) { c = 0xE0FFFF; }
            return new Color(c);
        };
        Color.lightgoldenrodyellow = function (c) {
            if (c === void 0) { c = 0xFAFAD2; }
            return new Color(c);
        };
        Color.lightgray = function (c) {
            if (c === void 0) { c = 0xD3D3D3; }
            return new Color(c);
        };
        Color.lightgreen = function (c) {
            if (c === void 0) { c = 0x90EE90; }
            return new Color(c);
        };
        Color.lightgrey = function (c) {
            if (c === void 0) { c = 0xD3D3D3; }
            return new Color(c);
        };
        Color.lightpink = function (c) {
            if (c === void 0) { c = 0xFFB6C1; }
            return new Color(c);
        };
        Color.lightsalmon = function (c) {
            if (c === void 0) { c = 0xFFA07A; }
            return new Color(c);
        };
        Color.lightseagreen = function (c) {
            if (c === void 0) { c = 0x20B2AA; }
            return new Color(c);
        };
        Color.lightskyblue = function (c) {
            if (c === void 0) { c = 0x87CEFA; }
            return new Color(c);
        };
        Color.lightslategray = function (c) {
            if (c === void 0) { c = 0x778899; }
            return new Color(c);
        };
        Color.lightslategrey = function (c) {
            if (c === void 0) { c = 0x778899; }
            return new Color(c);
        };
        Color.lightsteelblue = function (c) {
            if (c === void 0) { c = 0xB0C4DE; }
            return new Color(c);
        };
        Color.lightyellow = function (c) {
            if (c === void 0) { c = 0xFFFFE0; }
            return new Color(c);
        };
        Color.lime = function (c) {
            if (c === void 0) { c = 0x00FF00; }
            return new Color(c);
        };
        Color.limegreen = function (c) {
            if (c === void 0) { c = 0x32CD32; }
            return new Color(c);
        };
        Color.linen = function (c) {
            if (c === void 0) { c = 0xFAF0E6; }
            return new Color(c);
        };
        Color.magenta = function (c) {
            if (c === void 0) { c = 0xFF00FF; }
            return new Color(c);
        };
        Color.maroon = function (c) {
            if (c === void 0) { c = 0x800000; }
            return new Color(c);
        };
        Color.mediumaquamarine = function (c) {
            if (c === void 0) { c = 0x66CDAA; }
            return new Color(c);
        };
        Color.mediumblue = function (c) {
            if (c === void 0) { c = 0x0000CD; }
            return new Color(c);
        };
        Color.mediumorchid = function (c) {
            if (c === void 0) { c = 0xBA55D3; }
            return new Color(c);
        };
        Color.mediumpurple = function (c) {
            if (c === void 0) { c = 0x9370DB; }
            return new Color(c);
        };
        Color.mediumseagreen = function (c) {
            if (c === void 0) { c = 0x3CB371; }
            return new Color(c);
        };
        Color.mediumslateblue = function (c) {
            if (c === void 0) { c = 0x7B68EE; }
            return new Color(c);
        };
        Color.mediumspringgreen = function (c) {
            if (c === void 0) { c = 0x00FA9A; }
            return new Color(c);
        };
        Color.mediumturquoise = function (c) {
            if (c === void 0) { c = 0x48D1CC; }
            return new Color(c);
        };
        Color.mediumvioletred = function (c) {
            if (c === void 0) { c = 0xC71585; }
            return new Color(c);
        };
        Color.midnightblue = function (c) {
            if (c === void 0) { c = 0x191970; }
            return new Color(c);
        };
        Color.mintcream = function (c) {
            if (c === void 0) { c = 0xF5FFFA; }
            return new Color(c);
        };
        Color.mistyrose = function (c) {
            if (c === void 0) { c = 0xFFE4E1; }
            return new Color(c);
        };
        Color.moccasin = function (c) {
            if (c === void 0) { c = 0xFFE4B5; }
            return new Color(c);
        };
        Color.navajowhite = function (c) {
            if (c === void 0) { c = 0xFFDEAD; }
            return new Color(c);
        };
        Color.navy = function (c) {
            if (c === void 0) { c = 0x000080; }
            return new Color(c);
        };
        Color.oldlace = function (c) {
            if (c === void 0) { c = 0xFDF5E6; }
            return new Color(c);
        };
        Color.olive = function (c) {
            if (c === void 0) { c = 0x808000; }
            return new Color(c);
        };
        Color.olivedrab = function (c) {
            if (c === void 0) { c = 0x6B8E23; }
            return new Color(c);
        };
        Color.orange = function (c) {
            if (c === void 0) { c = 0xFFA500; }
            return new Color(c);
        };
        Color.orangered = function (c) {
            if (c === void 0) { c = 0xFF4500; }
            return new Color(c);
        };
        Color.orchid = function (c) {
            if (c === void 0) { c = 0xDA70D6; }
            return new Color(c);
        };
        Color.palegoldenrod = function (c) {
            if (c === void 0) { c = 0xEEE8AA; }
            return new Color(c);
        };
        Color.palegreen = function (c) {
            if (c === void 0) { c = 0x98FB98; }
            return new Color(c);
        };
        Color.paleturquoise = function (c) {
            if (c === void 0) { c = 0xAFEEEE; }
            return new Color(c);
        };
        Color.palevioletred = function (c) {
            if (c === void 0) { c = 0xDB7093; }
            return new Color(c);
        };
        Color.papayawhip = function (c) {
            if (c === void 0) { c = 0xFFEFD5; }
            return new Color(c);
        };
        Color.peachpuff = function (c) {
            if (c === void 0) { c = 0xFFDAB9; }
            return new Color(c);
        };
        Color.peru = function (c) {
            if (c === void 0) { c = 0xCD853F; }
            return new Color(c);
        };
        Color.pink = function (c) {
            if (c === void 0) { c = 0xFFC0CB; }
            return new Color(c);
        };
        Color.plum = function (c) {
            if (c === void 0) { c = 0xDDA0DD; }
            return new Color(c);
        };
        Color.powderblue = function (c) {
            if (c === void 0) { c = 0xB0E0E6; }
            return new Color(c);
        };
        Color.purple = function (c) {
            if (c === void 0) { c = 0x800080; }
            return new Color(c);
        };
        Color.red = function (c) {
            if (c === void 0) { c = 0xFF0000; }
            return new Color(c);
        };
        Color.rosybrown = function (c) {
            if (c === void 0) { c = 0xBC8F8F; }
            return new Color(c);
        };
        Color.royalblue = function (c) {
            if (c === void 0) { c = 0x4169E1; }
            return new Color(c);
        };
        Color.saddlebrown = function (c) {
            if (c === void 0) { c = 0x8B4513; }
            return new Color(c);
        };
        Color.salmon = function (c) {
            if (c === void 0) { c = 0xFA8072; }
            return new Color(c);
        };
        Color.sandybrown = function (c) {
            if (c === void 0) { c = 0xF4A460; }
            return new Color(c);
        };
        Color.seagreen = function (c) {
            if (c === void 0) { c = 0x2E8B57; }
            return new Color(c);
        };
        Color.seashell = function (c) {
            if (c === void 0) { c = 0xFFF5EE; }
            return new Color(c);
        };
        Color.sienna = function (c) {
            if (c === void 0) { c = 0xA0522D; }
            return new Color(c);
        };
        Color.silver = function (c) {
            if (c === void 0) { c = 0xC0C0C0; }
            return new Color(c);
        };
        Color.skyblue = function (c) {
            if (c === void 0) { c = 0x87CEEB; }
            return new Color(c);
        };
        Color.slateblue = function (c) {
            if (c === void 0) { c = 0x6A5ACD; }
            return new Color(c);
        };
        Color.slategray = function (c) {
            if (c === void 0) { c = 0x708090; }
            return new Color(c);
        };
        Color.slategrey = function (c) {
            if (c === void 0) { c = 0x708090; }
            return new Color(c);
        };
        Color.snow = function (c) {
            if (c === void 0) { c = 0xFFFAFA; }
            return new Color(c);
        };
        Color.springgreen = function (c) {
            if (c === void 0) { c = 0x00FF7F; }
            return new Color(c);
        };
        Color.steelblue = function (c) {
            if (c === void 0) { c = 0x4682B4; }
            return new Color(c);
        };
        Color.tan = function (c) {
            if (c === void 0) { c = 0xD2B48C; }
            return new Color(c);
        };
        Color.teal = function (c) {
            if (c === void 0) { c = 0x008080; }
            return new Color(c);
        };
        Color.thistle = function (c) {
            if (c === void 0) { c = 0xD8BFD8; }
            return new Color(c);
        };
        Color.tomato = function (c) {
            if (c === void 0) { c = 0xFF6347; }
            return new Color(c);
        };
        Color.turquoise = function (c) {
            if (c === void 0) { c = 0x40E0D0; }
            return new Color(c);
        };
        Color.violet = function (c) {
            if (c === void 0) { c = 0xEE82EE; }
            return new Color(c);
        };
        Color.wheat = function (c) {
            if (c === void 0) { c = 0xF5DEB3; }
            return new Color(c);
        };
        Color.white = function (c) {
            if (c === void 0) { c = 0xFFFFFF; }
            return new Color(c);
        };
        Color.whitesmoke = function (c) {
            if (c === void 0) { c = 0xF5F5F5; }
            return new Color(c);
        };
        Color.yellow = function (c) {
            if (c === void 0) { c = 0xFFFF00; }
            return new Color(c);
        };
        Color.yellowgreen = function (c) {
            if (c === void 0) { c = 0x9ACD32; }
            return new Color(c);
        };
        return Color;
    }());
    Trike.Color = Color;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A class to mathematically represent 3D boxes
    */
    var Box3 = (function () {
        /**
        * Creates a new box instance
        * @param {Vec3} min [Optional] The minimum point of the box
        * @param {Vec3} max [Optional] The maximum point of the box
        */
        function Box3(min, max) {
            this.min = (min !== undefined) ? min : new Trike.Vec3(Infinity, Infinity, Infinity);
            this.max = (max !== undefined) ? max : new Trike.Vec3(-Infinity, -Infinity, -Infinity);
            if (!Box3._v1) {
                Box3._v1 = new Trike.Vec3();
                Box3._points = [new Trike.Vec3(), new Trike.Vec3(), new Trike.Vec3(), new Trike.Vec3(), new Trike.Vec3(), new Trike.Vec3(), new Trike.Vec3(), new Trike.Vec3()];
            }
        }
        /**
        * Sets the dimensions of the box
        * @param {Vec3} min The minimum point of the box
        * @param {Vec3} max The maximum point of the box
        * @returns {Box3}
        */
        Box3.prototype.set = function (min, max) {
            this.min.copy(min);
            this.max.copy(max);
            return this;
        };
        /**
        * Adjusts the dimensions of the box by intersecting it with an additional point. This will
        * cause the box to grow.
        * @param {Vec3} point The point to add
        * @returns {Box3}
        */
        Box3.prototype.addPoint = function (point) {
            var min = this.min;
            var max = this.max;
            if (point.x < min.x) {
                min.x = point.x;
            }
            else if (point.x > max.x) {
                max.x = point.x;
            }
            if (point.y < min.y) {
                min.y = point.y;
            }
            else if (point.y > max.y) {
                max.y = point.y;
            }
            if (point.z < min.z) {
                min.z = point.z;
            }
            else if (point.z > max.z) {
                max.z = point.z;
            }
            return this;
        };
        /**
        * Adjusts the dimensions of the box by intersecting it with an additional point's xyz. This will
        * cause the box to grow.
        * @param {number} x The x position of the point
        * @param {number} y The y position of the point
        * @param {number} z The z position of the point
        * @returns {Box3}
        */
        Box3.prototype.addPointXYZ = function (x, y, z) {
            var min = this.min;
            var max = this.max;
            if (x < min.x) {
                min.x = x;
            }
            else if (x > max.x) {
                max.x = x;
            }
            if (y < min.y) {
                min.y = y;
            }
            else if (y > max.y) {
                max.y = y;
            }
            if (z < min.z) {
                min.z = z;
            }
            else if (z > max.z) {
                max.z = z;
            }
            return this;
        };
        /**
        * Sets the dimensions of this box based on an array of Vec3 points
        * @param {Array<Vec3>} points The points to set dimensions from
        * @returns {Box3}
        */
        Box3.prototype.setFromPoints = function (points) {
            if (points.length > 0) {
                var point = points[0];
                this.min.copy(point);
                this.max.copy(point);
                for (var i = 1, il = points.length; i < il; i++) {
                    this.addPoint(points[i]);
                }
            }
            else {
                this.makeEmpty();
            }
            return this;
        };
        /**
        * Sets the dimensions of this box based on a center point and a size vector
        * @param {Vec3} center The center of the box
        * @param {Vec3} size The scalar dimensions width, height, depth
        * @returns {Box3}
        */
        Box3.prototype.setFromCenterAndSize = function (center, size) {
            var v1 = Box3._v1;
            var halfSize = v1.copy(size).multiplyScalar(0.5);
            this.min.copy(center).sub(halfSize);
            this.max.copy(center).add(halfSize);
            return this;
        };
        /**
        * Sets the dimensions of this box based on the vertices of an object and all its mesh children
        * @param {Object3D} object The object to extract dimensions from
        * @returns {Box3}
        */
        Box3.prototype.setFromObject = function (object) {
            // Computes the world-axis-aligned bounding box of an object (including its children),
            // accounting for both the object's, and childrens', world transforms
            var v1 = Box3._v1;
            var scope = this;
            object.updateWorldMatrix(true);
            this.makeEmpty();
            var nodes = object.getAllChildren();
            for (var i = 0, len = nodes.length; i < len; i++) {
                var node = nodes[i];
                if (node.geometry !== undefined && node.geometry.buffers[Trike.AttributeType.POSITION].data !== undefined) {
                    var vertices = node.geometry.buffers[Trike.AttributeType.POSITION].data;
                    for (var i_1 = 0, il = vertices.length; i_1 < il; i_1++) {
                        v1.copy(vertices[i_1]);
                        v1.applyMatrix4(node.worldMatrix);
                        scope.expandByPoint(v1);
                    }
                }
            }
            return this;
        };
        /**
        * Copies the dimensions of box b
        * @param {Box3} b The box to copy from
        * @returns {Box3}
        */
        Box3.prototype.copy = function (b) {
            this.min.copy(b.min);
            this.max.copy(b.max);
            return this;
        };
        /**
        * Sets the min and max dimensions to Infinity values
        * @returns {Box3}
        */
        Box3.prototype.makeEmpty = function () {
            this.min.x = this.min.y = this.min.z = Infinity;
            this.max.x = this.max.y = this.max.z = -Infinity;
            return this;
        };
        /**
        * Checks if the volume of this box is empty
        * @returns {boolean}
        */
        Box3.prototype.empty = function () {
            // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
            return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);
        };
        /**
        * Gets the center of this box
        * @param {Vec3} ref [Optional] The optional vector to fill
        * @returns {Vec3}
        */
        Box3.prototype.center = function (ref) {
            var result = ref || new Trike.Vec3();
            return result.addVectors(this.min, this.max).multiplyScalar(0.5);
        };
        /**
        * Gets the scalar sizes of this box as a Vec3. Width in x, height in y, depth in z
        * @param {Vec3} ref [Optional] The optional vector to fill
        * @returns {Vec3}
        */
        Box3.prototype.size = function (ref) {
            var result = ref || new Trike.Vec3();
            return result.subVectors(this.max, this.min);
        };
        /**
        * Expands the box dimensions by a point reference
        * @param {Vec3} point The point to expand to
        * @returns {Box3}
        */
        Box3.prototype.expandByPoint = function (point) {
            this.min.min(point);
            this.max.max(point);
            return this;
        };
        /**
        * Expands the box dimensions by a vector reference
        * @param {Vec3} vector The vector to expand to
        * @returns {Box3}
        */
        Box3.prototype.expandByVector = function (vector) {
            this.min.sub(vector);
            this.max.add(vector);
            return this;
        };
        /**
        * Expands the box dimensions by a scalar value
        * @param {number} scalar
        * @returns {Box3}
        */
        Box3.prototype.expandByScalar = function (scalar) {
            this.min.addScalar(-scalar);
            this.max.addScalar(scalar);
            return this;
        };
        /**
        * Checks if this box contains a point p
        * @param {number} scalar
        * @returns {boolean}
        */
        Box3.prototype.containsPoint = function (p) {
            if (p.x < this.min.x || p.x > this.max.x ||
                p.y < this.min.y || p.y > this.max.y ||
                p.z < this.min.z || p.z > this.max.z) {
                return false;
            }
            return true;
        };
        /**
        * Checks if this box contains another box
        * @param {Box3} box
        * @returns {boolean}
        */
        Box3.prototype.containsBox = function (box) {
            if ((this.min.x <= box.min.x) && (box.max.x <= this.max.x) &&
                (this.min.y <= box.min.y) && (box.max.y <= this.max.y) &&
                (this.min.z <= box.min.z) && (box.max.z <= this.max.z)) {
                return true;
            }
            return false;
        };
        /**
        * Checks if this box intersects another box
        * @param {Box3} box
        * @returns {boolean}
        */
        Box3.prototype.isIntersectionBox = function (box) {
            // using 6 splitting planes to rule out intersections.
            if (box.max.x < this.min.x || box.min.x > this.max.x ||
                box.max.y < this.min.y || box.min.y > this.max.y ||
                box.max.z < this.min.z || box.min.z > this.max.z) {
                return false;
            }
            return true;
        };
        /**
        * Makes sure a point p is within the boundaries of this box
        * @param {Vec3} point
        * @param {Vec3} ref [Optional]
        * @returns {Vec3}
        */
        Box3.prototype.clampPoint = function (p, ref) {
            var result = ref || new Trike.Vec3();
            return result.copy(p).clamp(this.min, this.max);
        };
        /**
        * Gets the distance of this box to a given point p
        * @param {Vec3} p The point to check against
        * @returns {number}
        */
        Box3.prototype.distanceToPoint = function (p) {
            var v1 = Box3._v1;
            var clampedPoint = v1.copy(p).clamp(this.min, this.max);
            return clampedPoint.sub(p).length();
        };
        /**
        * Gets a bounding sphere of this box
        * @param {Sphere} ref [Optional] A sphere to fill
        * @returns {Sphere}
        */
        Box3.prototype.getBoundingSphere = function (ref) {
            var v1 = Box3._v1;
            var result = ref || new Trike.Sphere();
            result.center.copy(this.center(v1));
            result.radius = this.size(v1).length() * 0.5;
            return result;
        };
        /**
        * Intersects this box with another box b
        * @param {Box3} b
        * @returns {Box3}
        */
        Box3.prototype.intersect = function (b) {
            this.min.max(b.min);
            this.max.min(b.max);
            return this;
        };
        /**
        * Unions this box with another box b
        * @param {Box3} b
        * @returns {Box3}
        */
        Box3.prototype.union = function (b) {
            this.min.min(b.min);
            this.max.max(b.max);
            return this;
        };
        /**
        * Applies a matrix to this box's coordinates
        * @param {Matrix4} matrix
        * @returns {Box3}
        */
        Box3.prototype.applyMatrix4 = function (matrix) {
            var points = Box3._points;
            // NOTE: I am using a binary pattern to specify all 2^3 combinations below
            points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
            points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
            points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
            points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
            points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
            points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
            points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
            points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111
            this.makeEmpty();
            this.setFromPoints(points);
            return this;
        };
        /**
        * Moves this box by a given offset
        * @param {Vec3} offset The offset to move the box
        * @returns {Box3}
        */
        Box3.prototype.translate = function (offset) {
            this.min.add(offset);
            this.max.add(offset);
            return this;
        };
        /**
        * Checks if this box's dimensions match a reference box b
        * @param {Box3} b The box to check against
        * @returns {boolean}
        */
        Box3.prototype.equals = function (b) {
            return b.min.equals(this.min) && b.max.equals(this.max);
        };
        /**
        * Copies this box into a new object
        * @returns {boolean}
        */
        Box3.prototype.clone = function () {
            return new Box3().copy(this);
        };
        return Box3;
    }());
    Trike.Box3 = Box3;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    var Line3 = (function () {
        function Line3(start, end) {
            this.start = (start !== undefined) ? start : new Trike.Vec3();
            this.end = (end !== undefined) ? end : new Trike.Vec3();
        }
        Line3.prototype.set = function (start, end) {
            this.start.copy(start);
            this.end.copy(end);
            return this;
        };
        Line3.prototype.copy = function (line) {
            this.start.copy(line.start);
            this.end.copy(line.end);
            return this;
        };
        Line3.prototype.center = function (optionalTarget) {
            var result = optionalTarget || new Trike.Vec3();
            return result.addVectors(this.start, this.end).multiplyScalar(0.5);
        };
        Line3.prototype.delta = function (optionalTarget) {
            var result = optionalTarget || new Trike.Vec3();
            return result.subVectors(this.end, this.start);
        };
        Line3.prototype.distanceSq = function () {
            return this.start.distanceToSquared(this.end);
        };
        Line3.prototype.distance = function () {
            return this.start.distanceTo(this.end);
        };
        Line3.prototype.at = function (t, optionalTarget) {
            var result = optionalTarget || new Trike.Vec3();
            return this.delta(result).multiplyScalar(t).add(this.start);
        };
        Line3.prototype.closestPointToPointParameter = function (point, clampToLine) {
            var startP = new Trike.Vec3();
            var startEnd = new Trike.Vec3();
            startP.subVectors(point, this.start);
            startEnd.subVectors(this.end, this.start);
            var startEnd2 = startEnd.dot(startEnd);
            var startEnd_startP = startEnd.dot(startP);
            var t = startEnd_startP / startEnd2;
            if (clampToLine) {
                t = Trike.MathUtils.clamp(t, 0, 1);
            }
            return t;
        };
        Line3.prototype.closestPointToPoint = function (point, clampToLine, optionalTarget) {
            var t = this.closestPointToPointParameter(point, clampToLine);
            var result = optionalTarget || new Trike.Vec3();
            return this.delta(result).multiplyScalar(t).add(this.start);
        };
        Line3.prototype.applyMatrix4 = function (matrix) {
            this.start.applyMatrix4(matrix);
            this.end.applyMatrix4(matrix);
            return this;
        };
        Line3.prototype.equals = function (line) {
            return line.start.equals(this.start) && line.end.equals(this.end);
        };
        Line3.prototype.clone = function () {
            return new Line3().copy(this);
        };
        return Line3;
    }());
    Trike.Line3 = Line3;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A class to mathematically represent 3D spheres
    */
    var Sphere = (function () {
        /**
        * Creates a new Sphere instance
        * @param {Vec3} center [Optional] The center of the sphere
        * @param {number} radius [Optional] The radius of the sphere
        */
        function Sphere(center, radius) {
            this.center = (center !== undefined) ? center : new Trike.Vec3();
            this.radius = (radius !== undefined) ? radius : 0;
            if (!Sphere._box)
                Sphere._box = new Trike.Box3();
        }
        /**
        * Sets the dimensions of this sphere
        * @param {Vec3} center The center of the sphere
        * @param {number} radius The radius of the sphere
        * @returns {Sphere}
        */
        Sphere.prototype.set = function (center, radius) {
            this.center.copy(center);
            this.radius = radius;
            return this;
        };
        /**
        * Sets the dimensions of this sphere based on an array of Vec3 points
        * @param {Array<Vec3>} points The points to set dimensions from
        * @param {Vec3} optionalCenter [Optional] The center of the sphere
        * @returns {Sphere}
        */
        Sphere.prototype.setFromPoints = function (points, optionalCenter) {
            var box = Sphere._box;
            var center = this.center;
            if (optionalCenter !== undefined) {
                center.copy(optionalCenter);
            }
            else {
                box.setFromPoints(points).center(center);
            }
            var maxRadiusSq = 0;
            for (var i = 0, il = points.length; i < il; i++) {
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
            }
            this.radius = Math.sqrt(maxRadiusSq);
            return this;
        };
        /**
        * Copies the dimensions of the given sphere
        * @param {Sphere} sphere The sphere to copy from
        * @returns {Sphere}
        */
        Sphere.prototype.copy = function (sphere) {
            this.center.copy(sphere.center);
            this.radius = sphere.radius;
            return this;
        };
        /**
        * Checks if the sphere radius is less than zero
        * @returns {boolean}
        */
        Sphere.prototype.empty = function () {
            return (this.radius <= 0);
        };
        /**
        * Checks if the sphere contains a point in space
        * @param {Vec3} point The point to check
        * @returns {boolean}
        */
        Sphere.prototype.containsPoint = function (point) {
            return (point.distanceToSquared(this.center) <= (this.radius * this.radius));
        };
        /**
        * Gets the distance of this sphere to a given point p
        * @param {Vec3} p The point to check against
        * @returns {number}
        */
        Sphere.prototype.distanceToPoint = function (p) {
            return (p.distanceTo(this.center) - this.radius);
        };
        /**
        * Checks if a sphere intersects this sphere's dimensions
        * @param {Sphere} sphere The sphere to check against
        * @returns {boolean}
        */
        Sphere.prototype.intersectsSphere = function (sphere) {
            var radiusSum = this.radius + sphere.radius;
            return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);
        };
        /**
        * Makes sure a point p is within the boundaries of this sphere
        * @param {Vec3} p
        * @param {Vec3} ref [Optional]
        * @returns {Vec3}
        */
        Sphere.prototype.clampPoint = function (p, ref) {
            var deltaLengthSq = this.center.distanceToSquared(p);
            var result = ref || new Trike.Vec3();
            result.copy(p);
            if (deltaLengthSq > (this.radius * this.radius)) {
                result.sub(this.center).normalize();
                result.multiplyScalar(this.radius).add(this.center);
            }
            return result;
        };
        /**
        * Gets a bounding box that encompasses the dimensions of this sphere
        * @param {Box3} ref [Optional] Fills this box instead of creating a new one
        * @returns {Box3}
        */
        Sphere.prototype.getBoundingBox = function (ref) {
            var box = ref || new Trike.Box3();
            box.set(this.center, this.center);
            box.expandByScalar(this.radius);
            return box;
        };
        /**
        * Applies a matrix to this sphere's coordinates
        * @param {Matrix4} matrix
        * @returns {Sphere}
        */
        Sphere.prototype.applyMatrix4 = function (matrix) {
            this.center.applyMatrix4(matrix);
            this.radius = this.radius * matrix.getMaxScaleOnAxis();
            return this;
        };
        /**
        * Moves this sphere by a given offset
        * @param {Vec3} offset The offset to move the sphere
        * @returns {Sphere}
        */
        Sphere.prototype.translate = function (offset) {
            this.center.add(offset);
            return this;
        };
        /**
        * Checks if this sphere's dimensions match a reference sphere s
        * @param {Sphere} sphere The sphere to check against
        * @returns {boolean}
        */
        Sphere.prototype.equals = function (s) {
            return s.center.equals(this.center) && (s.radius === this.radius);
        };
        /**
        * Copies this sphere into a new object
        * @returns {Sphere}
        */
        Sphere.prototype.clone = function () {
            return new Sphere().copy(this);
        };
        return Sphere;
    }());
    Trike.Sphere = Sphere;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    var Plane = (function () {
        function Plane(normal, constant) {
            this.normal = (normal !== undefined) ? normal : new Trike.Vec3(1, 0, 0);
            this.constant = (constant !== undefined) ? constant : 0;
            if (!Plane._v1) {
                Plane._v1 = new Trike.Vec3();
                Plane._v2 = new Trike.Vec3();
            }
        }
        Plane.prototype.set = function (normal, constant) {
            this.normal.copy(normal);
            this.constant = constant;
            return this;
        };
        Plane.prototype.setComponents = function (x, y, z, w) {
            this.normal.set(x, y, z);
            this.constant = w;
            return this;
        };
        Plane.prototype.setFromNormalAndCoplanarPoint = function (normal, point) {
            this.normal.copy(normal);
            this.constant = -point.dot(this.normal); // must be this.normal, not normal, as this.normal is normalized
            return this;
        };
        Plane.prototype.setFromCoplanarPoints = function (a, b, c) {
            var v1 = Plane._v1;
            var v2 = Plane._v2;
            var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
            // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
            this.setFromNormalAndCoplanarPoint(normal, a);
            return this;
        };
        Plane.prototype.copy = function (plane) {
            this.normal.copy(plane.normal);
            this.constant = plane.constant;
            return this;
        };
        Plane.prototype.normalize = function () {
            // Note: will lead to a divide by zero if the plane is invalid.
            var inverseNormalLength = 1.0 / this.normal.length();
            this.normal.multiplyScalar(inverseNormalLength);
            this.constant *= inverseNormalLength;
            return this;
        };
        Plane.prototype.negate = function () {
            this.constant *= -1;
            this.normal.negate();
            return this;
        };
        Plane.prototype.distanceToPoint = function (point) {
            return this.normal.dot(point) + this.constant;
        };
        Plane.prototype.distanceToSphere = function (sphere) {
            return this.distanceToPoint(sphere.center) - sphere.radius;
        };
        Plane.prototype.projectPoint = function (point, optionalTarget) {
            return this.orthoPoint(point, optionalTarget).sub(point).negate();
        };
        Plane.prototype.orthoPoint = function (point, optionalTarget) {
            if (optionalTarget === void 0) { optionalTarget = new Trike.Vec3(); }
            var perpendicularMagnitude = this.distanceToPoint(point);
            var result = optionalTarget;
            return result.copy(this.normal).multiplyScalar(perpendicularMagnitude);
        };
        Plane.prototype.isIntersectionLine = function (line) {
            // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
            var startSign = this.distanceToPoint(line.start);
            var endSign = this.distanceToPoint(line.end);
            return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
        };
        Plane.prototype.intersectLine = function (line, optionalTarget) {
            if (optionalTarget === void 0) { optionalTarget = new Trike.Vec3(); }
            var v1 = Plane._v1;
            var result = optionalTarget;
            var direction = line.delta(v1);
            var denominator = this.normal.dot(direction);
            if (denominator === 0) {
                // line is coplanar, return origin
                if (this.distanceToPoint(line.start) === 0)
                    return result.copy(line.start);
                // Unsure if this is the correct method to handle this case.
                return undefined;
            }
            var t = -(line.start.dot(this.normal) + this.constant) / denominator;
            if (t < 0 || t > 1) {
                return undefined;
            }
            return result.copy(direction).multiplyScalar(t).add(line.start);
        };
        Plane.prototype.coplanarPoint = function (optionalTarget) {
            if (optionalTarget === void 0) { optionalTarget = new Trike.Vec3(); }
            var result = optionalTarget;
            return result.copy(this.normal).multiplyScalar(-this.constant);
        };
        Plane.prototype.applyMatrix4 = function (matrix, optionalNormalMatrix) {
            var v1 = Plane._v1;
            var v2 = Plane._v2;
            // compute new normal based on theory here:
            // http://www.songho.ca/opengl/gl_normaltransform.html
            optionalNormalMatrix = optionalNormalMatrix || new Trike.Matrix3().getNormalMatrix(matrix);
            var newNormal = v1.copy(this.normal).applyMatrix3(optionalNormalMatrix);
            var newCoplanarPoint = this.coplanarPoint(v2);
            newCoplanarPoint.applyMatrix4(matrix);
            this.setFromNormalAndCoplanarPoint(newNormal, newCoplanarPoint);
            return this;
        };
        Plane.prototype.translate = function (offset) {
            this.constant = this.constant - offset.dot(this.normal);
            return this;
        };
        Plane.prototype.equals = function (plane) {
            return plane.normal.equals(this.normal) && (plane.constant === this.constant);
        };
        Plane.prototype.clone = function () {
            return new Plane().copy(this);
        };
        return Plane;
    }());
    Trike.Plane = Plane;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    var FrustumCorners = (function () {
        function FrustumCorners() {
            this._t = new Trike.Vec4();
            this.farTopLeft = new Trike.Vec3();
            this.farTopRight = new Trike.Vec3();
            this.farBottomLeft = new Trike.Vec3();
            this.farBottomRight = new Trike.Vec3();
            this.nearTopLeft = new Trike.Vec3();
            this.nearTopRight = new Trike.Vec3();
            this.nearBottomLeft = new Trike.Vec3();
            this.nearBottomRight = new Trike.Vec3();
            this.cornerUniform = new Trike.UniformArray([
                this.farTopLeft, this.farTopRight, this.farBottomLeft, this.farBottomRight,
                this.nearTopLeft, this.nearTopRight, this.nearBottomLeft, this.nearBottomRight
            ], 3);
        }
        /**
        * Applies a transformation matrix to the corners.
        * @param {Matrix4} matrix
        * @returns {FrustumCorners}
        */
        FrustumCorners.prototype.applyMatrix = function (matrix) {
            this.farTopLeft.applyMatrix4(matrix);
            this.farBottomRight.applyMatrix4(matrix);
            this.farTopRight.applyMatrix4(matrix);
            this.farBottomLeft.applyMatrix4(matrix);
            this.nearTopLeft.applyMatrix4(matrix);
            this.nearBottomRight.applyMatrix4(matrix);
            this.nearTopRight.applyMatrix4(matrix);
            this.nearBottomLeft.applyMatrix4(matrix);
            return this;
        };
        /**
        * Applies a direction matrix to the corners.
        * @param {Matrix4} matrix
        * @returns {FrustumCorners}
        */
        FrustumCorners.prototype.transformDirection = function (matrix) {
            this.farTopLeft.transformDirection(matrix);
            this.farBottomRight.transformDirection(matrix);
            this.farTopRight.transformDirection(matrix);
            this.farBottomLeft.transformDirection(matrix);
            this.nearTopLeft.transformDirection(matrix);
            this.nearBottomRight.transformDirection(matrix);
            this.nearTopRight.transformDirection(matrix);
            this.nearBottomLeft.transformDirection(matrix);
            return this;
        };
        /**
        * Gets the frustum's 8 vertices that make up the near and far plane corners of the camera.
        * @param {Camera} camera
        * @returns {FrustumCorners}
        */
        FrustumCorners.prototype.setFrustumCorners = function (camera) {
            var pCam;
            var oCam;
            if (camera instanceof Trike.CameraCombined)
                camera = camera.activeCamera;
            if (camera instanceof Trike.CameraPerspective)
                pCam = camera;
            else if (camera instanceof Trike.CameraOrthographic)
                oCam = camera;
            var near = (pCam ? pCam.near : oCam.near);
            var far = (pCam ? pCam.far : oCam.far);
            var hNear, wNear, hFar, wFar;
            if (pCam) {
                var fov = pCam.fov;
                hNear = 2 * Math.tan(fov * Math.PI / 180 / 2) * near; // height
                wNear = hNear * pCam.aspect; // width
                // Far Plane dimensions
                hFar = 2 * Math.tan(fov * Math.PI / 180 / 2) * far; // height
                wFar = hFar * pCam.aspect; // width
            }
            else {
                wNear = oCam._right - oCam._left;
                wFar = wNear;
            }
            this.farTopLeft.set(-wFar / 2, hFar / 2, -far);
            this.farBottomRight.set(wFar / 2, -hFar / 2, -far);
            this.farTopRight.set(wFar / 2, hFar / 2, -far);
            this.farBottomLeft.set(-wFar / 2, -hFar / 2, -far);
            this.nearTopLeft.set(-wNear / 2, hNear / 2, -near);
            this.nearBottomRight.set(wNear / 2, -hNear / 2, -near);
            this.nearTopRight.set(wNear / 2, hNear / 2, -near);
            this.nearBottomLeft.set(-wNear / 2, -hNear / 2, -near);
            return this;
        };
        return FrustumCorners;
    }());
    Trike.FrustumCorners = FrustumCorners;
    var Frustum = (function () {
        function Frustum(p0, p1, p2, p3, p4, p5) {
            this.planes = [
                (p0 !== undefined) ? p0 : new Trike.Plane(),
                (p1 !== undefined) ? p1 : new Trike.Plane(),
                (p2 !== undefined) ? p2 : new Trike.Plane(),
                (p3 !== undefined) ? p3 : new Trike.Plane(),
                (p4 !== undefined) ? p4 : new Trike.Plane(),
                (p5 !== undefined) ? p5 : new Trike.Plane()
            ];
            if (!Frustum._v1) {
                Frustum._sphere = new Trike.Sphere();
                Frustum._v1 = new Trike.Vec3();
                Frustum._v2 = new Trike.Vec3();
            }
        }
        Frustum.prototype.set = function (p0, p1, p2, p3, p4, p5) {
            var planes = this.planes;
            planes[0].copy(p0);
            planes[1].copy(p1);
            planes[2].copy(p2);
            planes[3].copy(p3);
            planes[4].copy(p4);
            planes[5].copy(p5);
            return this;
        };
        /**
        * Copies the contents of a frustum into this
        * @param {Frustum} frustum Frustum to copy from
        * @returns {Frustum}
        */
        Frustum.prototype.copy = function (frustum) {
            var planes = this.planes;
            for (var i = 0; i < 6; i++)
                planes[i].copy(frustum.planes[i]);
            return this;
        };
        /**
        * Sets the planes of this frustrum to that of the provided matrix
        * @param {Matrix4} m
        * @returns {Frustum}
        */
        Frustum.prototype.setFromMatrix = function (m) {
            var planes = this.planes;
            var me = m.elements;
            var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
            var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
            var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
            var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
            planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
            planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
            planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
            planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
            planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
            planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
            return this;
        };
        Frustum.prototype.intersectsObject = function (object) {
            // const sphere = Frustum._sphere;
            // const geometry = object.geometry;
            // if ( geometry.boundingSphere === null )
            //  geometry.computeBoundingSphere();
            // sphere.copy( geometry.boundingSphere );
            // sphere.applyMatrix4( object.worldMatrix );
            return this.intersectsSphere(object._worldSphere);
        };
        /**
        * Checks if this frustum intersects a sphere. Returns true if the frustum contains the sphere
        * @param {Sphere} sphere
        * @returns {boolean}
        */
        Frustum.prototype.intersectsSphere = function (sphere) {
            var planes = this.planes;
            var center = sphere.center;
            var negRadius = -sphere.radius;
            for (var i = 0; i < 6; i++) {
                var distance = planes[i].distanceToPoint(center);
                if (distance < negRadius) {
                    return false;
                }
            }
            return true;
        };
        /**
        * Checks if this frustum intersects a box 3d. Returns true if the frustum contains the box
        * @param {Box3} box
        * @returns {boolean}
        */
        Frustum.prototype.intersectsBox = function (box) {
            var p1 = Frustum._v1, p2 = Frustum._v2;
            var planes = this.planes;
            for (var i = 0; i < 6; i++) {
                var plane = planes[i];
                p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
                p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
                p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
                p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                var d1 = plane.distanceToPoint(p1);
                var d2 = plane.distanceToPoint(p2);
                // if both outside plane, no intersection
                if (d1 < 0 && d2 < 0) {
                    return false;
                }
            }
            return true;
        };
        /**
        * Checks if this frustum contains a point. Returns true if the frustum contains the point.
        * @param {Vec3} point
        * @returns {boolean}
        */
        Frustum.prototype.containsPoint = function (point) {
            var planes = this.planes;
            for (var i = 0; i < 6; i++)
                if (planes[i].distanceToPoint(point) < 0)
                    return false;
            return true;
        };
        /**
        * Returns a clone of this frustum
        * @returns {Frustum}
        */
        Frustum.prototype.clone = function () {
            return new Frustum().copy(this);
        };
        return Frustum;
    }());
    Trike.Frustum = Frustum;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    var Euler = (function () {
        function Euler(x, y, z, order, createQaut) {
            if (createQaut === void 0) { createQaut = true; }
            this._x = x || 0;
            this._y = y || 0;
            this._z = z || 0;
            this._order = order || Euler.DefaultOrder;
            if (createQaut)
                this._quaternion = new Trike.Quat();
        }
        Euler.prototype._updateQuaternion = function () {
            if (this._quaternion !== undefined) {
                this._quaternion.setFromEuler(this, false);
            }
        };
        Object.defineProperty(Euler.prototype, "x", {
            get: function () {
                return this._x;
            },
            set: function (value) {
                this._x = value;
                this._updateQuaternion();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Euler.prototype, "y", {
            get: function () {
                return this._y;
            },
            set: function (value) {
                this._y = value;
                this._updateQuaternion();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Euler.prototype, "z", {
            get: function () {
                return this._z;
            },
            set: function (value) {
                this._z = value;
                this._updateQuaternion();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Euler.prototype, "order", {
            get: function () {
                return this._order;
            },
            set: function (value) {
                this._order = value;
                this._updateQuaternion();
            },
            enumerable: true,
            configurable: true
        });
        Euler.prototype.set = function (x, y, z, order) {
            this._x = x;
            this._y = y;
            this._z = z;
            this._order = order || this._order;
            this._updateQuaternion();
            return this;
        };
        Euler.prototype.copy = function (euler) {
            this._x = euler._x;
            this._y = euler._y;
            this._z = euler._z;
            this._order = euler._order;
            this._updateQuaternion();
            return this;
        };
        Euler.prototype.setFromRotationMatrix = function (m, order) {
            if (order === void 0) { order = Euler.DefaultOrder; }
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            // clamp, to handle numerical problems
            function clamp(x) {
                return Math.min(Math.max(x, -1), 1);
            }
            var te = m.elements;
            var m11 = te[0], m12 = te[4], m13 = te[8];
            var m21 = te[1], m22 = te[5], m23 = te[9];
            var m31 = te[2], m32 = te[6], m33 = te[10];
            order = order || this._order;
            if (order === 'XYZ') {
                this._y = Math.asin(clamp(m13));
                if (Math.abs(m13) < 0.99999) {
                    this._x = Math.atan2(-m23, m33);
                    this._z = Math.atan2(-m12, m11);
                }
                else {
                    this._x = Math.atan2(m32, m22);
                    this._z = 0;
                }
            }
            else if (order === 'YXZ') {
                this._x = Math.asin(-clamp(m23));
                if (Math.abs(m23) < 0.99999) {
                    this._y = Math.atan2(m13, m33);
                    this._z = Math.atan2(m21, m22);
                }
                else {
                    this._y = Math.atan2(-m31, m11);
                    this._z = 0;
                }
            }
            else if (order === 'ZXY') {
                this._x = Math.asin(clamp(m32));
                if (Math.abs(m32) < 0.99999) {
                    this._y = Math.atan2(-m31, m33);
                    this._z = Math.atan2(-m12, m22);
                }
                else {
                    this._y = 0;
                    this._z = Math.atan2(m21, m11);
                }
            }
            else if (order === 'ZYX') {
                this._y = Math.asin(-clamp(m31));
                if (Math.abs(m31) < 0.99999) {
                    this._x = Math.atan2(m32, m33);
                    this._z = Math.atan2(m21, m11);
                }
                else {
                    this._x = 0;
                    this._z = Math.atan2(-m12, m22);
                }
            }
            else if (order === 'YZX') {
                this._z = Math.asin(clamp(m21));
                if (Math.abs(m21) < 0.99999) {
                    this._x = Math.atan2(-m23, m22);
                    this._y = Math.atan2(-m31, m11);
                }
                else {
                    this._x = 0;
                    this._y = Math.atan2(m13, m33);
                }
            }
            else if (order === 'XZY') {
                this._z = Math.asin(-clamp(m12));
                if (Math.abs(m12) < 0.99999) {
                    this._x = Math.atan2(m32, m22);
                    this._y = Math.atan2(m13, m11);
                }
                else {
                    this._x = Math.atan2(-m23, m33);
                    this._y = 0;
                }
            }
            else {
                console.warn('WARNING: Euler.setFromRotationMatrix() given unsupported order: ' + order);
            }
            this._order = order;
            this._updateQuaternion();
            return this;
        };
        Euler.prototype.setFromQuaternion = function (q, order, update) {
            // q is assumed to be normalized
            // clamp, to handle numerical problems
            function clamp(x) {
                return Math.min(Math.max(x, -1), 1);
            }
            // http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
            var sqx = q.x * q.x;
            var sqy = q.y * q.y;
            var sqz = q.z * q.z;
            var sqw = q.w * q.w;
            order = order || this._order;
            if (order === 'XYZ') {
                this._x = Math.atan2(2 * (q.x * q.w - q.y * q.z), (sqw - sqx - sqy + sqz));
                this._y = Math.asin(clamp(2 * (q.x * q.z + q.y * q.w)));
                this._z = Math.atan2(2 * (q.z * q.w - q.x * q.y), (sqw + sqx - sqy - sqz));
            }
            else if (order === 'YXZ') {
                this._x = Math.asin(clamp(2 * (q.x * q.w - q.y * q.z)));
                this._y = Math.atan2(2 * (q.x * q.z + q.y * q.w), (sqw - sqx - sqy + sqz));
                this._z = Math.atan2(2 * (q.x * q.y + q.z * q.w), (sqw - sqx + sqy - sqz));
            }
            else if (order === 'ZXY') {
                this._x = Math.asin(clamp(2 * (q.x * q.w + q.y * q.z)));
                this._y = Math.atan2(2 * (q.y * q.w - q.z * q.x), (sqw - sqx - sqy + sqz));
                this._z = Math.atan2(2 * (q.z * q.w - q.x * q.y), (sqw - sqx + sqy - sqz));
            }
            else if (order === 'ZYX') {
                this._x = Math.atan2(2 * (q.x * q.w + q.z * q.y), (sqw - sqx - sqy + sqz));
                this._y = Math.asin(clamp(2 * (q.y * q.w - q.x * q.z)));
                this._z = Math.atan2(2 * (q.x * q.y + q.z * q.w), (sqw + sqx - sqy - sqz));
            }
            else if (order === 'YZX') {
                this._x = Math.atan2(2 * (q.x * q.w - q.z * q.y), (sqw - sqx + sqy - sqz));
                this._y = Math.atan2(2 * (q.y * q.w - q.x * q.z), (sqw + sqx - sqy - sqz));
                this._z = Math.asin(clamp(2 * (q.x * q.y + q.z * q.w)));
            }
            else if (order === 'XZY') {
                this._x = Math.atan2(2 * (q.x * q.w + q.y * q.z), (sqw - sqx + sqy - sqz));
                this._y = Math.atan2(2 * (q.x * q.z + q.y * q.w), (sqw + sqx - sqy - sqz));
                this._z = Math.asin(clamp(2 * (q.z * q.w - q.x * q.y)));
            }
            else {
                console.warn('WARNING: Euler.setFromQuaternion() given unsupported order: ' + order);
            }
            this._order = order;
            if (update !== false)
                this._updateQuaternion();
            return this;
        };
        Euler.prototype.reorder = function (newOrder) {
            // WARNING: this discards revolution information -bhouston
            var q = new Trike.Quat();
            q.setFromEuler(this);
            this.setFromQuaternion(q, newOrder);
        };
        Euler.prototype.fromArray = function (array) {
            this._x = array[0];
            this._y = array[1];
            this._z = array[2];
            if (array[3] !== undefined)
                this._order = array[3];
            this._updateQuaternion();
            return this;
        };
        Euler.prototype.toArray = function () {
            return [this._x, this._y, this._z, this._order];
        };
        Euler.prototype.equals = function (euler) {
            return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);
        };
        Euler.prototype.clone = function () {
            return new Euler(this._x, this._y, this._z, this._order, this._quaternion ? true : false);
        };
        Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
        Euler.DefaultOrder = 'XYZ';
        return Euler;
    }());
    Trike.Euler = Euler;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    var ImprovedNoise = (function () {
        function ImprovedNoise() {
            if (!ImprovedNoise._p) {
                ImprovedNoise._p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10,
                    23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87,
                    174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211,
                    133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208,
                    89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5,
                    202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119,
                    248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232,
                    178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249,
                    14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205,
                    93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180];
                for (var i = 0; i < 256; i++)
                    ImprovedNoise._p[256 + i] = ImprovedNoise._p[i];
            }
        }
        ImprovedNoise.prototype.fade = function (t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
        };
        ImprovedNoise.prototype.lerp = function (t, a, b) {
            return a + t * (b - a);
        };
        ImprovedNoise.prototype.grad = function (hash, x, y, z) {
            var h = hash & 15;
            var u = h < 8 ? x : y, v = h < 4 ? y : h === 12 || h === 14 ? x : z;
            return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
        };
        ImprovedNoise.prototype.getNoise = function (x, y, z) {
            var p = ImprovedNoise._p;
            var floorX = ~~x, floorY = ~~y, floorZ = ~~z;
            var X = floorX & 255, Y = floorY & 255, Z = floorZ & 255;
            x -= floorX;
            y -= floorY;
            z -= floorZ;
            var xMinus1 = x - 1, yMinus1 = y - 1, zMinus1 = z - 1;
            var u = this.fade(x), v = this.fade(y), w = this.fade(z);
            var A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z, B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z;
            return this.lerp(w, this.lerp(v, this.lerp(u, this.grad(p[AA], x, y, z), this.grad(p[BA], xMinus1, y, z)), this.lerp(u, this.grad(p[AB], x, yMinus1, z), this.grad(p[BB], xMinus1, yMinus1, z))), this.lerp(v, this.lerp(u, this.grad(p[AA + 1], x, y, zMinus1), this.grad(p[BA + 1], xMinus1, y, z - 1)), this.lerp(u, this.grad(p[AB + 1], x, yMinus1, zMinus1), this.grad(p[BB + 1], xMinus1, yMinus1, zMinus1))));
        };
        return ImprovedNoise;
    }());
    Trike.ImprovedNoise = ImprovedNoise;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A Ray has an origin and direction, and can be thought of as geometric line. We use for things such as collision detection or
    * picking.
    */
    var Ray = (function () {
        function Ray(origin, direction) {
            if (origin === void 0) { origin = new Trike.Vec3(); }
            if (direction === void 0) { direction = new Trike.Vec3(0, -1, 0); }
            this.origin = origin;
            this.direction = direction;
            // Optimization variables
            this._v = new Trike.Vec3();
            this._diff = new Trike.Vec3();
            this._edge1 = new Trike.Vec3();
            this._edge2 = new Trike.Vec3();
            this._norm = new Trike.Vec3();
        }
        /** Sets the origin and direction internals */
        Ray.prototype.set = function (origin, direction) {
            this.origin.copy(origin);
            this.direction.copy(direction);
            return this;
        };
        /** Copies the properties of a Ray */
        Ray.prototype.copy = function (ray) {
            this.origin.copy(ray.origin);
            this.direction.copy(ray.direction);
            return this;
        };
        /**
        * Returns a point on the ray at a distance of t.
        * @param {number} t The distance along the Ray
        * @param {Vec3} optionalTarget If specified this variable is filled instead of the function creating a new one.
        */
        Ray.prototype.at = function (t, optionalTarget) {
            var result = optionalTarget || new Trike.Vec3();
            return result.copy(this.direction).multiplyScalar(t).add(this.origin);
        };
        /**
        * Moves the origin along the Ray at a point t distance from its original orgin
        */
        Ray.prototype.recast = function (t) {
            var v1 = this._v;
            this.origin.copy(this.at(t, v1));
            return this;
        };
        /**
        * Returns the closest point on the Ray to a point specified by point.
        * @param {Vec3} point The point we testing against
        * @param {Vec3} optionalTarget If specified this variable is filled instead of the function creating a new one.
        */
        Ray.prototype.closestPointToPoint = function (point, optionalTarget) {
            var result = optionalTarget || new Trike.Vec3();
            result.subVectors(point, this.origin);
            var directionDistance = result.dot(this.direction);
            // point behind the ray
            if (directionDistance < 0)
                return result.copy(this.origin);
            return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        };
        /**
        * Returns the closest distance from the ray to a point
        */
        Ray.prototype.distanceToPoint = function (point) {
            var v1 = this._v;
            var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
            // point behind the ray
            if (directionDistance < 0)
                return this.origin.distanceTo(point);
            v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
            return v1.distanceTo(point);
        };
        /**
        * from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
        * It returns the min distance between the ray and the line segment defined by v0 and v1
        * It can also set two optional targets :
        * - The closest point on the ray
        * - The closest point on the segment
        */
        Ray.prototype.distanceSqToSegment = function (v0, v1, optionalPointOnRay, optionalPointOnSegment) {
            var segCenter = v0.clone().add(v1).multiplyScalar(0.5);
            var segDir = v1.clone().sub(v0).normalize();
            var segExtent = v0.distanceTo(v1) * 0.5;
            var diff = this.origin.clone().sub(segCenter);
            var a01 = -this.direction.dot(segDir);
            var b0 = diff.dot(this.direction);
            var b1 = -diff.dot(segDir);
            var c = diff.lengthSq();
            var det = Math.abs(1 - a01 * a01);
            var s0, s1, sqrDist, extDet;
            if (det > 0) {
                // The ray and segment are not parallel.
                s0 = a01 * b1 - b0;
                s1 = a01 * b0 - b1;
                extDet = segExtent * det;
                if (s0 >= 0) {
                    if (s1 >= -extDet) {
                        if (s1 <= extDet) {
                            // region 0
                            // Minimum at interior points of ray and segment.
                            var invDet = 1 / det;
                            s0 *= invDet;
                            s1 *= invDet;
                            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                        }
                        else {
                            // region 1
                            s1 = segExtent;
                            s0 = Math.max(0, -(a01 * s1 + b0));
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        }
                    }
                    else {
                        // region 5
                        s1 = -segExtent;
                        s0 = Math.max(0, -(a01 * s1 + b0));
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                }
                else {
                    if (s1 <= -extDet) {
                        // region 4
                        s0 = Math.max(0, -(-a01 * segExtent + b0));
                        s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                    else if (s1 <= extDet) {
                        // region 3
                        s0 = 0;
                        s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                        sqrDist = s1 * (s1 + 2 * b1) + c;
                    }
                    else {
                        // region 2
                        s0 = Math.max(0, -(a01 * segExtent + b0));
                        s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                    }
                }
            }
            else {
                // Ray and segment are parallel.
                s1 = (a01 > 0) ? -segExtent : segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
            if (optionalPointOnRay)
                optionalPointOnRay.copy(this.direction.clone().multiplyScalar(s0).add(this.origin));
            if (optionalPointOnSegment)
                optionalPointOnSegment.copy(segDir.clone().multiplyScalar(s1).add(segCenter));
            return sqrDist;
        };
        /**
        * Checks if this ray intersects a sphere
        */
        Ray.prototype.isIntersectionSphere = function (sphere) {
            return this.distanceToPoint(sphere.center) <= sphere.radius;
        };
        /**
        * Checks if this ray intersects a plane
        */
        Ray.prototype.isIntersectionPlane = function (plane) {
            // check if the ray lies on the plane first
            var distToPoint = plane.distanceToPoint(this.origin);
            if (distToPoint === 0)
                return true;
            var denominator = plane.normal.dot(this.direction);
            if (denominator * distToPoint < 0)
                return true;
            // ray origin is behind the plane (and is pointing behind it)
            return false;
        };
        /**
        * Returns the closest distance of plane to the origin of this Ray. If the ray is coplanar it will return 0 or null if never intersects the plane.
        */
        Ray.prototype.distanceToPlane = function (plane) {
            var denominator = plane.normal.dot(this.direction);
            if (denominator === 0) {
                // line is coplanar, return origin
                if (plane.distanceToPoint(this.origin) === 0)
                    return 0;
                // Null is preferable to undefined since undefined means.... it is undefined
                return null;
            }
            var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
            // Return if the ray never intersects the plane
            return t >= 0 ? t : null;
        };
        /**
        * Gets the point on the plane where the ray intersects it. Returns null if the ray and plane are coplanar
        */
        Ray.prototype.intersectPlane = function (plane, optionalTarget) {
            var t = this.distanceToPlane(plane);
            if (!t)
                return null;
            return this.at(t, optionalTarget);
        };
        /**
        * Returns a boolean if the ray is intersecting a box
        */
        Ray.prototype.isIntersectionBox = function (box) {
            var v = this._v;
            return (this.intersectBox(box, v) ? true : false);
        };
        /**
        * Gets the point on the box where the ray intersects it. Returns null if the ray does not intersect the box.
        * @param {Box3} box The box we are testing against
        * @param {Vec3} optionalTarget If specified this variable is filled instead of the function creating a new one.
        */
        Ray.prototype.intersectBox = function (box, optionalTarget) {
            var tmin, tmax, tymin, tymax, tzmin, tzmax;
            var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
            var origin = this.origin;
            if (invdirx >= 0) {
                tmin = (box.min.x - origin.x) * invdirx;
                tmax = (box.max.x - origin.x) * invdirx;
            }
            else {
                tmin = (box.max.x - origin.x) * invdirx;
                tmax = (box.min.x - origin.x) * invdirx;
            }
            if (invdiry >= 0) {
                tymin = (box.min.y - origin.y) * invdiry;
                tymax = (box.max.y - origin.y) * invdiry;
            }
            else {
                tymin = (box.max.y - origin.y) * invdiry;
                tymax = (box.min.y - origin.y) * invdiry;
            }
            if ((tmin > tymax) || (tymin > tmax))
                return null;
            // These lines also handle the case where tmin or tmax is NaN
            // (result of 0 * Infinity). x !== x returns true if x is NaN
            if (tymin > tmin || tmin !== tmin)
                tmin = tymin;
            if (tymax < tmax || tmax !== tmax)
                tmax = tymax;
            if (invdirz >= 0) {
                tzmin = (box.min.z - origin.z) * invdirz;
                tzmax = (box.max.z - origin.z) * invdirz;
            }
            else {
                tzmin = (box.max.z - origin.z) * invdirz;
                tzmax = (box.min.z - origin.z) * invdirz;
            }
            if ((tmin > tzmax) || (tzmin > tmax))
                return null;
            if (tzmin > tmin || tmin !== tmin)
                tmin = tzmin;
            if (tzmax < tmax || tmax !== tmax)
                tmax = tzmax;
            // Return point closest to the ray (positive side)
            if (tmax < 0)
                return null;
            return this.at(tmin >= 0 ? tmin : tmax, optionalTarget);
        };
        /**
        * Gets a point on a triangle where the ray intersects it. Returns null if the ray does not intersect the triangle.
        * @param {Vec3} a First point on the triangle
        * @param {Vec3} b Second point on the triangle
        * @param {Vec3} c Third point on the triangle
        * @param {boolean} backfaceCulling Defines which way the normal is facing on the triangle
        * @param {Vec3} optionalTarget If specified this variable is filled instead of the function creating a new one.
        */
        Ray.prototype.intersectTriangle = function (a, b, c, backfaceCulling, optionalTarget) {
            if (backfaceCulling === void 0) { backfaceCulling = true; }
            // Compute the offset origin, edges, and normal.
            var diff = this._diff;
            var edge1 = this._edge1;
            var edge2 = this._edge2;
            var normal = this._norm;
            // from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp
            edge1.subVectors(b, a);
            edge2.subVectors(c, a);
            normal.crossVectors(edge1, edge2);
            // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
            // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
            //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
            //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
            //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
            var DdN = this.direction.dot(normal);
            var sign;
            if (DdN > 0) {
                if (backfaceCulling)
                    return null;
                sign = 1;
            }
            else if (DdN < 0) {
                sign = -1;
                DdN = -DdN;
            }
            else
                return null;
            diff.subVectors(this.origin, a);
            var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
            // b1 < 0, no intersection
            if (DdQxE2 < 0)
                return null;
            var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
            // b2 < 0, no intersection
            if (DdE1xQ < 0)
                return null;
            // b1+b2 > 1, no intersection
            if (DdQxE2 + DdE1xQ > DdN)
                return null;
            // Line intersects triangle, check if ray does.
            var QdN = -sign * diff.dot(normal);
            // t < 0, no intersection
            if (QdN < 0)
                return null;
            // Ray intersects triangle.
            return this.at(QdN / DdN, optionalTarget);
        };
        /**
        * Applies a matrix to this ray
        */
        Ray.prototype.applyMatrix4 = function (matrix4) {
            this.direction.add(this.origin).applyMatrix4(matrix4);
            this.origin.applyMatrix4(matrix4);
            this.direction.sub(this.origin);
            this.direction.normalize();
            return this;
        };
        /**
        * Checks if the ray specified is equal to this one.
        */
        Ray.prototype.equals = function (ray) {
            return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
        };
        /**
        * Clones this ray
        */
        Ray.prototype.clone = function () {
            return new Ray().copy(this);
        };
        return Ray;
    }());
    Trike.Ray = Ray;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Internal class used to create an AleaRand
    */
    function Mash() {
        var n = 0xefc8249d;
        var mash = function (data) {
            data = data.toString();
            for (var i = 0; i < data.length; i++) {
                n += data.charCodeAt(i);
                var h = 0.02519603282416938 * n;
                n = h >>> 0;
                h -= n;
                h *= n;
                n = h >>> 0;
                h -= n;
                n += h * 0x100000000; // 2^32
            }
            return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
        };
        return mash;
    }
    /**
    * A random number generator class that allows you to use seeded random numbers
    */
    var AleaRand = (function () {
        function AleaRand(s0, s1, s2, c) {
            this.s0 = s0;
            this.s1 = s1;
            this.s2 = s2;
            this.c = c;
        }
        AleaRand.prototype.random = function () {
            var s0 = this.s0, s1 = this.s1, s2 = this.s2, c = this.c;
            var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32
            s0 = s1;
            s1 = s2;
            return s2 = t - (c = t | 0);
        };
        AleaRand.prototype.uint32 = function () {
            return this.random() * 0x100000000; // 2^32
        };
        AleaRand.prototype.fract53 = function () {
            return this.random() +
                (this.random() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
        };
        return AleaRand;
    }());
    Trike.AleaRand = AleaRand;
    /**
    * A Collection of random generators
    */
    var Random = (function () {
        function Random() {
        }
        /**
        * Returns a random point inside of a sphere.
        * @param {number} radius The radius of the sphere
        * @param {Vec3} center [Optional] The center position of the sphere
        * @param {Vec3} ref [Optional] Pass in the vector to be filled
        * @param {boolean} uniform [Optional] If true, the point uses a more complex formula to make it more distributed
        * @returns {Vec3}
        */
        Random.pointInsideSphere = function (radius, center, ref, uniform) {
            if (radius === void 0) { radius = 1; }
            if (uniform === void 0) { uniform = true; }
            var toRet = ref || new Trike.Vec3();
            if (uniform === false) {
                var u = Math.random();
                var v = Math.random();
                var theta = 2 * Math.PI * u;
                var phi = Math.acos(2 * v - 1);
                var radiusRandom = Math.random() * radius;
                toRet.x = (center ? center.x : 0) + (radiusRandom * Math.sin(phi) * Math.cos(theta));
                toRet.y = (center ? center.y : 0) + (radiusRandom * Math.sin(phi) * Math.sin(theta));
                toRet.z = (center ? center.z : 0) + (radiusRandom * Math.cos(phi));
            }
            else {
                var theta = Math.random() * Math.PI * 2;
                var o = Math.acos(2 * Math.random() - 1);
                var r = radius * (Math.pow(Math.random(), 0.3333333333333333));
                var sinO = Math.sin(o);
                toRet.x = (center ? center.x : 0) + r * Math.cos(theta) * sinO;
                toRet.y = (center ? center.y : 0) + r * Math.sin(theta) * sinO;
                toRet.z = (center ? center.z : 0) + r * Math.cos(o);
            }
            return toRet;
        };
        /**
        * Returns a random point on the radius of a sphere.
        * @param {number} radius The radius of the sphere
        * @param {Vec3} center [Optional] The center position of the sphere
        * @param {Vec3} ref [Optional] Pass in the vector to be filled
        * @returns {Vec3}
        */
        Random.pointOnSphere = function (radius, center, ref) {
            if (radius === void 0) { radius = 1; }
            var toRet = ref || new Trike.Vec3();
            var u = Math.random();
            var v = Math.random();
            var theta = 2 * Math.PI * u;
            var phi = Math.acos(2 * v - 1);
            toRet.x = (center ? center.x : 0) + (radius * Math.sin(phi) * Math.cos(theta));
            toRet.y = (center ? center.y : 0) + (radius * Math.sin(phi) * Math.sin(theta));
            toRet.z = (center ? center.z : 0) + (radius * Math.cos(phi));
            return toRet;
        };
        /**
        * Returns a random point inside of a box.
        * @param {number} width The width of the box
        * @param {number} height The height of the box
        * @param {number} depth The depth of the box
        * @param {Vec3} center [Optional] The center position of the box
        * @param {Vec3} ref [Optional] Pass in the vector to be filled
        * @returns {Vec3}
        */
        Random.pointInsideBox = function (width, height, depth, center, ref) {
            if (width === void 0) { width = 1; }
            if (height === void 0) { height = 1; }
            if (depth === void 0) { depth = 1; }
            var toRet = ref || new Trike.Vec3();
            toRet.x = Math.random() * width - (width * 0.5) + (center ? center.x : 0);
            toRet.y = Math.random() * height - (height * 0.5) + (center ? center.y : 0);
            toRet.z = Math.random() * depth - (depth * 0.5) + (center ? center.z : 0);
            return toRet;
        };
        /**
        * Creates a random number generator that allows you to use seeded random numbers
        * returns {AleaRand}
        */
        Random.Alea = function (args) {
            if (args === void 0) { args = [+new Date]; }
            var s0 = 0;
            var s1 = 0;
            var s2 = 0;
            var c = 1;
            var mash = Mash();
            s0 = mash(' ');
            s1 = mash(' ');
            s2 = mash(' ');
            for (var i = 0; i < args.length; i++) {
                s0 -= mash(args[i]);
                if (s0 < 0) {
                    s0 += 1;
                }
                s1 -= mash(args[i]);
                if (s1 < 0) {
                    s1 += 1;
                }
                s2 -= mash(args[i]);
                if (s2 < 0) {
                    s2 += 1;
                }
            }
            mash = null;
            var random = new AleaRand(s0, s1, s2, c);
            return random;
        };
        return Random;
    }());
    Trike.Random = Random;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Simplex noise is a method for constructing an n-dimensional noise function.
    * It was developed an improvement over Perlin noise. The simplex noise class takes a random
    * number generator to randomly create a noise environment. You can then sample values of that
    * environment in different dimensions.
    *
    * Example usage:
    * const simplex = new SimplexNoise(),
    * value2d = simplex.noise2D( x, y ),
    * value3d = simplex.noise3D( x, y, z ),
    * value4d = simplex.noise4D( x, y, z, w );
    *
    * To use a seeded noise use the following:
    * const randomFunc = Random.Alea([seed]).random,
    * simplex = new SimplexNoise(randomFunc),
    * value2d = simplex.noise2D(x, y);
    */
    var SimplexNoise = (function () {
        function SimplexNoise(random) {
            if (random === void 0) { random = Math.random; }
            this.p = new Uint8Array(256);
            this.perm = new Uint8Array(512);
            this.permMod12 = new Uint8Array(512);
            for (var i = 0; i < 256; i++) {
                this.p[i] = random() * 256;
            }
            for (var i = 0; i < 512; i++) {
                this.perm[i] = this.p[i & 255];
                this.permMod12[i] = this.perm[i] % 12;
            }
            this.grad3 = new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1,
                -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]);
            this.grad4 = new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1,
                1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1, -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1, 1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1,
                -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]);
        }
        /*
        * 2D simplex noise. Use this to generate a number when given three constants.
        * @param {number} x The X constant
        * @param {number} y The Y constant
        * returns {number}
        */
        SimplexNoise.prototype.noise2D = function (xin, yin) {
            var permMod12 = this.permMod12, perm = this.perm, grad3 = this.grad3, G2 = SimplexNoise.G2;
            var n0 = 0, n1 = 0, n2 = 0; // Noise contributions from the three corners
            // Skew the input space to determine which simplex cell we're in
            var s = (xin + yin) * SimplexNoise.F2; // Hairy factor for 2D
            var i = Math.floor(xin + s);
            var j = Math.floor(yin + s);
            var t = (i + j) * G2;
            var X0 = i - t; // Unskew the cell origin back to (x,y) space
            var Y0 = j - t;
            var x0 = xin - X0; // The x,y distances from the cell origin
            var y0 = yin - Y0;
            // For the 2D case, the simplex shape is an equilateral triangle.
            // Determine which simplex we are in.
            var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
            if (x0 > y0) {
                i1 = 1;
                j1 = 0;
            } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
            else {
                i1 = 0;
                j1 = 1;
            } // upper triangle, YX order: (0,0)->(0,1)->(1,1)
            // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
            // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
            // c = (3-sqrt(3))/6
            var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
            var y1 = y0 - j1 + G2;
            var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
            var y2 = y0 - 1.0 + 2.0 * G2;
            // Work out the hashed gradient indices of the three simplex corners
            var ii = i & 255;
            var jj = j & 255;
            // Calculate the contribution from the three corners
            var t0 = 0.5 - x0 * x0 - y0 * y0;
            if (t0 >= 0) {
                var gi0 = permMod12[ii + perm[jj]] * 3;
                t0 *= t0;
                n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient
            }
            var t1 = 0.5 - x1 * x1 - y1 * y1;
            if (t1 >= 0) {
                var gi1 = permMod12[ii + i1 + perm[jj + j1]] * 3;
                t1 *= t1;
                n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1);
            }
            var t2 = 0.5 - x2 * x2 - y2 * y2;
            if (t2 >= 0) {
                var gi2 = permMod12[ii + 1 + perm[jj + 1]] * 3;
                t2 *= t2;
                n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2);
            }
            // Add contributions from each corner to get the final noise value.
            // The result is scaled to return values in the interval [-1,1].
            return 70.0 * (n0 + n1 + n2);
        };
        /*
        * 3D simplex noise. Use this to generate a number when given three constants.
        * @param {number} x The X constant
        * @param {number} y The Y constant
        * @param {number} z The Z constant
        * returns {number}
        */
        SimplexNoise.prototype.noise3D = function (xin, yin, zin) {
            var permMod12 = this.permMod12, perm = this.perm, grad3 = this.grad3, G3 = SimplexNoise.G3, F3 = SimplexNoise.F3;
            var n0, n1, n2, n3; // Noise contributions from the four corners
            // Skew the input space to determine which simplex cell we're in
            var s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D
            var i = Math.floor(xin + s);
            var j = Math.floor(yin + s);
            var k = Math.floor(zin + s);
            var t = (i + j + k) * G3;
            var X0 = i - t; // Unskew the cell origin back to (x,y,z) space
            var Y0 = j - t;
            var Z0 = k - t;
            var x0 = xin - X0; // The x,y,z distances from the cell origin
            var y0 = yin - Y0;
            var z0 = zin - Z0;
            // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
            // Determine which simplex we are in.
            var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
            var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
            if (x0 >= y0) {
                if (y0 >= z0) {
                    i1 = 1;
                    j1 = 0;
                    k1 = 0;
                    i2 = 1;
                    j2 = 1;
                    k2 = 0;
                } // X Y Z order
                else if (x0 >= z0) {
                    i1 = 1;
                    j1 = 0;
                    k1 = 0;
                    i2 = 1;
                    j2 = 0;
                    k2 = 1;
                } // X Z Y order
                else {
                    i1 = 0;
                    j1 = 0;
                    k1 = 1;
                    i2 = 1;
                    j2 = 0;
                    k2 = 1;
                } // Z X Y order
            }
            else {
                if (y0 < z0) {
                    i1 = 0;
                    j1 = 0;
                    k1 = 1;
                    i2 = 0;
                    j2 = 1;
                    k2 = 1;
                } // Z Y X order
                else if (x0 < z0) {
                    i1 = 0;
                    j1 = 1;
                    k1 = 0;
                    i2 = 0;
                    j2 = 1;
                    k2 = 1;
                } // Y Z X order
                else {
                    i1 = 0;
                    j1 = 1;
                    k1 = 0;
                    i2 = 1;
                    j2 = 1;
                    k2 = 0;
                } // Y X Z order
            }
            // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
            // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
            // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
            // c = 1/6.
            var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
            var y1 = y0 - j1 + G3;
            var z1 = z0 - k1 + G3;
            var x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords
            var y2 = y0 - j2 + 2.0 * G3;
            var z2 = z0 - k2 + 2.0 * G3;
            var x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords
            var y3 = y0 - 1.0 + 3.0 * G3;
            var z3 = z0 - 1.0 + 3.0 * G3;
            // Work out the hashed gradient indices of the four simplex corners
            var ii = i & 255;
            var jj = j & 255;
            var kk = k & 255;
            // Calculate the contribution from the four corners
            var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
            if (t0 < 0)
                n0 = 0.0;
            else {
                var gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;
                t0 *= t0;
                n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0);
            }
            var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
            if (t1 < 0)
                n1 = 0.0;
            else {
                var gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;
                t1 *= t1;
                n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1);
            }
            var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
            if (t2 < 0)
                n2 = 0.0;
            else {
                var gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;
                t2 *= t2;
                n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2);
            }
            var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
            if (t3 < 0)
                n3 = 0.0;
            else {
                var gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;
                t3 *= t3;
                n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3);
            }
            // Add contributions from each corner to get the final noise value.
            // The result is scaled to stay just inside [-1,1]
            return 32.0 * (n0 + n1 + n2 + n3);
        };
        /*
        * 4D simplex noise. Use this to generate a number when given four constants.
        * @param {number} x The X constant
        * @param {number} y The Y constant
        * @param {number} z The Z constant
        * @param {number} w The W constant
        * returns {number}
        */
        SimplexNoise.prototype.noise4D = function (x, y, z, w) {
            var permMod12 = this.permMod12, perm = this.perm, grad4 = this.grad4, G4 = SimplexNoise.G4, F4 = SimplexNoise.F4;
            var n0, n1, n2, n3, n4; // Noise contributions from the five corners
            // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
            var s = (x + y + z + w) * F4; // Factor for 4D skewing
            var i = Math.floor(x + s);
            var j = Math.floor(y + s);
            var k = Math.floor(z + s);
            var l = Math.floor(w + s);
            var t = (i + j + k + l) * G4; // Factor for 4D unskewing
            var X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
            var Y0 = j - t;
            var Z0 = k - t;
            var W0 = l - t;
            var x0 = x - X0; // The x,y,z,w distances from the cell origin
            var y0 = y - Y0;
            var z0 = z - Z0;
            var w0 = w - W0;
            // For the 4D case, the simplex is a 4D shape I won't even try to describe.
            // To find out which of the 24 possible simplices we're in, we need to
            // determine the magnitude ordering of x0, y0, z0 and w0.
            // Six pair-wise comparisons are performed between each possible pair
            // of the four coordinates, and the results are used to rank the numbers.
            var rankx = 0;
            var ranky = 0;
            var rankz = 0;
            var rankw = 0;
            if (x0 > y0)
                rankx++;
            else
                ranky++;
            if (x0 > z0)
                rankx++;
            else
                rankz++;
            if (x0 > w0)
                rankx++;
            else
                rankw++;
            if (y0 > z0)
                ranky++;
            else
                rankz++;
            if (y0 > w0)
                ranky++;
            else
                rankw++;
            if (z0 > w0)
                rankz++;
            else
                rankw++;
            var i1, j1, k1, l1; // The integer offsets for the second simplex corner
            var i2, j2, k2, l2; // The integer offsets for the third simplex corner
            var i3, j3, k3, l3; // The integer offsets for the fourth simplex corner
            // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
            // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
            // impossible. Only the 24 indices which have non-zero entries make any sense.
            // We use a thresholding to set the coordinates in turn from the largest magnitude.
            // Rank 3 denotes the largest coordinate.
            i1 = rankx >= 3 ? 1 : 0;
            j1 = ranky >= 3 ? 1 : 0;
            k1 = rankz >= 3 ? 1 : 0;
            l1 = rankw >= 3 ? 1 : 0;
            // Rank 2 denotes the second largest coordinate.
            i2 = rankx >= 2 ? 1 : 0;
            j2 = ranky >= 2 ? 1 : 0;
            k2 = rankz >= 2 ? 1 : 0;
            l2 = rankw >= 2 ? 1 : 0;
            // Rank 1 denotes the second smallest coordinate.
            i3 = rankx >= 1 ? 1 : 0;
            j3 = ranky >= 1 ? 1 : 0;
            k3 = rankz >= 1 ? 1 : 0;
            l3 = rankw >= 1 ? 1 : 0;
            // The fifth corner has all coordinate offsets = 1, so no need to compute that.
            var x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
            var y1 = y0 - j1 + G4;
            var z1 = z0 - k1 + G4;
            var w1 = w0 - l1 + G4;
            var x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords
            var y2 = y0 - j2 + 2.0 * G4;
            var z2 = z0 - k2 + 2.0 * G4;
            var w2 = w0 - l2 + 2.0 * G4;
            var x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords
            var y3 = y0 - j3 + 3.0 * G4;
            var z3 = z0 - k3 + 3.0 * G4;
            var w3 = w0 - l3 + 3.0 * G4;
            var x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords
            var y4 = y0 - 1.0 + 4.0 * G4;
            var z4 = z0 - 1.0 + 4.0 * G4;
            var w4 = w0 - 1.0 + 4.0 * G4;
            // Work out the hashed gradient indices of the five simplex corners
            var ii = i & 255;
            var jj = j & 255;
            var kk = k & 255;
            var ll = l & 255;
            // Calculate the contribution from the five corners
            var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
            if (t0 < 0)
                n0 = 0.0;
            else {
                var gi0 = (perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32) * 4;
                t0 *= t0;
                n0 = t0 * t0 * (grad4[gi0] * x0 + grad4[gi0 + 1] * y0 + grad4[gi0 + 2] * z0 + grad4[gi0 + 3] * w0);
            }
            var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
            if (t1 < 0)
                n1 = 0.0;
            else {
                var gi1 = (perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32) * 4;
                t1 *= t1;
                n1 = t1 * t1 * (grad4[gi1] * x1 + grad4[gi1 + 1] * y1 + grad4[gi1 + 2] * z1 + grad4[gi1 + 3] * w1);
            }
            var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
            if (t2 < 0)
                n2 = 0.0;
            else {
                var gi2 = (perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32) * 4;
                t2 *= t2;
                n2 = t2 * t2 * (grad4[gi2] * x2 + grad4[gi2 + 1] * y2 + grad4[gi2 + 2] * z2 + grad4[gi2 + 3] * w2);
            }
            var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
            if (t3 < 0)
                n3 = 0.0;
            else {
                var gi3 = (perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32) * 4;
                t3 *= t3;
                n3 = t3 * t3 * (grad4[gi3] * x3 + grad4[gi3 + 1] * y3 + grad4[gi3 + 2] * z3 + grad4[gi3 + 3] * w3);
            }
            var t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
            if (t4 < 0)
                n4 = 0.0;
            else {
                var gi4 = (perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32) * 4;
                t4 *= t4;
                n4 = t4 * t4 * (grad4[gi4] * x4 + grad4[gi4 + 1] * y4 + grad4[gi4 + 2] * z4 + grad4[gi4 + 3] * w4);
            }
            // Sum up and scale the result to cover the range [-1,1]
            return 27.0 * (n0 + n1 + n2 + n3 + n4);
        };
        SimplexNoise.F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
        SimplexNoise.G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
        SimplexNoise.F3 = 1.0 / 3.0;
        SimplexNoise.G3 = 1.0 / 6.0;
        SimplexNoise.F4 = (Math.sqrt(5.0) - 1.0) / 4.0;
        SimplexNoise.G4 = (5.0 - Math.sqrt(5.0)) / 20.0;
        return SimplexNoise;
    }());
    Trike.SimplexNoise = SimplexNoise;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /*
    * A Class of useful interpolater functions
    * http://flashcove.net/795/cubic-spline-generation-in-as3-catmull-rom-curves/
    */
    var Interpolater = (function () {
        function Interpolater() {
        }
        /**
        * Catmull works by specifying 4 control points p0, p1, p2, p3 and a weight. The function is used to calculate a point n between p1 and p2 based
        * on the weight. The weight is normalized, so if it's a value of 0 then the return value will be p1 and if its 1 it will return p2.
        * @param {number} p0 The first control point. If set to p1 then the interpolation will start from p1 exactly
        * @param {number} p1 The first value
        * @param {number} p2 The second value
        * @param {number} p3 The second control point. If set to p3 then the interpolation will start from p1 exactly
        * @param {number} weight The normalized weight, ideally from 0 to 1
        * @returns {number}
        */
        Interpolater.catmullRom = function (p0, p1, p2, p3, weight) {
            var weight2 = weight * weight;
            var weight3 = weight2 * weight;
            var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5;
            return (2 * (p1 - p2) + v0 + v1) * weight3 + (-3 * (p1 - p2) - 2 * v0 - v1) * weight2 + v0 * weight + p1;
        };
        /**
        * Interpolates between two numbers based on a weight
        * @param {number} a The first number
        * @param {number} b The second number
        * @param {number} weight The normalized weight, ideally from 0 to 1
        * @returns {number}
        */
        Interpolater.interpolate = function (a, b, weight) {
            return a + (b - a) * weight;
        };
        /**
        * Same as catmullRom, but optimized to work with {Vec2}
        * @param {Vec2} p0 The first control point. If set to p1 then the interpolation will start from p1 exactly
        * @param {Vec2} p1 The first value
        * @param {Vec2} p2 The second value
        * @param {Vec2} p3 The second control point. If set to p3 then the interpolation will start from p1 exactly
        * @param {number} weight The normalized weight, ideally from 0 to 1
        * @returns {Vec2}
        */
        Interpolater.catmullRomV2 = function (p0, p1, p2, p3, weight, out) {
            var u3 = weight * weight * weight;
            var u2 = weight * weight;
            var f1 = -0.5 * u3 + u2 - 0.5 * weight;
            var f2 = 1.5 * u3 - 2.5 * u2 + 1.0;
            var f3 = -1.5 * u3 + 2.0 * u2 + 0.5 * weight;
            var f4 = 0.5 * u3 - 0.5 * u2;
            var x = p0.x * f1 + p1.x * f2 + p2.x * f3 + p3.x * f4;
            var y = p0.y * f1 + p1.y * f2 + p2.y * f3 + p3.y * f4;
            return (out ? out.set(x, y) : new Trike.Vec2(x, y));
        };
        /**
        * Calculates a point on a line, from a set of graph points using catmul-rom interpolation.
        * Given an array of 2D points representing a graph over two axes x and y.
        * We query each of the points using a queryValue that tests which of the
        * points is closest based on the desired query axis. For example if your array of points represents
        * values (y) over time (x); you can query a value v at time 0.2 like so
        * catmulValueFromGraph(points, 0.2, x)
        * @param {Array<Vec2>} points The control points that represent the graph
        * @param {number} queryValue The value to check
        * @param {string} queryAxis The axis to check values against
        * @param {Vec2} out [Optional] Specify a vector to fill instead of creating a new one
        * @returns {Vec2}
        */
        Interpolater.catmulValueFromGraph = function (points, queryValue, queryAxis, out) {
            if (queryAxis === void 0) { queryAxis = 'x'; }
            var p0 = null, p1 = null, p2 = null, p3 = null;
            for (var i = 0, l = points.length; i < l; i++) {
                if (i > 0)
                    p0 = points[i - 1];
                else
                    p0 = points[i];
                p1 = points[i];
                if (i + 1 < l)
                    p2 = points[i + 1];
                else
                    p2 = points[i];
                if (i + 2 < l)
                    p3 = points[i + 1];
                else
                    p3 = points[i];
                if (queryValue >= p1[queryAxis] && queryValue <= p2[queryAxis]) {
                    var weight = (queryValue - p1[queryAxis]) / (p2[queryAxis] - p1[queryAxis]);
                    return Interpolater.catmullRomV2(p0, p1, p2, p3, weight, out);
                }
            }
            return null;
        };
        /**
        * Creates a interpolated path array of 2D points from a given path. The granularity of the out array
        * is decided by the number of intervals.
        * @param {Array<Vec2>} path The path you want to smooth out
        * @param {number} interval The interval of each sample
        * @param {Array<Vec2>} out [Optional]
        * @returns {Array<Vec2>}
        */
        Interpolater.catmullRomPathV2 = function (path, interval, out) {
            if (interval === void 0) { interval = 0.01; }
            if (out === void 0) { out = []; }
            if (path === null)
                return;
            for (var i = 0, l = path.length; i < l - 1; i++) {
                var ui = 0;
                for (var u = 0.0; u < 1.0; u += interval) {
                    var vec = new Trike.Vec2();
                    vec = Interpolater.catmullRomV2(path[Math.max(0, i - 1)], path[i], path[Math.min(i + 1, l - 1)], path[Math.min(i + 2, l - 1)], u);
                    out.push(vec); // store each value
                    ui++;
                }
            }
            return out;
        };
        /**
        * Creates a interpolated path array of 3D points from a given path. The granularity of the out array
        * @param {Array<Vec3>} path The path you want to smooth out
        * @param {number} interval The interval of each sample
        * @param {Array<Vec3>} out [Optional]
        * @returns {Array<Vec3>}
        */
        Interpolater.catmullRomPathV3 = function (path, interval, out) {
            if (interval === void 0) { interval = 0.01; }
            if (out === void 0) { out = []; }
            if (path === null)
                return;
            var pa, pb, pc, pd;
            for (var i = 0, l = path.length; i < l - 1; i++) {
                var ui = 0;
                for (var u = 0.0; u < 1.0; u += interval) {
                    pa = path[Math.max(0, i - 1)];
                    pb = path[i];
                    pc = path[Math.min(i + 1, l - 1)];
                    pd = path[Math.min(i + 2, l - 1)];
                    var vec = new Trike.Vec3();
                    vec.x = Interpolater.catmullRom(pa.x, pb.x, pc.x, pd.x, u);
                    vec.y = Interpolater.catmullRom(pa.y, pb.y, pc.y, pd.y, u);
                    vec.z = Interpolater.catmullRom(pa.z, pb.z, pc.z, pd.z, u);
                    out.push(vec); // store each value
                    ui++;
                }
            }
            return out;
        };
        return Interpolater;
    }());
    Trike.Interpolater = Interpolater;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * This class represents a face triangle. Each geometry in Trike is made up of these faces and each face keeps a set of references to each
    * of its vertices (a, b and c).
    */
    var Face3 = (function () {
        function Face3(a, b, c, normal, materialIndex) {
            if (normal === void 0) { normal = new Trike.Vec3(); }
            this.a = a;
            this.b = b;
            this.c = c;
            this.normal = normal;
            this.vertexNormals = new Array(3);
            this.vertexTangents = new Array(3);
            this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
            this.centroid = new Trike.Vec3(0, 0, 0);
            this.attributeIndices = [];
            // We create the default position buffer based on the a, b and c indices provided
            this.setAttributeIndices(Trike.AttributeType.POSITION, a, b, c);
        }
        Face3.prototype.setAttributeIndices = function (type, i1, i2, i3) {
            this.attributeIndices[type] = [i1, i2, i3];
        };
        /**
        * Clones a new Face3 object
        */
        Face3.prototype.clone = function () {
            var face = new Face3(this.a, this.b, this.c);
            face.normal.copy(this.normal);
            face.centroid.copy(this.centroid);
            face.materialIndex = this.materialIndex;
            var i, il;
            for (i = 0, il = this.vertexNormals.length; i < il; i++) {
                if (this.vertexNormals[i])
                    face.vertexNormals[i] = this.vertexNormals[i].clone();
            }
            for (i = 0, il = this.vertexTangents.length; i < il; i++) {
                if (this.vertexTangents[i])
                    face.vertexTangents[i] = this.vertexTangents[i].clone();
            }
            for (var a in this.attributeIndices) {
                if (!this.attributeIndices[a])
                    continue;
                face.setAttributeIndices(parseInt(a), this.attributeIndices[a][0], this.attributeIndices[a][1], this.attributeIndices[a][2]);
            }
            return face;
        };
        return Face3;
    }());
    Trike.Face3 = Face3;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A simple holder class for geometry bone data. This is not the actual bone
    * attached to a mesh. This is simply a holder of the original data loaded in from files.
    */
    var BoneInfo = (function () {
        function BoneInfo(pos, rotation, scale, name, parent) {
            this.name = name;
            this.parent = parent;
            this.position = pos;
            this.rotation = rotation;
            this.scale = scale;
        }
        return BoneInfo;
    }());
    Trike.BoneInfo = BoneInfo;
    /**
    * A buffer which correlates to a material attribute. Geometries can have multiple buffers and each must be
    * unique using the AttributeType to identify the buffer. Fill the data member with Vectors or
    * data then needs to be sent to the GPU. When being compiled the data variable is flattened out into a
    * single Float32Array called dataFlat. Rebuilding the geometry will often mean having to rebuild these
    * buffers.
    */
    var GeometryBuffer = (function () {
        function GeometryBuffer(data, elementSize, type) {
            this.data = data;
            this.elementSize = elementSize;
            this.type = type;
            this.buffer = null;
            this.dataFlat = null;
        }
        /**
        * Use this function to convert the data object to a flat Float32Array stored in the variable dataFlat
        * @param {Array<any>} flattenedData Optionally you can pass data instead of using the data stored in the buffer.
        */
        GeometryBuffer.prototype.flattenData = function (flattenedData) {
            var elmSize = this.elementSize;
            var data = (flattenedData ? flattenedData : this.data);
            var df = new Float32Array(data.length * elmSize);
            var counter = 0;
            for (var i = 0, len = data.length; i < len; i++) {
                if (data[i] instanceof Trike.Vec2) {
                    df[counter] = data[i].x;
                    df[counter + 1] = data[i].y;
                }
                else if (data[i] instanceof Trike.Vec3) {
                    df[counter] = data[i].x;
                    df[counter + 1] = data[i].y;
                    df[counter + 2] = data[i].z;
                }
                else if (data[i] instanceof Trike.Vec4 || data[i] instanceof Trike.Quat) {
                    df[counter] = data[i].x;
                    df[counter + 1] = data[i].y;
                    df[counter + 2] = data[i].z;
                    df[counter + 3] = data[i].w;
                }
                else if (data[i] instanceof Trike.Color) {
                    df[counter] = data[i].r;
                    df[counter + 1] = data[i].g;
                    df[counter + 2] = data[i].b;
                    df[counter + 3] = data[i].a;
                }
                else if (typeof (data[i]) === 'number') {
                    df[counter] = data[i];
                }
                else {
                    for (var ii = 0, len2 = elmSize; ii < len2; ii++)
                        df[counter + ii] = data[i][ii];
                }
                counter += elmSize;
            }
            this.dataFlat = df;
        };
        return GeometryBuffer;
    }());
    Trike.GeometryBuffer = GeometryBuffer;
    /**
    * Holds the indices used to draw a mesh. These are generated from the faces of the geometry object.
    */
    var GeometryIndexBuffer = (function () {
        function GeometryIndexBuffer(data) {
            this.data = data || [];
            this.elementSize = 1;
            this.buffer = null;
            this.dataFlat = null;
        }
        /**
        * Use this function to convert the data object to a flat Float32Array stored in the variable dataFlat
        */
        GeometryIndexBuffer.prototype.flattenData = function (numTris) {
            var data = this.data;
            // If the index buffer is very big, then we need to use a bigger buffer. Simply check the tri count
            // i.e. 65535 / 3
            if (numTris > 21845 && Trike.Capabilities.getSingleton().uintIndices)
                this.dataFlat = new Uint32Array(data.length);
            else
                this.dataFlat = new Uint16Array(data.length);
            var df = this.dataFlat;
            for (var i = 0, len = data.length; i < len; i++)
                df[i] = data[i];
        };
        return GeometryIndexBuffer;
    }());
    Trike.GeometryIndexBuffer = GeometryIndexBuffer;
    (function (BufferUsage) {
        BufferUsage[BufferUsage["Static"] = 0] = "Static";
        BufferUsage[BufferUsage["Dynamic"] = 1] = "Dynamic";
        BufferUsage[BufferUsage["Streaming"] = 2] = "Streaming";
    })(Trike.BufferUsage || (Trike.BufferUsage = {}));
    var BufferUsage = Trike.BufferUsage;
    /**
    * The base class for all geometry. Every visual in a 3D scene requires some form of Geometry. You can either
    * use the class directly and add attribures & faces, or you can use some of the premade sub classes such as GeometryCube.
    */
    var Geometry = (function (_super) {
        __extends(Geometry, _super);
        function Geometry() {
            _super.call(this);
            this._requiresBuild = true;
            this.bufferUsage = BufferUsage.Static;
            this._buffers = new Array(10); // There are 10 AttributeTypes
            for (var i = 0; i < 10; i++)
                this._buffers[i] = null;
            this._cleanup = [];
            this.faces = [];
            this._indexBuffer = null;
            this._indexBufferLines = null;
            this.compileStatus = '';
            this.boundingSphere = new Trike.Sphere();
            this.boundingBox = new Trike.Box3();
            this.numInfluences = 2;
            this.buildCount = 0;
            this.animationSets = new Array();
            this.bones = new Array();
            this.dirtyBuffers = new Array();
            this._dataMap = [];
        }
        /**
        * Attempts to merge the provided geometry into this geometry's buffers. Try to make sure that all geometries you merge
        * should have the same number of buffers and buffer types
        * @param {Geometry} geom The geometry we are merging to this geometry
        * @returns {Geometry}
        */
        Geometry.prototype.mergGeometry = function (geom) {
            var buffers = this._buffers;
            var animationSets = this.animationSets;
            var bones = this.bones;
            var faces = this.faces;
            var newFaces = new Array();
            for (var i = 0, l = geom.faces.length; i < l; i++) {
                var newFace = geom.faces[i].clone();
                newFaces.push(newFace);
                for (var a in geom.faces[i].attributeIndices) {
                    if (!geom.faces[i].attributeIndices[a])
                        continue;
                    if (!buffers[a])
                        continue;
                    // Get the current number of attribute items of that attribute type
                    var curSize = buffers[a].data.length;
                    newFace.attributeIndices[a][0] = newFace.attributeIndices[a][0] + curSize;
                    newFace.attributeIndices[a][1] = newFace.attributeIndices[a][1] + curSize;
                    newFace.attributeIndices[a][2] = newFace.attributeIndices[a][2] + curSize;
                }
            }
            for (var i = 0, l = geom._buffers.length; i < l; i++) {
                if (!geom._buffers[i])
                    continue;
                if (!buffers[i])
                    buffers[i] = new GeometryBuffer(geom._buffers[i].data.slice(0), geom._buffers[i].elementSize, geom._buffers[i].type);
                else
                    buffers[i].data.push.apply(buffers[i].data, geom._buffers[i].data);
            }
            animationSets.push.apply(animationSets, geom.animationSets);
            bones.push.apply(bones, geom.bones);
            faces.push.apply(faces, newFaces);
            this.computeFaceNormals();
            this.generateNormals();
            this.computeCentroids();
            // this.mergeVertices();
            this._requiresBuild = true;
            return this;
        };
        /**
        * Gets an animation set by its name
        * @returns {AnimationTrack}
        */
        Geometry.prototype.getAnimationSet = function (name) {
            var animationSets = this.animationSets;
            for (var i = 0, l = animationSets.length; i < l; i++)
                if (animationSets[i].name === name)
                    return animationSets[i];
            return null;
        };
        /**
        * Adds a new buffer to the geometry. This will replace any existing buffers of the same type.
        * Will trigger a rebuild.
        * @returns {GeometryBuffer}
        */
        Geometry.prototype.addAttributes = function (buffer) {
            // If we are replacing a buffer we need to make sure the existing buffer is added to
            // the cleanup array.
            var buffers = this._buffers;
            if (buffers[buffer.type])
                this._cleanup.push(buffers[buffer.type].buffer);
            buffers[buffer.type] = buffer;
            this._requiresBuild = true;
            return buffer;
        };
        /**
        * Removes an attribute buffer
        */
        Geometry.prototype.removeAttribute = function (type) {
            var buffers = this._buffers;
            if (buffers[type])
                this._cleanup.push(buffers[type].buffer);
            buffers[type] = null;
        };
        /**
        * Removes all data from the Geometry. This is useful if you want re-make the geometry.
        */
        Geometry.prototype.resetBuffers = function () {
            var buffers = this._buffers;
            for (var i in buffers)
                if (buffers[i]) {
                    this._cleanup.push(buffers[i].buffer);
                    buffers[i] = null;
                }
            if (this._indexBuffer)
                this._cleanup.push(this._indexBuffer.buffer);
            if (this._indexBufferLines)
                this._cleanup.push(this._indexBufferLines.buffer);
            this._indexBuffer = null;
            this._indexBufferLines = null;
            this.faces = [];
            this.animationSets.splice(0, this.animationSets.length);
            this.bones.splice(0, this.bones.length);
            this._requiresBuild = true;
            return this;
        };
        /**
        * Rebuilds only specific buffers whose data has been modified outside the class.
        * If the number data of elements has changed, then this will throw errors and you should instead flag
        * the geometry for rebuild. Use this function, when the number of items stays the same, but we just need to flush
        * new values.
        * @param {WebGLRenderingContext} gl The webgl context
        */
        Geometry.prototype.updateDirtyBuffers = function (gl) {
            var dirty = this.dirtyBuffers, usage = this._usage, faces = this.faces, dataMap = this._dataMap;
            var b, face;
            for (var i = 0, l = dirty.length; i < l; i++) {
                b = dirty[i];
                if (faces.length > 0) {
                    // Create arrays to hold the face data.
                    dataMap.splice(0, dataMap.length);
                    // For each face
                    for (var fi = 0, flen = faces.length; fi < flen; fi++) {
                        face = faces[fi];
                        var faceAttributeIndices = face.attributeIndices[b.type];
                        // This will override any existing data which ensures only the data we need will go through.
                        dataMap.push(b.data[faceAttributeIndices[0]]);
                        dataMap.push(b.data[faceAttributeIndices[1]]);
                        dataMap.push(b.data[faceAttributeIndices[2]]);
                    }
                    b.flattenData(dataMap);
                    gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, b.dataFlat, usage);
                }
                else {
                    // Flatten and bind
                    b.flattenData();
                    gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, b.dataFlat, usage);
                }
            }
            dirty.splice(0, dirty.length);
            return true;
        };
        /**
        * Builds the geometry webgl buffers
        * @param {WebGLRenderingContext} gl The webgl context
        */
        Geometry.prototype.buildGeometry = function (gl) {
            this.compileStatus = 'Compiled Successfully';
            var buffers = this._buffers;
            var i = buffers.length;
            var numElements = 0;
            var faces = this.faces;
            var usage = gl.STREAM_DRAW;
            var dataMap = this._dataMap;
            this.buildCount++;
            if (this.bufferUsage === BufferUsage.Static)
                usage = gl.STATIC_DRAW;
            else if (this.bufferUsage === BufferUsage.Dynamic)
                usage = gl.DYNAMIC_DRAW;
            // Cleanup any buffers buffers who have been replaced by new ones.
            var cleanup = this._cleanup;
            i = cleanup.length;
            while (i--)
                if (cleanup[i])
                    gl.deleteBuffer(cleanup[i]);
            this._cleanup.splice(0, this._cleanup.length);
            // If a webgl buffer exists, delete it as we are creating new data.
            i = buffers.length;
            while (i--) {
                if (!buffers[i])
                    continue;
                if (buffers[i].buffer)
                    gl.deleteBuffer(buffers[i].buffer);
                buffers[i].buffer = null;
            }
            // Cleanup the index buffers
            if (this._indexBuffer)
                gl.deleteBuffer(this._indexBuffer.buffer);
            if (this._indexBufferLines)
                gl.deleteBuffer(this._indexBufferLines.buffer);
            this._indexBuffer = null;
            this._indexBufferLines = null;
            // IF we have faces, we need to take the data stored in each buffer and essentially flatten it out by the face index.
            // We do this by looking at the face indices of each buffer and matching those indices to the data stored in the
            // geometry buffers. This will not only flatten the data out - it will also mean the data is order from 0 - num of faces
            if (faces.length > 0) {
                // Since we have faces we can create a new index buffer.
                this._indexBuffer = new GeometryIndexBuffer();
                this._indexBufferLines = new GeometryIndexBuffer();
                var c = 0, flatCounter = 0;
                var face = void 0, datum = void 0;
                // For each buffer
                i = buffers.length;
                while (i--) {
                    if (!buffers[i])
                        continue;
                    // Create arrays to hold the face data.
                    dataMap.splice(0, dataMap.length);
                    // For each face
                    for (var fi = 0, flen = faces.length; fi < flen; fi++) {
                        face = faces[fi];
                        // Do nothing if we dont have a set of face attribute indices
                        if (!face.attributeIndices[buffers[i].type]) {
                            this.compileStatus = 'Geometry [' + this.constructor.name + '] uses faces, but does map the vertex data for its buffer[' + buffers[i].type + '].';
                            return false;
                        }
                        var faceAttributeIndices = face.attributeIndices[buffers[i].type];
                        // This will override any existing data which ensures only the data we need will go through.
                        dataMap.push(buffers[i].data[faceAttributeIndices[0]]);
                        dataMap.push(buffers[i].data[faceAttributeIndices[1]]);
                        dataMap.push(buffers[i].data[faceAttributeIndices[2]]);
                    }
                    buffers[i].flattenData(dataMap);
                }
                var indexCounter = 0;
                for (var fi = 0, flen = faces.length; fi < flen; fi++) {
                    this._indexBuffer.data.push(indexCounter, indexCounter + 1, indexCounter + 2);
                    // Create the line indices (as squares)
                    if (fi % 2 === 0) {
                        this._indexBufferLines.data.push(indexCounter, indexCounter + 1, indexCounter, indexCounter + 2);
                    }
                    else {
                        this._indexBufferLines.data.push(indexCounter, indexCounter + 1, indexCounter + 1, indexCounter + 2);
                    }
                    indexCounter += 3;
                }
            }
            else {
                i = buffers.length;
                while (i--) {
                    if (!buffers[i])
                        continue;
                    buffers[i].flattenData();
                    // Make sure the buffer lengths are the same.
                    var len = buffers[i].dataFlat.length / buffers[i].elementSize;
                    if (len !== numElements && numElements !== 0) {
                        this.compileStatus = 'Could not compile geometry. The buffers sizes are not consistent. For each geometry you can have multiple attribute buffers, but each buffer size must be the same as buffer.dataFlat.length / buffer.elementSize.';
                        return false;
                    }
                    numElements = len;
                }
            }
            // Now go through each buffer and bind its data.
            i = buffers.length;
            while (i--) {
                if (!buffers[i])
                    continue;
                // First create the buffer
                buffers[i].buffer = gl.createBuffer();
                // Then bind the data
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers[i].buffer);
                gl.bufferData(gl.ARRAY_BUFFER, buffers[i].dataFlat, usage);
            }
            // If an index buffer was set, then lets create it.
            if (this._indexBuffer) {
                this._indexBuffer.flattenData(this.faces.length);
                this._indexBuffer.buffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer.buffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer.dataFlat, usage);
                this._indexBufferLines.flattenData(this.faces.length);
                this._indexBufferLines.buffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBufferLines.buffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._indexBufferLines.dataFlat, usage);
            }
            this._numElements = numElements;
            this._usage = usage;
            this._requiresBuild = false;
            this.dirtyBuffers.splice(0, this.dirtyBuffers.length);
            // this.computeBoundingBox();
            // this.computeBoundingSphere();
            return true;
        };
        /**
        * Computes the bounding box of the geometry.
        */
        Geometry.prototype.computeBoundingBox = function () {
            var pBuffer = this.buffers[Trike.AttributeType.POSITION];
            if (pBuffer) {
                var vertices = pBuffer.data;
                this.boundingBox.setFromPoints(vertices);
            }
        };
        /**
        * Computes the bounding sphere of the geometry.
        */
        Geometry.prototype.computeBoundingSphere = function () {
            var pBuffer = this.buffers[Trike.AttributeType.POSITION];
            if (pBuffer) {
                var vertices = pBuffer.data;
                this.boundingSphere.setFromPoints(vertices);
            }
        };
        /**
        * Reverses the face order so that A, B, C becomes C, B, A
        */
        Geometry.prototype.reverseFaceOrder = function () {
            var faces = this.faces;
            for (var i = 0, l = faces.length; i < l; i++) {
                var a = faces[i].a, c = faces[i].c;
                faces[i].a = c;
                faces[i].c = a;
                for (var att in faces[i].attributeIndices) {
                    if (faces[i].attributeIndices[att]) {
                        a = faces[i].attributeIndices[att][0];
                        c = faces[i].attributeIndices[att][2];
                        faces[i].attributeIndices[att][0] = c;
                        faces[i].attributeIndices[att][2] = a;
                    }
                }
            }
        };
        /**
        * Transforms the vertices and normals by a matrix
        */
        Geometry.prototype.applyMatrix = function (matrix) {
            var normalMatrix = new Trike.Matrix3().getNormalMatrix(matrix);
            var vertices = this.buffers[Trike.AttributeType.POSITION].data;
            var normals = (this.buffers[Trike.AttributeType.NORMAL] ? this.buffers[Trike.AttributeType.NORMAL].data : null);
            for (var i = 0, il = vertices.length; i < il; i++) {
                var vertex = vertices[i];
                vertex.applyMatrix4(matrix);
            }
            if (normals) {
                for (var i = 0, il = this.faces.length; i < il; i++) {
                    var face = this.faces[i];
                    face.normal.applyMatrix3(normalMatrix).normalize();
                    normals[face.attributeIndices[Trike.AttributeType.NORMAL][0]].applyMatrix3(normalMatrix).normalize();
                    normals[face.attributeIndices[Trike.AttributeType.NORMAL][1]].applyMatrix3(normalMatrix).normalize();
                    normals[face.attributeIndices[Trike.AttributeType.NORMAL][2]].applyMatrix3(normalMatrix).normalize();
                    face.centroid.applyMatrix4(matrix);
                }
            }
            this.computeBoundingBox();
            this.computeBoundingSphere();
            this._requiresBuild = true;
            return this;
        };
        /**
        * Will generate a color buffer if one doesnt exist. If one does exist it will set each of its colors
        * to the given color parameter.
        */
        Geometry.prototype.generateColors = function (color) {
            if (color === void 0) { color = 0xFFFFFF; }
            var faces = this.faces;
            var face;
            var colors;
            if (this._buffers[Trike.AttributeType.COLOR])
                this._cleanup.push(this._buffers[Trike.AttributeType.COLOR].buffer);
            // We need to get / create the colors for this geometry and fill it with color data.
            var colorBuffer = new GeometryBuffer([], 4, Trike.AttributeType.COLOR);
            this._buffers[Trike.AttributeType.COLOR] = colorBuffer;
            colors = colorBuffer.data;
            // Now that we have color data, we need to tell each face which datum it points to
            for (var i = 0, flen = faces.length; i < flen; i++) {
                face = faces[i];
                colors.push(new Trike.Color(color));
                colors.push(new Trike.Color(color));
                colors.push(new Trike.Color(color));
                face.attributeIndices[Trike.AttributeType.COLOR] = [colors.length - 3, colors.length - 2, colors.length - 1];
            }
            this._requiresBuild = true;
        };
        /**
        * Generates a normal buffer if none exists, or otherwise re-calculates the normal buffer data.
        * Will trigger a re-build.
        * @param {boolean} smoothNormals If true, then each normal will be smoothed. If false the normals will create
        * flat shading.
        */
        Geometry.prototype.generateNormals = function (smoothNormals) {
            if (smoothNormals === void 0) { smoothNormals = false; }
            if (!this._buffers[Trike.AttributeType.POSITION])
                throw new Error('You must have a position buffer to calculate the normal buffer.');
            // Create vars
            var v, vl, f, fl, face;
            var faces = this.faces;
            var positions = this._buffers[Trike.AttributeType.POSITION].data;
            var normals;
            // We need to get / create the normals for this geometry.
            // No normal buffer, so lets create one with the same size as the positions
            if (this._buffers[Trike.AttributeType.NORMAL])
                this._cleanup.push(this._buffers[Trike.AttributeType.NORMAL].buffer);
            var normalBuffer = new GeometryBuffer(new Array(positions.length), 3, Trike.AttributeType.NORMAL);
            this._buffers[Trike.AttributeType.NORMAL] = normalBuffer;
            normals = normalBuffer.data;
            var i = positions.length;
            while (i--)
                normals[i] = new Trike.Vec3(0, 0, 0);
            // If smooth, then we average out the normals over each face.
            if (smoothNormals) {
                // vertex normals weighted by triangle areas
                // http://www.iquilezles.org/www/articles/normals/normals.htm
                var vA = void 0, vB = void 0, vC = void 0, vD = void 0;
                var cb = new Trike.Vec3(0, 0, 0), ab = new Trike.Vec3(0, 0, 0), db = new Trike.Vec3(0, 0, 0), dc = new Trike.Vec3(0, 0, 0), bc = new Trike.Vec3(0, 0, 0);
                for (f = 0, fl = faces.length; f < fl; f++) {
                    face = faces[f];
                    vA = positions[face.a];
                    vB = positions[face.b];
                    vC = positions[face.c];
                    cb.subVectors(vC, vB);
                    ab.subVectors(vA, vB);
                    cb.subVectors(cb, ab);
                    // Cumulate the normals value
                    normals[face.a].addVectors(normals[face.a], cb);
                    normals[face.b].addVectors(normals[face.b], cb);
                    normals[face.c].addVectors(normals[face.c], cb);
                }
            }
            else {
                // Just copy the face normal
                for (f = 0, fl = faces.length; f < fl; f++) {
                    face = faces[f];
                    normals[face.a].addVectors(normals[face.a], face.normal);
                    normals[face.b].addVectors(normals[face.b], face.normal);
                    normals[face.c].addVectors(normals[face.c], face.normal);
                }
            }
            // Normalise the vectors so they are from 0 to 1
            for (v = 0, vl = normals.length; v < vl; v++)
                normals[v].normalize();
            for (f = 0, fl = faces.length; f < fl; f++) {
                face = faces[f];
                // Vec3.copy( face.vertexNormals[0], normals[face.a] );
                // Vec3.copy( face.vertexNormals[1], normals[face.b] );
                // Vec3.copy( face.vertexNormals[2], normals[face.c] );
                face.attributeIndices[Trike.AttributeType.NORMAL] = [face.a, face.b, face.c];
            }
            this._requiresBuild = true;
        };
        /**
        * Computes the face normal by getting the cross product of each of its position vertices. You must have a position buffer added in order for this to work.
        */
        Geometry.prototype.computeFaceNormals = function () {
            if (!this._buffers[Trike.AttributeType.POSITION])
                return;
            var cb = new Trike.Vec3(0, 0, 0), ab = new Trike.Vec3(0, 0, 0);
            var vertices = this._buffers[Trike.AttributeType.POSITION].data;
            for (var f = 0, fl = this.faces.length; f < fl; f++) {
                var face = this.faces[f];
                var vA = vertices[face.a];
                var vB = vertices[face.b];
                var vC = vertices[face.c];
                cb.subVectors(vC, vB); // cb.subVectors( vC, vB );
                ab.subVectors(vA, vB); // ab.subVectors( vA, vB );
                cb.crossVectors(cb, ab); // cb.cross( ab );
                cb.normalize();
                face.normal.copy(cb);
            }
        };
        /**
        * Checks for duplicate vertices with hashmap and faces'vertex indices are updated. You must have a position buffer added in order for this to work.
        * @returns The number of vertices removed.
        */
        Geometry.prototype.mergeVertices = function () {
            if (!this._buffers[Trike.AttributeType.POSITION])
                return;
            var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
            var precision = Math.pow(10, precisionPoints);
            var verticesMap = {}, i, il, face, indices, k, j, jl, bl, b, u, q, ql, v, key = '', buffers = this._buffers, unique = [], changes = [], faces = this.faces, faceIndicesToRemove = [], positionBuffer = this._buffers[Trike.AttributeType.POSITION];
            for (i = 0, il = positionBuffer.data.length; i < il; i++) {
                v = positionBuffer.data[i];
                key = Math.round(v.x * precision).toString() + '_' + Math.round(v.y * precision).toString() + '_' + Math.round(v.z * precision).toString();
                // IF the vertex already exists then use that one otherwise create a new entry.
                if (verticesMap[key] === undefined) {
                    verticesMap[key] = i;
                    unique.push(positionBuffer.data[i]);
                    changes[i] = unique.length - 1;
                }
                else
                    changes[i] = changes[verticesMap[key]];
            }
            // if faces are completely degenerate after merging vertices, we
            // have to remove them from the geometry.
            for (i = 0, il = faces.length; i < il; i++) {
                face = this.faces[i];
                face.a = changes[face.a];
                face.b = changes[face.b];
                face.c = changes[face.c];
                indices = [face.a, face.b, face.c];
                // update the face position's index buffer
                face.attributeIndices[Trike.AttributeType.POSITION].splice(0, 3, face.a, face.b, face.c);
                var dupIndex = -1;
                // if any duplicate vertices are found in a Face3
                // we have to remove the face as nothing can be saved
                for (var n = 0; n < 3; n++) {
                    if (indices[n] === indices[(n + 1) % 3]) {
                        dupIndex = n;
                        faceIndicesToRemove.push(i);
                        break;
                    }
                }
            }
            for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
                var idx = faceIndicesToRemove[i];
                faces.splice(idx, 1);
            }
            // Get the difference in vertices - i.e. how much have we removed.
            var diff = positionBuffer.data.length - unique.length;
            // Remove unnecessary data
            positionBuffer.data = unique;
            this._requiresBuild = true;
            // positionBuffer.data = unique;
            return diff;
        };
        /**
        * Computes the centroid of the faces. This is essentially the mid-point of the face.
        */
        Geometry.prototype.computeCentroids = function () {
            var vertices = this._buffers[Trike.AttributeType.POSITION].data;
            var faces = this.faces;
            var f, fl, face;
            for (f = 0, fl = faces.length; f < fl; f++) {
                face = faces[f];
                face.centroid.set(0, 0, 0);
                face.centroid.addVectors(face.centroid, vertices[face.a]);
                face.centroid.addVectors(face.centroid, vertices[face.b]);
                face.centroid.addVectors(face.centroid, vertices[face.c]);
                face.centroid.divideScalar(3);
            }
        };
        /**
        * Cleans up the object.
        */
        Geometry.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            // Calls destroyBuffers later
            Trike.Renderer.resoucesToRemove.push(this);
            this.faces = null;
            this.boundingSphere = null;
            this.boundingBox = null;
            this.bones = null;
            this._dataMap = null;
        };
        /**
        * Cleans up the references and frees the memory buffers
        */
        Geometry.prototype.destroyBuffers = function (gl) {
            var buffers = this._buffers;
            var cleanup = this._cleanup;
            // If a webgl buffer exists, delete it as we are creating new data.
            var i = buffers.length;
            while (i--) {
                if (!buffers[i])
                    continue;
                if (buffers[i].buffer)
                    gl.deleteBuffer(buffers[i].buffer);
            }
            i = cleanup.length;
            while (i--)
                if (cleanup[i])
                    gl.deleteBuffer(cleanup[i]);
            if (this._indexBuffer && this._indexBuffer.buffer)
                gl.deleteBuffer(this._indexBuffer.buffer);
            if (this._indexBufferLines && this._indexBufferLines.buffer)
                gl.deleteBuffer(this._indexBufferLines.buffer);
            this._buffers = null;
            this._indexBuffer = null;
            this._cleanup = null;
            this._indexBufferLines = null;
        };
        Object.defineProperty(Geometry.prototype, "buffers", {
            // Getters and Setters
            get: function () { return this._buffers; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Geometry.prototype, "requiresBuild", {
            get: function () { return this._requiresBuild; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Geometry.prototype, "numElements", {
            get: function () { return this._numElements; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Geometry.prototype, "indexBuffer", {
            get: function () { return (this._indexBuffer ? this._indexBuffer : null); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Geometry.prototype, "indexBufferLines", {
            get: function () { return (this._indexBufferLines ? this._indexBufferLines : null); },
            enumerable: true,
            configurable: true
        });
        return Geometry;
    }(Trike.EventDispatcher));
    Trike.Geometry = Geometry;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Use this class to create cube geometry
    */
    var GeometryLine = (function (_super) {
        __extends(GeometryLine, _super);
        function GeometryLine(points, dashes, mode) {
            if (dashes === void 0) { dashes = false; }
            if (mode === void 0) { mode = Trike.LineMode.HeadToTail; }
            _super.call(this);
            this.build(points, dashes);
            this.dashes = dashes;
            this.lineMode = mode;
        }
        /**
        * Builds the geometry of the cube. This will cause the geometry to be rebuilt, so use it sparingly.
        */
        GeometryLine.prototype.build = function (points, dashes) {
            if (dashes === void 0) { dashes = false; }
            // Add the buffers
            this.addAttributes(new Trike.GeometryBuffer([], 3, Trike.AttributeType.POSITION));
            if (dashes)
                this.addAttributes(new Trike.GeometryBuffer([], 1, Trike.AttributeType.CUSTOM_1));
            else
                this.removeAttribute(Trike.AttributeType.CUSTOM_1);
            // Fill the vertex / position buffer
            var vertexArray = this.buffers[Trike.AttributeType.POSITION].data;
            for (var i = 0, len = points.length; i < len; i++)
                vertexArray.push(points[i]);
            // If we are using dashes - we need to store the distance of each vert to its neighbour
            if (dashes) {
                var tempVec = new Trike.Vec3();
                var distanceArray = this.buffers[Trike.AttributeType.CUSTOM_1].data;
                if (this.lineMode === Trike.LineMode.HeadToTail || this.lineMode === Trike.LineMode.HeadToTailClosed) {
                    distanceArray.push(0); // the length so far starts at 0
                    for (var ii = 1; ii < vertexArray.length; ++ii)
                        distanceArray.push(distanceArray[ii - 1] + tempVec.subVectors(vertexArray[ii - 1], vertexArray[ii]).length());
                }
                else {
                    for (var ii = 0; ii < vertexArray.length; ii += 2) {
                        distanceArray.push(0);
                        if (ii + 1 < vertexArray.length)
                            distanceArray.push(tempVec.subVectors(vertexArray[ii], vertexArray[ii + 1]).length());
                    }
                }
            }
            this.computeBoundingBox();
            this.computeBoundingSphere();
        };
        return GeometryLine;
    }(Trike.Geometry));
    Trike.GeometryLine = GeometryLine;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Geometry representing a cube
    */
    var GeometryCube = (function (_super) {
        __extends(GeometryCube, _super);
        /**
        * Creates an instance
        * @param {number} width The width of this geometry
        * @param {number} height The height of this geometry
        * @param {number} depth The depth of this geometry
        * @param {number} widthSegments The widthSegments of this geometry
        * @param {number} heightSegments The heightSegments of this geometry
        * @param {number} depthSegments The depthSegments of this geometry
        */
        function GeometryCube(width, height, depth, widthSegments, heightSegments, depthSegments) {
            if (width === void 0) { width = 1; }
            if (height === void 0) { height = 1; }
            if (depth === void 0) { depth = 1; }
            if (widthSegments === void 0) { widthSegments = 1; }
            if (heightSegments === void 0) { heightSegments = 1; }
            if (depthSegments === void 0) { depthSegments = 1; }
            _super.call(this);
            this._width = width;
            this._height = height;
            this._depth = depth;
            this._widthSegments = widthSegments;
            this._heightSegments = heightSegments;
            this._depthSegments = depthSegments;
            this.build();
        }
        /**
        * Gets or sets the width of this cube. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryCube.prototype.width = function (val) {
            if (val === undefined)
                return this._width;
            if (val === 0)
                val = 0.0001;
            this._width = val;
            this.build();
        };
        /**
        * Gets or sets the height of this cube. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryCube.prototype.height = function (val) {
            if (val === undefined)
                return this._height;
            if (val === 0)
                val = 0.0001;
            this._height = val;
            this.build();
        };
        /**
        * Gets or sets the depth of this cube. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryCube.prototype.depth = function (val) {
            if (val === undefined)
                return this._depth;
            if (val === 0)
                val = 0.0001;
            this._depth = val;
            this.build();
        };
        /**
        * Gets or sets the number of width segments of this cube. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryCube.prototype.widthSegments = function (val) {
            if (val === undefined)
                return this._widthSegments;
            if (val < 1)
                val = 1;
            this._widthSegments = val;
            this.build();
        };
        /**
        * Gets or sets the number of height segments of this cube. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryCube.prototype.heightSegments = function (val) {
            if (val === undefined)
                return this._heightSegments;
            if (val < 1)
                val = 1;
            this._heightSegments = val;
            this.build();
        };
        /**
        * Gets or sets the number of depth segments of this cube. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryCube.prototype.depthSegments = function (val) {
            if (val === undefined)
                return this._depthSegments;
            if (val < 1)
                val = 1;
            this._depthSegments = val;
            this.build();
        };
        /**
        * Builds the geometry of the cube. This will cause the geometry to be rebuilt, so use it sparingly.
        */
        GeometryCube.prototype.build = function () {
            var width = this._width;
            var height = this._height;
            var depth = this._depth;
            var widthSegments = this._widthSegments;
            var heightSegments = this._heightSegments;
            var depthSegments = this._depthSegments;
            var width_half = width / 2;
            var height_half = height / 2;
            var depth_half = depth / 2;
            var tempVerts = [];
            // Add the buffers
            this.addAttributes(new Trike.GeometryBuffer([], 3, Trike.AttributeType.POSITION));
            this.addAttributes(new Trike.GeometryBuffer([], 2, Trike.AttributeType.UV));
            this.faces.splice(0, this.faces.length);
            // First we build the vertices and indices
            this.buildPlane('z', 'y', -1, -1, depth, height, width_half, 0, widthSegments, heightSegments, depthSegments); // px
            this.buildPlane('z', 'y', 1, -1, depth, height, -width_half, 1, widthSegments, heightSegments, depthSegments); // nx
            this.buildPlane('x', 'z', 1, 1, width, depth, height_half, 2, widthSegments, heightSegments, depthSegments); // py
            this.buildPlane('x', 'z', 1, -1, width, depth, -height_half, 3, widthSegments, heightSegments, depthSegments); // ny
            this.buildPlane('x', 'y', 1, -1, width, height, depth_half, 4, widthSegments, heightSegments, depthSegments); // pz
            this.buildPlane('x', 'y', -1, -1, width, height, -depth_half, 5, widthSegments, heightSegments, depthSegments); // nz
            this.generateNormals();
            this.computeCentroids();
            this.mergeVertices();
            this.computeBoundingBox();
            this.computeBoundingSphere();
        };
        /**
        * Builds one of the cube planes
        */
        GeometryCube.prototype.buildPlane = function (u, v, udir, vdir, width, height, depth, materialIndex, widthSegments, heightSegments, depthSegments) {
            var w, ix, iy, gridX = widthSegments, gridY = heightSegments;
            var buffers = this.buffers, width_half = width / 2, height_half = height / 2, offset = buffers[Trike.AttributeType.POSITION].data.length;
            if ((u === 'x' && v === 'y') || (u === 'y' && v === 'x')) {
                w = 'z';
            }
            else if ((u === 'x' && v === 'z') || (u === 'z' && v === 'x')) {
                w = 'y';
                gridY = depthSegments;
            }
            else if ((u === 'z' && v === 'y') || (u === 'y' && v === 'z')) {
                w = 'x';
                gridX = depthSegments;
            }
            var gridX1 = gridX + 1, gridY1 = gridY + 1, segment_width = width / gridX, segment_height = height / gridY, normal = new Trike.Vec3(0, 0, 0);
            normal[w] = depth > 0 ? 1 : -1;
            for (iy = 0; iy < gridY1; iy++) {
                for (ix = 0; ix < gridX1; ix++) {
                    var vector = new Trike.Vec3(0, 0, 0);
                    vector[u] = (ix * segment_width - width_half) * udir;
                    vector[v] = (iy * segment_height - height_half) * vdir;
                    vector[w] = depth;
                    // Add the vertex data to the geometry
                    buffers[Trike.AttributeType.POSITION].data.push(vector);
                }
            }
            for (iy = 0; iy < gridY; iy++) {
                for (ix = 0; ix < gridX; ix++) {
                    // Get the current UV index
                    var uvIndex = buffers[Trike.AttributeType.UV].data.length;
                    var a = ix + gridX1 * iy;
                    var b = ix + gridX1 * (iy + 1);
                    var c = (ix + 1) + gridX1 * (iy + 1);
                    var d = (ix + 1) + gridX1 * iy;
                    var uva = new Trike.Vec2(ix / gridX, 1 - iy / gridY);
                    var uvb = new Trike.Vec2(ix / gridX, 1 - (iy + 1) / gridY);
                    var uvc = new Trike.Vec2((ix + 1) / gridX, 1 - (iy + 1) / gridY);
                    var uvd = new Trike.Vec2((ix + 1) / gridX, 1 - iy / gridY);
                    // Add some UV data to the geometry's UV buffer
                    buffers[Trike.AttributeType.UV].data.push(uva, uvb, uvd, uvb, uvc, uvd);
                    // Add the first face3
                    var face = new Trike.Face3(a + offset, b + offset, d + offset);
                    face.normal.copy(normal);
                    face.vertexNormals[0] = normal.clone();
                    face.vertexNormals[1] = normal.clone();
                    face.vertexNormals[2] = normal.clone();
                    face.materialIndex = materialIndex;
                    this.faces.push(face);
                    // Set the face indices
                    face.setAttributeIndices(Trike.AttributeType.UV, uvIndex, uvIndex + 1, uvIndex + 2);
                    // Add the second face3
                    face = new Trike.Face3(b + offset, c + offset, d + offset);
                    face.normal.copy(normal);
                    face.vertexNormals[0] = normal.clone();
                    face.vertexNormals[1] = normal.clone();
                    face.vertexNormals[2] = normal.clone();
                    face.materialIndex = materialIndex;
                    this.faces.push(face);
                    // Set the face indices
                    face.setAttributeIndices(Trike.AttributeType.UV, uvIndex + 3, uvIndex + 4, uvIndex + 5);
                }
            }
        };
        return GeometryCube;
    }(Trike.Geometry));
    Trike.GeometryCube = GeometryCube;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Use this class to create cube geometry
    */
    var GeometrySphere = (function (_super) {
        __extends(GeometrySphere, _super);
        function GeometrySphere(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
            if (radius === void 0) { radius = 1; }
            if (widthSegments === void 0) { widthSegments = 8; }
            if (heightSegments === void 0) { heightSegments = 6; }
            if (phiStart === void 0) { phiStart = 0; }
            if (phiLength === void 0) { phiLength = Math.PI * 2; }
            if (thetaStart === void 0) { thetaStart = 0; }
            if (thetaLength === void 0) { thetaLength = Math.PI; }
            _super.call(this);
            this._phiStart = phiStart;
            this._phiLength = phiLength;
            this._thetaStart = thetaStart;
            this._thetaLength = thetaLength;
            this._radius = radius;
            this._widthSegments = widthSegments;
            this._heightSegments = heightSegments;
            this.build();
        }
        /**
        * Gets or sets the theta start of this sphere. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometrySphere.prototype.thetaStart = function (val) {
            if (val === undefined)
                return this._thetaStart;
            if (val === 0)
                val = 0.0001;
            this._thetaStart = val;
            this.build();
        };
        /**
        * Gets or sets the theta length of this sphere. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometrySphere.prototype.thetaLength = function (val) {
            if (val === undefined)
                return this._thetaLength;
            if (val === 0)
                val = 0.0001;
            this._thetaLength = val;
            this.build();
        };
        /**
        * Gets or sets the phi start of this sphere. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometrySphere.prototype.phiStart = function (val) {
            if (val === undefined)
                return this._phiStart;
            if (val === 0)
                val = 0.0001;
            this._phiStart = val;
            this.build();
        };
        /**
        * Gets or sets the phi length of this sphere. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometrySphere.prototype.phiLength = function (val) {
            if (val === undefined)
                return this._phiLength;
            if (val === 0)
                val = 0.0001;
            this._phiLength = val;
            this.build();
        };
        /**
        * Gets or sets the radius of this sphere. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometrySphere.prototype.radius = function (val) {
            if (val === undefined)
                return this._radius;
            if (val === 0)
                val = 0.0001;
            this._radius = val;
            this.build();
        };
        /**
        * Gets or sets the number of width segments of this sphere. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometrySphere.prototype.widthSegments = function (val) {
            if (val === undefined)
                return this._widthSegments;
            if (val < 1)
                val = 1;
            this._widthSegments = val;
            this.build();
        };
        /**
        * Gets or sets the number of height segments of this sphere. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometrySphere.prototype.heightSegments = function (val) {
            if (val === undefined)
                return this._heightSegments;
            if (val < 1)
                val = 1;
            this._heightSegments = val;
            this.build();
        };
        /**
        * Builds the geometry of the sphere. This will cause the geometry to be rebuilt, so use it sparingly.
        */
        GeometrySphere.prototype.build = function () {
            var phiStart = this._phiStart;
            var phiLength = this._phiLength;
            var thetaStart = this._thetaStart;
            var thetaLength = this._thetaLength;
            var radius = this._radius;
            var widthSegments = this._widthSegments;
            var heightSegments = this._heightSegments;
            var x, y;
            var vertices = [], uvs = [], buffers = this.buffers;
            // Cleanup any existing faces
            this.faces.splice(0, this.faces.length);
            this.addAttributes(new Trike.GeometryBuffer([], 3, Trike.AttributeType.POSITION));
            this.addAttributes(new Trike.GeometryBuffer([], 3, Trike.AttributeType.NORMAL));
            this.addAttributes(new Trike.GeometryBuffer([], 2, Trike.AttributeType.UV));
            var vertexData = buffers[Trike.AttributeType.POSITION].data;
            var normData = buffers[Trike.AttributeType.NORMAL].data;
            var uvData = buffers[Trike.AttributeType.UV].data;
            for (y = 0; y <= heightSegments; y++) {
                var verticesRow = [];
                var uvsRow = [];
                for (x = 0; x <= widthSegments; x++) {
                    var u = x / widthSegments;
                    var v = y / heightSegments;
                    var vertex = new Trike.Vec3(0, 0, 0);
                    vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                    vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
                    vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                    vertexData.push(vertex);
                    verticesRow.push(vertexData.length - 1);
                    uvsRow.push(new Trike.Vec2(u, 1 - v));
                }
                vertices.push(verticesRow);
                uvs.push(uvsRow);
            }
            for (y = 0; y < heightSegments; y++) {
                for (x = 0; x < widthSegments; x++) {
                    var v1 = vertices[y][x + 1];
                    var v2 = vertices[y][x];
                    var v3 = vertices[y + 1][x];
                    var v4 = vertices[y + 1][x + 1];
                    var n1 = vertexData[v1].clone();
                    var n2 = vertexData[v2].clone();
                    var n3 = vertexData[v3].clone();
                    var n4 = vertexData[v4].clone();
                    n1.normalize();
                    n2.normalize();
                    n3.normalize();
                    n4.normalize();
                    var uv1 = uvs[y][x + 1].clone();
                    var uv2 = uvs[y][x].clone();
                    var uv3 = uvs[y + 1][x].clone();
                    var uv4 = uvs[y + 1][x + 1].clone();
                    if (Math.abs(vertexData[v1][1]) === radius) {
                        var face = new Trike.Face3(v1, v3, v4);
                        this.faces.push(face);
                        normData.push(n1, n3, n4);
                        uvData.push(uv1, uv3, uv4);
                        face.attributeIndices[Trike.AttributeType.POSITION] = [v1, v3, v4];
                        face.attributeIndices[Trike.AttributeType.NORMAL] = [normData.length - 3, normData.length - 2, normData.length - 1];
                        face.attributeIndices[Trike.AttributeType.UV] = [uvData.length - 3, uvData.length - 2, uvData.length - 1];
                    }
                    else if (Math.abs(vertexData[v3][1]) === radius) {
                        var face = new Trike.Face3(v1, v2, v3);
                        this.faces.push(face);
                        normData.push(n1, n2, n3);
                        uvData.push(uv1, uv2, uv3);
                        face.attributeIndices[Trike.AttributeType.POSITION] = [v1, v2, v3];
                        face.attributeIndices[Trike.AttributeType.NORMAL] = [normData.length - 3, normData.length - 2, normData.length - 1];
                        face.attributeIndices[Trike.AttributeType.UV] = [uvData.length - 3, uvData.length - 2, uvData.length - 1];
                    }
                    else {
                        var face = new Trike.Face3(v1, v2, v4);
                        this.faces.push(face);
                        normData.push(n1, n2, n4);
                        uvData.push(uv1, uv2, uv4);
                        face.attributeIndices[Trike.AttributeType.POSITION] = [v1, v2, v4];
                        face.attributeIndices[Trike.AttributeType.NORMAL] = [normData.length - 3, normData.length - 2, normData.length - 1];
                        face.attributeIndices[Trike.AttributeType.UV] = [uvData.length - 3, uvData.length - 2, uvData.length - 1];
                        face = new Trike.Face3(v2, v3, v4);
                        this.faces.push(face);
                        normData.push(n2, n3, n4);
                        uvData.push(uv2.clone(), uv3, uv4.clone());
                        face.attributeIndices[Trike.AttributeType.POSITION] = [v2, v3, v4];
                        face.attributeIndices[Trike.AttributeType.NORMAL] = [normData.length - 3, normData.length - 2, normData.length - 1];
                        face.attributeIndices[Trike.AttributeType.UV] = [uvData.length - 3, uvData.length - 2, uvData.length - 1];
                    }
                }
            }
            this.computeCentroids();
            this.computeFaceNormals();
            this.computeBoundingBox();
            this.computeBoundingSphere();
        };
        return GeometrySphere;
    }(Trike.Geometry));
    Trike.GeometrySphere = GeometrySphere;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Geometry representing a plane
    */
    var GeometryPlane = (function (_super) {
        __extends(GeometryPlane, _super);
        /**
        * Creates an instance
        * @param {number} width The width of this geometry
        * @param {number} height The height of this geometry
        * @param {number} widthSegments The widthSegments of this geometry
        * @param {number} heightSegments The heightSegments of this geometry
        */
        function GeometryPlane(width, height, widthSegments, heightSegments) {
            if (width === void 0) { width = 1; }
            if (height === void 0) { height = 1; }
            if (widthSegments === void 0) { widthSegments = 1; }
            if (heightSegments === void 0) { heightSegments = 1; }
            _super.call(this);
            this._width = width;
            this._height = height;
            this._widthSegments = widthSegments;
            this._heightSegments = heightSegments;
            this.build();
        }
        /**
        * Gets or sets the width of this cube. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryPlane.prototype.width = function (val) {
            if (val === undefined)
                return this._width;
            if (val === 0)
                val = 0.0001;
            this._width = val;
            this.build();
        };
        /**
        * Gets or sets the height of this cube. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryPlane.prototype.height = function (val) {
            if (val === undefined)
                return this._height;
            if (val === 0)
                val = 0.0001;
            this._height = val;
            this.build();
        };
        /**
        * Gets or sets the number of width segments of this cube. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryPlane.prototype.widthSegments = function (val) {
            if (val === undefined)
                return this._widthSegments;
            if (val < 1)
                val = 1;
            this._widthSegments = val;
            this.build();
        };
        /**
        * Gets or sets the number of height segments of this cube. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryPlane.prototype.heightSegments = function (val) {
            if (val === undefined)
                return this._heightSegments;
            if (val < 1)
                val = 1;
            this._heightSegments = val;
            this.build();
        };
        /**
        * Builds the geometry of the plane. This will cause the geometry to be rebuilt, so use it sparingly.
        */
        GeometryPlane.prototype.build = function () {
            var width = this._width;
            var height = this._height;
            var widthSegments = this._widthSegments;
            var heightSegments = this._heightSegments;
            this.addAttributes(new Trike.GeometryBuffer([], 3, Trike.AttributeType.POSITION));
            this.addAttributes(new Trike.GeometryBuffer([], 3, Trike.AttributeType.NORMAL));
            this.addAttributes(new Trike.GeometryBuffer([], 2, Trike.AttributeType.UV));
            this.faces.splice(0, this.faces.length);
            var vertexData = this.buffers[Trike.AttributeType.POSITION].data;
            var normData = this.buffers[Trike.AttributeType.NORMAL].data;
            var uvData = this.buffers[Trike.AttributeType.UV].data;
            var ix, iz;
            var width_half = width / 2;
            var height_half = height / 2;
            var gridX = widthSegments;
            var gridZ = heightSegments;
            var gridX1 = gridX + 1;
            var gridZ1 = gridZ + 1;
            var segment_width = width / gridX;
            var segment_height = height / gridZ;
            var normal = new Trike.Vec3(0, 0, 1);
            for (iz = 0; iz < gridZ1; iz++) {
                for (ix = 0; ix < gridX1; ix++) {
                    var x = ix * segment_width - width_half;
                    var y = iz * segment_height - height_half;
                    vertexData.push(new Trike.Vec3(x, -y, 0));
                }
            }
            for (iz = 0; iz < gridZ; iz++) {
                for (ix = 0; ix < gridX; ix++) {
                    var a = ix + gridX1 * iz;
                    var b = ix + gridX1 * (iz + 1);
                    var c = (ix + 1) + gridX1 * (iz + 1);
                    var d = (ix + 1) + gridX1 * iz;
                    var uva = new Trike.Vec2(ix / gridX, 1 - iz / gridZ);
                    var uvb = new Trike.Vec2(ix / gridX, 1 - (iz + 1) / gridZ);
                    var uvc = new Trike.Vec2((ix + 1) / gridX, 1 - (iz + 1) / gridZ);
                    var uvd = new Trike.Vec2((ix + 1) / gridX, 1 - iz / gridZ);
                    var face = new Trike.Face3(a, b, d);
                    face.normal.copy(normal);
                    this.faces.push(face);
                    normData.push(normal.clone(), normal.clone(), normal.clone());
                    uvData.push(uva, uvb, uvd);
                    face.attributeIndices[Trike.AttributeType.POSITION] = [a, b, d];
                    face.attributeIndices[Trike.AttributeType.NORMAL] = [normData.length - 3, normData.length - 2, normData.length - 1];
                    face.attributeIndices[Trike.AttributeType.UV] = [uvData.length - 3, uvData.length - 2, uvData.length - 1];
                    face = new Trike.Face3(b, c, d);
                    face.normal.copy(normal);
                    this.faces.push(face);
                    normData.push(normal.clone(), normal.clone(), normal.clone());
                    uvData.push(uvb.clone(), uvc, uvd.clone());
                    face.attributeIndices[Trike.AttributeType.POSITION] = [b, c, d];
                    face.attributeIndices[Trike.AttributeType.NORMAL] = [normData.length - 3, normData.length - 2, normData.length - 1];
                    face.attributeIndices[Trike.AttributeType.UV] = [uvData.length - 3, uvData.length - 2, uvData.length - 1];
                }
            }
            this.computeCentroids();
            this.computeBoundingBox();
            this.computeBoundingSphere();
        };
        return GeometryPlane;
    }(Trike.Geometry));
    Trike.GeometryPlane = GeometryPlane;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Use this class to create planar geometry used in screen quads.
    * This adds the indices of the far corners of the camera frustum (The actual verts are
    * passed as 4 component vec3 array as a uniform)
    */
    var GeometryScreenPlane = (function (_super) {
        __extends(GeometryScreenPlane, _super);
        function GeometryScreenPlane() {
            _super.call(this, 2, 2, 1, 1);
        }
        /**
        * Builds the geometry of the plane. This will cause the geometry to be rebuilt, so use it sparingly.
        */
        GeometryScreenPlane.prototype.build = function () {
            _super.prototype.build.call(this);
            // Add screen indices
            this.addAttributes(new Trike.GeometryBuffer([0, 1, 2, 3], 1, Trike.AttributeType.SCREEN_CORNER_INDEX));
            this.faces[0].attributeIndices[Trike.AttributeType.SCREEN_CORNER_INDEX] = [0, 2, 1];
            this.faces[1].attributeIndices[Trike.AttributeType.SCREEN_CORNER_INDEX] = [2, 3, 1];
            // Add surface data (which basically represent screen ratios)
            this.addAttributes(new Trike.GeometryBuffer([
                new Trike.Vec2(-0.5, 0.5),
                new Trike.Vec2(0.5, 0.5),
                new Trike.Vec2(-0.5, -0.5),
                new Trike.Vec2(0.5, -0.5)], 2, Trike.AttributeType.SURFACE));
            this.faces[0].attributeIndices[Trike.AttributeType.SURFACE] = [0, 2, 1];
            this.faces[1].attributeIndices[Trike.AttributeType.SURFACE] = [2, 3, 1];
            this.computeBoundingBox();
            this.computeBoundingSphere();
        };
        return GeometryScreenPlane;
    }(Trike.GeometryPlane));
    Trike.GeometryScreenPlane = GeometryScreenPlane;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Use this class to create cylinder geometry
    */
    var GeometryCylinder = (function (_super) {
        __extends(GeometryCylinder, _super);
        function GeometryCylinder(radiusTop, radiusBottom, height, radialSegments, heightSegments, thetaStart, thetaLength, openEnded) {
            if (radiusTop === void 0) { radiusTop = 1; }
            if (radiusBottom === void 0) { radiusBottom = 1; }
            if (height === void 0) { height = 10; }
            if (radialSegments === void 0) { radialSegments = 8; }
            if (heightSegments === void 0) { heightSegments = 1; }
            if (thetaStart === void 0) { thetaStart = 0; }
            if (thetaLength === void 0) { thetaLength = Math.PI * 2; }
            if (openEnded === void 0) { openEnded = false; }
            _super.call(this);
            this._radiusTop = radiusTop;
            this._radiusBottom = radiusBottom;
            this._height = height;
            this._radialSegments = radialSegments;
            this._heightSegments = heightSegments;
            this._openEnded = openEnded;
            this._thetaStart = thetaStart;
            this._thetaLength = thetaLength;
            this.build();
        }
        /**
        * Gets or sets the theta length value of this cylinder. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryCylinder.prototype.thetaLength = function (val) {
            if (val === undefined)
                return this._thetaLength;
            this._thetaLength = val;
            this.build();
        };
        /**
        * Gets or sets the start theta value of this cylinder. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryCylinder.prototype.thetaStart = function (val) {
            if (val === undefined)
                return this._thetaStart;
            this._thetaStart = val;
            this.build();
        };
        /**
        * Gets or sets if this cylinder is open ended or not. The causes the geometry to be re-built so
        * use it sparingly
        * @param {boolean} val [Optional]
        * @returns {boolean}
        */
        GeometryCylinder.prototype.openEnded = function (val) {
            if (val === undefined)
                return this._openEnded;
            this._openEnded = val;
            this.build();
        };
        /**
        * Gets or sets the number of height segments of this cylinder. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryCylinder.prototype.heightSegments = function (val) {
            if (val === undefined)
                return this._heightSegments;
            if (val < 1)
                val = 1;
            this._heightSegments = val;
            this.build();
        };
        /**
        * Gets or sets the number of radial segments of this cylinder. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryCylinder.prototype.radialSegments = function (val) {
            if (val === undefined)
                return this._radialSegments;
            if (val < 1)
                val = 1;
            this._radialSegments = val;
            this.build();
        };
        /**
        * Gets or sets the height of this cylinder. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryCylinder.prototype.height = function (val) {
            if (val === undefined)
                return this._height;
            if (val === 0)
                val = 0.0001;
            this._height = val;
            this.build();
        };
        /**
        * Gets or sets the bottom radius of this cylinder. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryCylinder.prototype.radiusBottom = function (val) {
            if (val === undefined)
                return this._radiusBottom;
            if (val === 0)
                val = 0.0001;
            this._radiusBottom = val;
            this.build();
        };
        /**
        * Gets or sets the top radius of this cylinder. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryCylinder.prototype.radiusTop = function (val) {
            if (val === undefined)
                return this._radiusTop;
            if (val === 0)
                val = 0.0001;
            this._radiusTop = val;
            this.build();
        };
        /**
        * Builds the geometry of the cube. This will cause the geometry to be rebuilt, so use it sparingly.
        */
        GeometryCylinder.prototype.build = function () {
            var radiusTop = this._radiusTop;
            var radiusBottom = this._radiusBottom;
            var height = this._height;
            var radialSegments = this._radialSegments;
            var heightSegments = this._heightSegments;
            var openEnded = this._openEnded;
            var thetaStart = this._thetaStart;
            var thetaLength = this._thetaLength;
            var buffers = this.buffers;
            // Add the buffers
            this.addAttributes(new Trike.GeometryBuffer([], 3, Trike.AttributeType.POSITION));
            this.addAttributes(new Trike.GeometryBuffer([], 2, Trike.AttributeType.UV));
            this.addAttributes(new Trike.GeometryBuffer([], 3, Trike.AttributeType.NORMAL));
            this.faces.splice(0, this.faces.length);
            var heightHalf = height / 2;
            var x, y;
            var vertices = [], uvs = [];
            for (y = 0; y <= heightSegments; y++) {
                var verticesRow = [];
                var uvsRow = [];
                var v = y / heightSegments;
                var radius = v * (radiusBottom - radiusTop) + radiusTop;
                for (x = 0; x <= radialSegments; x++) {
                    var u = x / radialSegments;
                    var vertex = new Trike.Vec3();
                    vertex.x = radius * Math.sin(u * thetaLength + thetaStart);
                    vertex.y = -v * height + heightHalf;
                    vertex.z = radius * Math.cos(u * thetaLength + thetaStart);
                    buffers[Trike.AttributeType.POSITION].data.push(vertex);
                    verticesRow.push(buffers[Trike.AttributeType.POSITION].data.length - 1);
                    uvsRow.push(new Trike.Vec2(u, 1 - v));
                }
                vertices.push(verticesRow);
                uvs.push(uvsRow);
            }
            var tanTheta = (radiusBottom - radiusTop) / height;
            var na, nb;
            for (x = 0; x < radialSegments; x++) {
                if (radiusTop !== 0) {
                    na = buffers[Trike.AttributeType.POSITION].data[vertices[0][x]].clone();
                    nb = buffers[Trike.AttributeType.POSITION].data[vertices[0][x + 1]].clone();
                }
                else {
                    na = buffers[Trike.AttributeType.POSITION].data[vertices[1][x]].clone();
                    nb = buffers[Trike.AttributeType.POSITION].data[vertices[1][x + 1]].clone();
                }
                na.setY(Math.sqrt(na.x * na.x + na.z * na.z) * tanTheta).normalize();
                nb.setY(Math.sqrt(nb.x * nb.x + nb.z * nb.z) * tanTheta).normalize();
                for (y = 0; y < heightSegments; y++) {
                    // Get the current UV index
                    var uvIndex = buffers[Trike.AttributeType.UV].data.length;
                    var normalIndex = buffers[Trike.AttributeType.NORMAL].data.length;
                    var v1 = vertices[y][x];
                    var v2 = vertices[y + 1][x];
                    var v3 = vertices[y + 1][x + 1];
                    var v4 = vertices[y][x + 1];
                    var n1 = na.clone();
                    var n2 = na.clone();
                    var n3 = nb.clone();
                    var n4 = nb.clone();
                    var uv1 = uvs[y][x].clone();
                    var uv2 = uvs[y + 1][x].clone();
                    var uv3 = uvs[y + 1][x + 1].clone();
                    var uv4 = uvs[y][x + 1].clone();
                    // Add the faces
                    var face = new Trike.Face3(v1, v2, v4);
                    buffers[Trike.AttributeType.NORMAL].data.push(n1, n2, n4);
                    face.vertexNormals[0] = n1;
                    face.vertexNormals[1] = n2;
                    face.vertexNormals[2] = n4;
                    this.faces.push(face);
                    // Add some UV data to the geometry's UV buffer
                    buffers[Trike.AttributeType.UV].data.push(uv1, uv2, uv4);
                    // Set the face indices
                    face.setAttributeIndices(Trike.AttributeType.NORMAL, normalIndex, normalIndex + 1, normalIndex + 2);
                    face.setAttributeIndices(Trike.AttributeType.UV, uvIndex, uvIndex + 1, uvIndex + 2);
                    face = new Trike.Face3(v2, v3, v4);
                    buffers[Trike.AttributeType.NORMAL].data.push(n2.clone(), n3, n4.clone());
                    face.vertexNormals[0] = n2.clone();
                    face.vertexNormals[1] = n3;
                    face.vertexNormals[2] = n4.clone();
                    this.faces.push(face);
                    // Add some UV data to the geometry's UV buffer
                    buffers[Trike.AttributeType.UV].data.push(uv2.clone(), uv3, uv4.clone());
                    // Set the face indices
                    face.setAttributeIndices(Trike.AttributeType.NORMAL, normalIndex + 3, normalIndex + 4, normalIndex + 5);
                    face.setAttributeIndices(Trike.AttributeType.UV, uvIndex + 3, uvIndex + 4, uvIndex + 5);
                }
            }
            // top cap
            if (openEnded === false && radiusTop > 0) {
                buffers[Trike.AttributeType.POSITION].data.push(new Trike.Vec3(0, heightHalf, 0));
                for (x = 0; x < radialSegments; x++) {
                    // Get the current UV index
                    var uvIndex = buffers[Trike.AttributeType.UV].data.length;
                    var normalIndex = buffers[Trike.AttributeType.NORMAL].data.length;
                    var v1 = vertices[0][x];
                    var v2 = vertices[0][x + 1];
                    var v3 = buffers[Trike.AttributeType.POSITION].data.length - 1;
                    var n1 = new Trike.Vec3(0, 1, 0);
                    var n2 = new Trike.Vec3(0, 1, 0);
                    var n3 = new Trike.Vec3(0, 1, 0);
                    var uv1 = uvs[0][x].clone();
                    var uv2 = uvs[0][x + 1].clone();
                    var uv3 = new Trike.Vec2(uv2.x, 0);
                    // Add the face
                    var face = new Trike.Face3(v1, v2, v3);
                    buffers[Trike.AttributeType.NORMAL].data.push(n1, n2, n3);
                    face.vertexNormals[0] = n1;
                    face.vertexNormals[1] = n2;
                    face.vertexNormals[2] = n3;
                    this.faces.push(face);
                    // Add some UV data to the geometry's UV buffer
                    buffers[Trike.AttributeType.UV].data.push(uv1, uv2, uv3);
                    // Set the face indices
                    // face.setAttributeIndices( AttributeType.POSITION, v1, v2, v3 );
                    face.setAttributeIndices(Trike.AttributeType.NORMAL, normalIndex, normalIndex + 1, normalIndex + 2);
                    face.setAttributeIndices(Trike.AttributeType.UV, uvIndex, uvIndex + 1, uvIndex + 2);
                }
            }
            // bottom cap
            if (openEnded === false && radiusBottom > 0) {
                buffers[Trike.AttributeType.POSITION].data.push(new Trike.Vec3(0, -heightHalf, 0));
                for (x = 0; x < radialSegments; x++) {
                    // Get the current UV index
                    var uvIndex = buffers[Trike.AttributeType.UV].data.length;
                    var normalIndex = buffers[Trike.AttributeType.NORMAL].data.length;
                    var v1 = vertices[y][x + 1];
                    var v2 = vertices[y][x];
                    var v3 = buffers[Trike.AttributeType.POSITION].data.length - 1;
                    var n1 = new Trike.Vec3(0, -1, 0);
                    var n2 = new Trike.Vec3(0, -1, 0);
                    var n3 = new Trike.Vec3(0, -1, 0);
                    var uv1 = uvs[y][x + 1].clone();
                    var uv2 = uvs[y][x].clone();
                    var uv3 = new Trike.Vec2(uv2.x, 1);
                    // Add the face
                    var face = new Trike.Face3(v1, v2, v3);
                    buffers[Trike.AttributeType.NORMAL].data.push(n1, n2, n3);
                    face.vertexNormals[0] = n1;
                    face.vertexNormals[1] = n2;
                    face.vertexNormals[2] = n3;
                    this.faces.push(face);
                    // Add some UV data to the geometry's UV buffer
                    buffers[Trike.AttributeType.UV].data.push(uv1, uv2, uv3);
                    // Set the face indices
                    // face.setAttributeIndices( AttributeType.POSITION, v1, v2, v3 );
                    face.setAttributeIndices(Trike.AttributeType.NORMAL, normalIndex, normalIndex + 1, normalIndex + 2);
                    face.setAttributeIndices(Trike.AttributeType.UV, uvIndex, uvIndex + 1, uvIndex + 2);
                }
            }
            this.computeCentroids();
            this.computeFaceNormals();
            this.computeBoundingBox();
            this.computeBoundingSphere();
        };
        return GeometryCylinder;
    }(Trike.Geometry));
    Trike.GeometryCylinder = GeometryCylinder;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Use this class to create a ring geometry
    */
    var GeometryRing = (function (_super) {
        __extends(GeometryRing, _super);
        function GeometryRing(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
            if (innerRadius === void 0) { innerRadius = 1; }
            if (outerRadius === void 0) { outerRadius = 2; }
            if (thetaSegments === void 0) { thetaSegments = 8; }
            if (phiSegments === void 0) { phiSegments = 8; }
            if (thetaStart === void 0) { thetaStart = 0; }
            if (thetaLength === void 0) { thetaLength = Math.PI * 2; }
            _super.call(this);
            this._innerRadius = innerRadius;
            this._outerRadius = outerRadius;
            this._thetaSegments = thetaSegments;
            this._phiSegments = phiSegments;
            this._thetaStart = thetaStart;
            this._thetaLength = thetaLength;
            this.build();
        }
        /**
        * Gets or sets the theta length value of this ring. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryRing.prototype.thetaLength = function (val) {
            if (val === undefined)
                return this._thetaLength;
            this._thetaLength = val;
            this.build();
        };
        /**
        * Gets or sets the start theta value of this ring. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryRing.prototype.thetaStart = function (val) {
            if (val === undefined)
                return this._thetaStart;
            this._thetaStart = val;
            this.build();
        };
        /**
        * Gets or sets the number of phi segments of this ring. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryRing.prototype.phiSegments = function (val) {
            if (val === undefined)
                return this._phiSegments;
            if (val < 1)
                val = 1;
            this._phiSegments = val;
            this.build();
        };
        /**
        * Gets or sets the number of theta segments of this ring. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryRing.prototype.thetaSegments = function (val) {
            if (val === undefined)
                return this._thetaSegments;
            if (val < 3)
                val = 3;
            this._thetaSegments = val;
            this.build();
        };
        /**
        * Gets or sets the outer radius of this ring. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryRing.prototype.outerRadius = function (val) {
            if (val === undefined)
                return this._outerRadius;
            if (val === 0)
                val = 0.0001;
            this._outerRadius = val;
            this.build();
        };
        /**
        * Gets or sets the inner radius of this ring. The causes the geometry to be re-built so
        * use it sparingly
        * @param {number} val [Optional]
        * @returns {number}
        */
        GeometryRing.prototype.innerRadius = function (val) {
            if (val === undefined)
                return this._innerRadius;
            if (val === 0)
                val = 0.0001;
            this._innerRadius = val;
            this.build();
        };
        /**
        * Builds the geometry of the cube. This will cause the geometry to be rebuilt, so use it sparingly.
        */
        GeometryRing.prototype.build = function () {
            var innerRadius = this._innerRadius;
            var outerRadius = this._outerRadius;
            var thetaSegments = this._thetaSegments;
            var phiSegments = this._phiSegments;
            var thetaStart = this._thetaStart;
            var thetaLength = this._thetaLength;
            var buffers = this.buffers;
            // Add the buffers
            this.addAttributes(new Trike.GeometryBuffer([], 3, Trike.AttributeType.POSITION));
            this.addAttributes(new Trike.GeometryBuffer([], 2, Trike.AttributeType.UV));
            this.addAttributes(new Trike.GeometryBuffer([], 3, Trike.AttributeType.NORMAL));
            this.faces.splice(0, this.faces.length);
            var i, o, radius = innerRadius;
            var uvs = [], radiusStep = ((outerRadius - innerRadius) / phiSegments);
            for (i = 0; i < phiSegments + 1; i++) {
                for (o = 0; o < thetaSegments + 1; o++) {
                    var vertex = new Trike.Vec3();
                    var segment = thetaStart + o / thetaSegments * thetaLength;
                    vertex.x = radius * Math.cos(segment);
                    vertex.y = radius * Math.sin(segment);
                    buffers[Trike.AttributeType.POSITION].data.push(vertex);
                    uvs.push(new Trike.Vec2((vertex.x / outerRadius + 1) / 2, (vertex.y / outerRadius + 1) / 2));
                }
                radius += radiusStep;
            }
            var n = new Trike.Vec3(0, 0, 1);
            // concentric circles inside ring
            for (i = 0; i < phiSegments; i++) {
                var thetaSegment = i * (thetaSegments + 1);
                // number of segments per circle
                for (o = 0; o < thetaSegments; o++) {
                    // Get the current UV index
                    var uvIndex = buffers[Trike.AttributeType.UV].data.length;
                    var normalIndex = buffers[Trike.AttributeType.NORMAL].data.length;
                    var segment = o + thetaSegment;
                    var v1 = segment;
                    var v2 = segment + thetaSegments + 1;
                    var v3 = segment + thetaSegments + 2;
                    // Add the faces
                    var face = new Trike.Face3(v1, v2, v3);
                    buffers[Trike.AttributeType.NORMAL].data.push(n.clone(), n.clone(), n.clone());
                    face.vertexNormals[0] = n.clone();
                    face.vertexNormals[1] = n.clone();
                    face.vertexNormals[2] = n.clone();
                    this.faces.push(face);
                    // Add some UV data to the geometry's UV buffer
                    buffers[Trike.AttributeType.UV].data.push(uvs[v1].clone(), uvs[v2].clone(), uvs[v3].clone());
                    // Set the face indices
                    face.setAttributeIndices(Trike.AttributeType.NORMAL, normalIndex, normalIndex + 1, normalIndex + 2);
                    face.setAttributeIndices(Trike.AttributeType.UV, uvIndex, uvIndex + 1, uvIndex + 2);
                    v1 = segment;
                    v2 = segment + thetaSegments + 2;
                    v3 = segment + 1;
                    // Add second the face
                    face = new Trike.Face3(v1, v2, v3);
                    buffers[Trike.AttributeType.NORMAL].data.push(n.clone(), n.clone(), n.clone());
                    face.vertexNormals[0] = n.clone();
                    face.vertexNormals[1] = n.clone();
                    face.vertexNormals[2] = n.clone();
                    this.faces.push(face);
                    // Add some UV data to the geometry's UV buffer
                    buffers[Trike.AttributeType.UV].data.push(uvs[v1].clone(), uvs[v2].clone(), uvs[v3].clone());
                    // Set the face indices
                    face.setAttributeIndices(Trike.AttributeType.NORMAL, normalIndex + 3, normalIndex + 4, normalIndex + 5);
                    face.setAttributeIndices(Trike.AttributeType.UV, uvIndex + 3, uvIndex + 4, uvIndex + 5);
                }
            }
            this.computeCentroids();
            this.computeFaceNormals();
            this.computeBoundingBox();
            this.computeBoundingSphere();
        };
        return GeometryRing;
    }(Trike.Geometry));
    Trike.GeometryRing = GeometryRing;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Use this class to create cube geometry
    */
    var GeometryTriangles = (function (_super) {
        __extends(GeometryTriangles, _super);
        function GeometryTriangles(triangleData, normalData, uvData) {
            if (normalData === void 0) { normalData = null; }
            if (uvData === void 0) { uvData = null; }
            _super.call(this);
            this.build(triangleData, normalData, uvData);
        }
        /**
        * Builds the geometry as a series of triangles
        */
        GeometryTriangles.prototype.build = function (triangleData, normalData, uvData) {
            if (normalData === void 0) { normalData = null; }
            if (uvData === void 0) { uvData = null; }
            // Add the buffers
            this.addAttributes(new Trike.GeometryBuffer([], 3, Trike.AttributeType.POSITION));
            var verteArray = this.buffers[Trike.AttributeType.POSITION].data;
            // Fill the vertex / position buffer
            for (var i = 0, len = triangleData.length; i < len; i++)
                verteArray.push(triangleData[i]);
            // Fill normal data if provided
            if (normalData) {
                this.addAttributes(new Trike.GeometryBuffer([], 3, Trike.AttributeType.NORMAL));
                var normalArray = this.buffers[Trike.AttributeType.POSITION].data;
                for (var i = 0, len = normalData.length; i < len; i++)
                    normalArray.push(normalData[i]);
            }
            // Fill uv data if provided
            if (uvData) {
                this.addAttributes(new Trike.GeometryBuffer([], 2, Trike.AttributeType.UV));
                var uvArray = this.buffers[Trike.AttributeType.UV].data;
                for (var i = 0, len = normalData.length; i < len; i++)
                    uvArray.push(uvData[i]);
            }
            this.computeBoundingBox();
            this.computeBoundingSphere();
        };
        return GeometryTriangles;
    }(Trike.Geometry));
    Trike.GeometryTriangles = GeometryTriangles;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Specialized geometry for Point clouds.
    */
    var GeometryPoints = (function (_super) {
        __extends(GeometryPoints, _super);
        function GeometryPoints() {
            _super.call(this);
            this.pointsScale = 1;
            if (!GeometryPoints._v)
                GeometryPoints._v = new Trike.Vec3();
        }
        /**
        * Rebuilds only specific buffers whose data has been modified outside the class.
        * If the number data of elements has changed, then this will throw errors and you should instead flag
        * the geometry for rebuild. Use this function, when the number of items stays the same, but we just need to flush
        * new values.
        * @param {WebGLRenderingContext} gl The webgl context
        */
        GeometryPoints.prototype.updateDirtyBuffers = function (gl) {
            var dirty = this.dirtyBuffers;
            var b;
            for (var i = 0, l = dirty.length; i < l; i++)
                if (dirty[i].type === Trike.AttributeType.POSITION) {
                    this.computeBoxSphere(true);
                    break;
                }
            return _super.prototype.updateDirtyBuffers.call(this, gl);
        };
        /**
        * Computes the bounding box of the geometry.
        */
        GeometryPoints.prototype.computeBoundingBox = function () {
            var sBuffer = this.buffers[Trike.AttributeType.SCALE];
            // No individual sizes, so just use the BB calculations as normal
            if (!sBuffer) {
                _super.prototype.computeBoundingBox.call(this);
                return;
            }
            var pBuffer = this.buffers[Trike.AttributeType.POSITION];
            // No positions means no bounds
            if (!pBuffer) {
                _super.prototype.computeBoundingBox.call(this);
                return;
            }
            this.computeBoxSphere(false);
        };
        /**
        * Computes the bounding sphere of the geometry.
        */
        GeometryPoints.prototype.computeBoundingSphere = function () {
            var sBuffer = this.buffers[Trike.AttributeType.SCALE];
            // No individual sizes, so just use the BB calculations as normal
            if (!sBuffer) {
                _super.prototype.computeBoundingSphere.call(this);
                return;
            }
            var pBuffer = this.buffers[Trike.AttributeType.POSITION];
            // No positions means no bounds
            if (!pBuffer) {
                _super.prototype.computeBoundingSphere.call(this);
                return;
            }
            this.computeBoxSphere(true);
        };
        /**
        * Computes the bounding box and / or sphere of the geometry.
        */
        GeometryPoints.prototype.computeBoxSphere = function (computeSphere) {
            var sBuffer = this.buffers[Trike.AttributeType.SCALE];
            if (!sBuffer) {
                _super.prototype.computeBoundingBox.call(this);
                this.boundingBox.getBoundingSphere(this.boundingSphere);
                return;
            }
            var pBuffer = this.buffers[Trike.AttributeType.POSITION];
            var box = this.boundingBox;
            var sphere = this.boundingSphere;
            var vertices = pBuffer.data;
            var scales = sBuffer.data;
            var maxRadiusSq = 0;
            var tempV = GeometryPoints._v;
            var x, y, z, v, scale, center, particleScale = this.pointsScale;
            if (vertices.length > 0) {
                v = vertices[0];
                box.min.copy(v);
                box.max.copy(v);
                // Do the box first
                for (var i = 0, l = vertices.length; i < l; i++) {
                    v = vertices[i];
                    scale = (scales[i] / 2) * particleScale * 0.4; // The 0.4 is an estimate
                    // Create a box around each point
                    x = v.x;
                    y = v.y;
                    z = v.z;
                    box.addPointXYZ(x - scale, y - scale, z - scale);
                    box.addPointXYZ(x + scale, y - scale, z - scale);
                    box.addPointXYZ(x - scale, y + scale, z - scale);
                    box.addPointXYZ(x + scale, y + scale, z - scale);
                    box.addPointXYZ(x - scale, y - scale, z + scale);
                    box.addPointXYZ(x + scale, y - scale, z + scale);
                    box.addPointXYZ(x - scale, y + scale, z + scale);
                    box.addPointXYZ(x + scale, y + scale, z + scale);
                }
                // Now do the sphere
                if (computeSphere)
                    box.getBoundingSphere(sphere);
            }
            else {
                box.makeEmpty();
                if (computeSphere)
                    sphere.empty();
                return;
            }
        };
        return GeometryPoints;
    }(Trike.Geometry));
    Trike.GeometryPoints = GeometryPoints;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Base class for all texture objects
    */
    var TextureBase = (function (_super) {
        __extends(TextureBase, _super);
        /**
        * Creates an instance of the TextureBase
        * @param {number} width The width of the texture
        * @param {number} height The height of the texture
        * @param {TextureMapping} mapping The mapping technique for this texture
        * @param {TextureWrapping} wrapS The S wrapping mode for the texture (horizontal)
        * @param {TextureWrapping} wrapT The T wrapping mode for the texture (vertical)
        * @param {TextureFilter} magFilter The filter to use when magnifying the image
        * @param {TextureFilter} minFilter The filter to use when minifying the image
        * @param {TextureFormat} format The texture format
        * @param {TextureType} type The texture type
        * @param {number} anisotropy Higher values give better results but are more expensive
        */
        function TextureBase(width, height, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
            _super.call(this);
            // Create a red image as a temp
            if (!TextureBase.defaultImage) {
                TextureBase.defaultImage = document.createElement('img');
                TextureBase.defaultImage.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkWg2AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAsSURBVDhPYzx8+DADNmBrawtloQImKE00GNVADGCE0hgAV/yMyFCitQYGBgCQcgVoJvPlYwAAAABJRU5ErkJggg==';
            }
            this.wrapS = wrapS !== undefined ? wrapS : Trike.TextureWrapping.MirroredRepeatWrapping;
            this.wrapT = wrapT !== undefined ? wrapT : Trike.TextureWrapping.MirroredRepeatWrapping;
            this.magFilter = magFilter !== undefined ? magFilter : Trike.TextureFilter.Linear;
            this.minFilter = minFilter !== undefined ? minFilter : Trike.TextureFilter.NearestMipMapLinear;
            this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
            this.format = format !== undefined ? format : Trike.TextureFormat.RGBAFormat;
            this.type = type !== undefined ? type : Trike.TextureType.UnsignedByteType;
            this.generateMipmaps = true;
        }
        Object.defineProperty(TextureBase.prototype, "anisotropy", {
            get: function () { return this._anisotropy; },
            set: function (val) {
                this._anisotropy = val;
                this.requiresBuild = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Gets the number of component slots of this texture. For example if the format is RGBA then its 4. If its RGB its 3.
        */
        TextureBase.prototype.getNumberComponents = function () {
            //  http://books.google.co.uk/books?id=3c-jmWkLNwUC&pg=PA80&lpg=PA80&dq=Int16Array+gl&source=bl&ots=z-tp2x2DAd&sig=2YW_MZ5s8HysyJIhIwTmVjc7QpU&hl=en&sa=X&ei=OSgcVKrpHcmxggSYmYJY&ved=0CCkQ6AEwAQ#v=onepage&q=Int16Array%20gl&f=false
            //  PG 181
            //  Base Internal Format    red     green   blue    alpha   luminance
            //   --------------------    ---    -----   ----    -----   ---------
            //   ALPHA                   0       0       0        A
            //   LUMINANCE               0       0       0                R
            //   LUMINANCE_ALPHA         0       0       0        A       R
            //   RGB                     R       G       B
            //   RGBA                    R       G       B        A
            if (this.format === Trike.TextureFormat.LuminanceAlphaFormat)
                return 2;
            else if (this.format === Trike.TextureFormat.RGBFormat)
                return 3;
            else if (this.format === Trike.TextureFormat.RGBAFormat)
                return 4;
            else
                return 1;
        };
        /**
        * Cleans up the references
        */
        TextureBase.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            Trike.Renderer.resoucesToRemove.push(this);
            this.format = null;
            this.wrapS = null;
            this.wrapT = null;
            this.type = null;
            this.minFilter = null;
            this.magFilter = null;
        };
        /**
        * Cleans up the references and frees the memory buffers
        */
        TextureBase.prototype.destroyBuffers = function (gl) {
            if (this.webglTexture)
                gl.deleteTexture(this.webglTexture);
            this.webglTexture = null;
        };
        return TextureBase;
    }(Trike.EventDispatcher));
    Trike.TextureBase = TextureBase;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A wrapper class for webgl textures
    */
    var Texture = (function (_super) {
        __extends(Texture, _super);
        /**
        * Creates an instance of the Texture
        * @param {HTMLImageElement} image Optional image to use
        * @param {TextureMapping} mapping The mapping technique for this texture
        * @param {TextureWrapping} wrapS The S wrapping mode for the texture (horizontal)
        * @param {TextureWrapping} wrapT The T wrapping mode for the texture (vertical)
        * @param {TextureFilter} magFilter The filter to use when magnifying the image
        * @param {TextureFilter} minFilter The filter to use when minifying the image
        * @param {TextureFormat} format The texture format
        * @param {TextureType} type The texture type
        * @param {number} anisotropy Higher values give better results but are more expensive
        */
        function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
            _super.call(this, 0, 0, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
            if (image === undefined || image === null)
                image = Trike.TextureBase.defaultImage;
            this.width = image.width;
            this.height = image.height;
            this.webglTexture = null;
            this.requiresBuild = true;
            this.flipY = true;
            this.premultiplyAlpha = false;
            // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
            this.unpackAlignment = 4;
            this.image = image;
            this.mipmaps = new Array();
            this.mapping = mapping !== undefined ? mapping : Trike.TextureMapping.UVMapping;
            this.offset = new Trike.Vec2(0, 0);
            this.repeat = new Trike.Vec2(1, 1);
            this.requiresBuild = true;
        }
        /**
        * Loads an image into this texure.
        * @param {string} url The image file URI we are loading
        * @param {string} crossOrigin The cross origin for the loader. The default is 'anonymous'
        * @returns {Texture}
        */
        Texture.prototype.loadImage = function (url, crossOrigin) {
            if (crossOrigin === void 0) { crossOrigin = 'anonymous'; }
            if (url === null || url === '') {
                this.image = Trike.TextureBase.defaultImage;
                this.width = this.image.width;
                this.height = this.image.height;
                this.requiresBuild = true;
                return;
            }
            // Create any temp loader vars
            if (!this._imageLoader) {
                this._imageLoader = document.createElement('img');
                this._proxyComplete = this._onComplete.bind(this);
                this._proxyProgress = this._onProgress.bind(this);
                this._proxyError = this._onError.bind(this);
            }
            if (crossOrigin !== undefined)
                this._imageLoader.crossOrigin = crossOrigin;
            this._imageLoader.addEventListener('load', this._proxyComplete);
            this._imageLoader.addEventListener('progress', this._proxyProgress);
            this._imageLoader.addEventListener('error', this._proxyError);
            this._imageLoader.src = url;
            return this;
        };
        /** Each time we make progress on the download */
        Texture.prototype._onProgress = function (e) {
            var percentLoaded = e.loaded / e.total * 100;
            this.emit('texture_loader_progress', { texture: this, previousImage: this.image, progress: percentLoaded, originalEvent: e });
        };
        /** Error downloading file */
        Texture.prototype._onError = function (e) {
            if (!this._imageLoader)
                return;
            this._imageLoader.removeEventListener('load', this._proxyComplete);
            this._imageLoader.removeEventListener('progress', this._proxyProgress);
            this._imageLoader.removeEventListener('error', this._proxyError);
            this._imageLoader = null;
            this.emit('texture_loader_error', { texture: this, previousImage: this.image, progress: 0, originalEvent: e });
        };
        /** File loaded */
        Texture.prototype._onComplete = function (e) {
            if (!this._imageLoader)
                return;
            var prevImage = this.image;
            this._imageLoader.removeEventListener('load', this._proxyComplete);
            this._imageLoader.removeEventListener('progress', this._proxyProgress);
            this._imageLoader.removeEventListener('error', this._proxyError);
            this.image = this._imageLoader;
            this.width = this.image.width;
            this.height = this.image.height;
            this.requiresBuild = true;
            this.emit('texture_loader_complete', { texture: this, previousImage: prevImage, progress: 100, originalEvent: e });
        };
        /**
        * Sets some of the filter data of the texture
        */
        Texture.setFilters = function (texture, gl, textureType, isImagePowerOfTwo) {
            if (isImagePowerOfTwo) {
                gl.texParameteri(textureType, gl.TEXTURE_WRAP_S, Trike.getGLParam(texture.wrapS, gl));
                gl.texParameteri(textureType, gl.TEXTURE_WRAP_T, Trike.getGLParam(texture.wrapT, gl));
                gl.texParameteri(textureType, gl.TEXTURE_MAG_FILTER, Trike.getGLParam(texture.magFilter, gl));
                gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, Trike.getGLParam(texture.minFilter, gl));
            }
            else {
                gl.texParameteri(textureType, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(textureType, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(textureType, gl.TEXTURE_MAG_FILTER, Texture.filterFallback(texture.magFilter, gl));
                gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, Texture.filterFallback(texture.minFilter, gl));
            }
            if (Trike.Capabilities.getSingleton().glExtensionTextureFilterAnisotropic && texture.type !== Trike.TextureType.FloatType) {
                if (texture.anisotropy > 1)
                    gl.texParameterf(textureType, Trike.Capabilities.getSingleton().glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, Trike.Capabilities.getSingleton().maxAnisotropy));
            }
        };
        /**
        * This function is called to fill the buffers of the webgl texture.
        * @param {WebGLRenderingContext} gl The WebGLRenderingContext we are using to compile the texture with
        * @param {number} glFormat The webgl texture format flag
        * @param {number} glType The webgl texture type flag
        * @param {boolean} isImagePowerOfTwo The Is this texture a power of 2
        * @param {Array<ImageData>} mipmaps An optional array of images to be used for mipmaps
        */
        Texture.prototype.fillTextureBuffer = function (gl, glFormat, glType, isImagePowerOfTwo, mipmaps) {
            var mipmap;
            // regular Texture (image, video, canvas)
            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels
            if (mipmaps.length > 0 && isImagePowerOfTwo) {
                for (var i = 0, il = mipmaps.length; i < il; i++) {
                    mipmap = mipmaps[i];
                    gl.texImage2D(gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap);
                }
            }
            else
                gl.texImage2D(gl.TEXTURE_2D, 0, glFormat, glFormat, glType, this.image);
        };
        /**
        * Builds the webgl texture and fills the buffer data
        * @param {WebGLRenderingContext} gl The WebGLRenderingContext we are using to compile the texture with
        * @param {number} slot The slot we can use to build this texture. This is provided by the Renderer
        */
        Texture.prototype.compile = function (gl, slot) {
            var image = this.image;
            var isImagePowerOfTwo = Texture.isPowerOfTwo(image.width) && Texture.isPowerOfTwo(image.height);
            var glFormat = Trike.getGLParam(this.format, gl);
            var glType = Trike.getGLParam(this.type, gl);
            var mipmaps = this.mipmaps;
            var generateMipmaps = this.generateMipmaps;
            if (this.webglTexture) {
                gl.deleteTexture(this.webglTexture);
                this.webglTexture = null;
            }
            // Create the texture
            this.webglTexture = gl.createTexture();
            // Bind it so we can set the params
            gl.activeTexture(slot);
            gl.bindTexture(gl.TEXTURE_2D, this.webglTexture);
            // Now set the texture parameters
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, (this.flipY ? 1 : 0));
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, (this.premultiplyAlpha ? 1 : 0));
            gl.pixelStorei(gl.UNPACK_ALIGNMENT, this.unpackAlignment);
            // Sets the different texture filters.
            Texture.setFilters(this, gl, gl.TEXTURE_2D, isImagePowerOfTwo);
            this.fillTextureBuffer(gl, glFormat, glType, isImagePowerOfTwo, mipmaps);
            if (generateMipmaps) {
                var genMaps = false;
                if (mipmaps.length > 0)
                    this.fillTextureBuffer(gl, glFormat, glType, isImagePowerOfTwo, this.mipmaps);
                else
                    genMaps = true;
                if (genMaps && isImagePowerOfTwo)
                    gl.generateMipmap(gl.TEXTURE_2D);
            }
            gl.bindTexture(gl.TEXTURE_2D, null);
            this.requiresBuild = false;
        };
        /**
        * Checks if a value is a power of 2
        * @param {number} value The value we are checking
        * @returns {boolean}
        */
        Texture.isPowerOfTwo = function (value) {
            return (value & (value - 1)) === 0;
        };
        /**
        * Determines which webgl texture filter we need to use
        * @param {TextureFilter} value The TextureFilter we are checking
        * @param {WebGLRenderingContext} gl The WebGLRenderingContext associated with this texture
        * @returns {number}
        */
        Texture.filterFallback = function (f, gl) {
            if (f === Trike.TextureFilter.Nearest || f === Trike.TextureFilter.NearestMipMap || f === Trike.TextureFilter.NearestMipMapLinear)
                return gl.NEAREST;
            return gl.LINEAR;
        };
        /**
        * Cleans up the references and frees the memory buffers
        */
        Texture.prototype.dispose = function () {
            this._onError(null);
            _super.prototype.dispose.call(this);
            this.image = null;
            this.mapping = null;
            this.mipmaps = null;
        };
        return Texture;
    }(Trike.TextureBase));
    Trike.Texture = Texture;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * The CanvasTexture uses a Canvas object instead of an image to represent texture data. This can be really useful
    * to draw dynamic textures on a mesh. Simply use the canvas context and set Texture.requiresBuild to true to re-draw the canvas.
    * The CanvasTexture ignores its internal image property when filling the webgl texture buffers, but does use it as a reference when
    * loading images or re-sizing the texture.
    */
    var CanvasTexture = (function (_super) {
        __extends(CanvasTexture, _super);
        /**
        * Creates an instance of the CanvasTexture
        * @param {number} width The canvas width
        * @param {number} height The canvas height
        * @param {string} fillStyle The fill color of the canvas
        */
        function CanvasTexture(width, height, fillStyle) {
            if (fillStyle === void 0) { fillStyle = '#000000'; }
            var canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            var context = canvas.getContext('2d');
            context.fillStyle = fillStyle;
            context.fillRect(0, 0, width, height);
            var imageData = context.getImageData(0, 0, width, height);
            var image = document.createElement('img');
            image.src = canvas.toDataURL('image/png');
            _super.call(this, image);
            this.canvas = canvas;
            this.context = context;
            this.imageData = imageData;
        }
        /**
        * Resizes the canvas
        * @param {number} width The new width
        * @param {number} height The new height
        * @param {boolean} redrawImage Should the canvas re-draw its base image. The default is true.
        */
        CanvasTexture.prototype.resize = function (width, height, redrawImage) {
            if (redrawImage === void 0) { redrawImage = true; }
            this.flush();
            this.width = width;
            this.height = height;
            this.canvas.width = width;
            this.canvas.height = height;
            if (redrawImage)
                this.context.drawImage(this.image, 0, 0, this.image.width, this.image.height, 0, 0, width, height);
            this.imageData = this.context.getImageData(0, 0, width, height);
            this.image.src = this.canvas.toDataURL('image/png');
            this.requiresBuild = true;
        };
        /**
        * Fills the image with the contents of the canvas. Will cause a texture update.
        */
        CanvasTexture.prototype.flush = function () {
            this.image.src = this.canvas.toDataURL('image/png');
            this.requiresBuild = true;
        };
        /**
        * Fills the image with the contents of the canvas. Will cause a texture update.
        */
        CanvasTexture.prototype.syncImageData = function () {
            this.imageData = this.context.getImageData(0, 0, this.image.width, this.image.height);
        };
        /**
        * Override the complete function so we can re-draw the image that was loaded onto the canvas
        */
        CanvasTexture.prototype._onComplete = function (e) {
            _super.prototype._onComplete.call(this, e);
            // Update the canvas to have the same image
            this.canvas.width = this.image.width;
            this.canvas.height = this.image.height;
            this.context.drawImage(this.image, 0, 0, this.image.width, this.image.height, 0, 0, this.image.width, this.image.height);
            this.imageData = this.context.getImageData(0, 0, this.image.width, this.image.height);
        };
        /**
        * This function is called to fill the data of a webgl texture.
        */
        CanvasTexture.prototype.fillTextureBuffer = function (gl, glFormat, glType, isImagePowerOfTwo, mipmaps) {
            var mipmap;
            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels
            if (mipmaps && mipmaps.length > 0 && isImagePowerOfTwo) {
                for (var i = 0, il = mipmaps.length; i < il; i++) {
                    mipmap = mipmaps[i];
                    gl.texImage2D(gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
            }
            else
                gl.texImage2D(gl.TEXTURE_2D, 0, glFormat, glFormat, glType, this.canvas);
        };
        return CanvasTexture;
    }(Trike.Texture));
    Trike.CanvasTexture = CanvasTexture;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Textures filled with raw data
    */
    var DataTexture = (function (_super) {
        __extends(DataTexture, _super);
        /**
        * @param {ArrayBufferView} data Can be either Uint8Array, or Float32Array
        * @param {number} width The width of this texture
        * @param {number} height The height of this texture
        * @param {TextureFormat} format
        * @param {TextureType} type Can be either Uint8Array = TextureType.UnsignedByteType or  Float32Array = TextureType.FloatType
        * @param {number} anisotropy Higher values give better results but are more expensive
        * @param {TextureMapping} mapping The mapping technique for this texture
        * @param {TextureWrapping} wrapS The S wrapping mode for the texture (horizontal)
        * @param {TextureWrapping} wrapT The T wrapping mode for the texture (vertical)
        */
        function DataTexture(data, width, height, format, type, anisotropy, mapping, wrapS, wrapT, magFilter, minFilter) {
            if (magFilter === void 0) { magFilter = Trike.TextureFilter.Linear; }
            if (minFilter === void 0) { minFilter = Trike.TextureFilter.Linear; }
            _super.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
            this.data = data;
            this.width = width;
            this.height = height;
            this.generateMipmaps = false;
            if (!data)
                this.buildCommonDataFormat();
        }
        /**
        * Loads an image into this texure.
        * @param {string} url The image file URI we are loading
        * @param {string} crossOrigin The cross origin for the loader. The default is 'anonymous'
        * @returns {Texture}
        */
        DataTexture.prototype.loadImage = function (url, crossOrigin) {
            if (crossOrigin === void 0) { crossOrigin = 'anonymous'; }
            var binaryLoader = new Trike.BinaryLoader();
            binaryLoader.on('binary_success', this.loaded, this);
            binaryLoader.on('binary_error', this.loaded, this);
            binaryLoader.load(url);
            return this;
        };
        /**
        * Data successfully loaded
        */
        DataTexture.prototype.loaded = function (response, event, sender) {
            sender.off('binary_success', this.loaded, this);
            sender.off('binary_error', this.loaded, this);
            if (response === 'binary_error') {
                console.error('Could not load data texture');
                this.emit('texture_loader_error', { texture: this, previousImage: null, progress: 0, originalEvent: null });
                return;
            }
            // Parse the array buffer based on the data type
            if (this.type === Trike.TextureType.FloatType)
                this.data = new Float32Array(event.buffer);
            else if (this.type === Trike.TextureType.UnsignedByteType)
                this.data = new Uint8Array(event.buffer);
            this.requiresBuild = true;
            this.emit('texture_loader_complete', { texture: this, previousImage: this.image, progress: 100, originalEvent: null });
        };
        /**
        * Resizes the data texture. You must re-fill the data object.
        * @param {any} data Must be the same format as the data provided in the constructor
        * @param {number} width The width of the texture
        * @param {number} height The height of the texture
        */
        DataTexture.prototype.resize = function (data, width, height) {
            this.width = width;
            this.height = height;
            this.data = data;
            this.requiresBuild = true;
        };
        /**
        * Gets a square of data out of the data array
        */
        DataTexture.prototype.getImageData = function (left, top, width, height) {
            var data = this.data;
            var textureW = this.width;
            var textureH = this.height;
            var numComponents = this.getNumberComponents();
            var index = ((textureW * top) + left) * numComponents;
            // Make sure within boundaries
            if (index >= this.data.length)
                return [];
            if (left + width > textureW)
                width -= (left + width) - textureW;
            if (top + height > textureH)
                height -= (left + height) - textureH;
            if (left < 0)
                return [];
            if (top < 0)
                return [];
            var toReturn = [];
            for (var y = 0, yl = height; y < yl; y++) {
                index = ((textureW * (top + y)) + left) * numComponents;
                for (var x = 0, xl = width; x < xl; x++)
                    for (var c = 0, cl = numComponents; c < cl; c++)
                        toReturn.push(data[index + (x * numComponents + c)]);
            }
            return toReturn;
        };
        /**
        * Sets the data values of each component based on the newData array, but only within the rectangular
        * area provided.
        */
        DataTexture.prototype.putImageData = function (newData, left, top, width, height) {
            var data = this.data;
            var textureW = this.width;
            var textureH = this.height;
            var numComponents = this.getNumberComponents();
            var index = ((textureW * top) + left) * numComponents;
            // Make sure within boundaries
            if (index >= this.data.length)
                return;
            if (left + width > textureW)
                width -= (left + width) - textureW;
            if (top + height > textureH)
                height -= (left + height) - textureH;
            if (left < 0)
                return;
            if (top < 0)
                return;
            var toReturn = [];
            var counter = 0;
            for (var y = 0, yl = height; y < yl; y++) {
                index = ((textureW * (top + y)) + left) * numComponents;
                for (var x = 0, xl = width; x < xl; x++)
                    for (var c = 0, cl = numComponents; c < cl; c++) {
                        this.data[index + (x * numComponents + c)] = newData[counter];
                        counter++;
                    }
            }
            return;
        };
        /**
        * Tries to build the data array by looking at the format and type of data texture
        */
        DataTexture.prototype.buildCommonDataFormat = function () {
            var componentSize = this.getNumberComponents();
            var w = this.width;
            var h = this.height;
            // http://books.google.co.uk/books?id=3c-jmWkLNwUC&pg=PA80&lpg=PA80&dq=Int16Array+gl&source=bl&ots=z-tp2x2DAd&sig=2YW_MZ5s8HysyJIhIwTmVjc7QpU&hl=en&sa=X&ei=OSgcVKrpHcmxggSYmYJY&ved=0CCkQ6AEwAQ#v=onepage&q=Int16Array%20gl&f=false
            // Pg 80
            if (this.type === Trike.TextureType.FloatType)
                this.data = new Float32Array(w * h * componentSize);
            else if (this.type === Trike.TextureType.UnsignedByteType)
                this.data = new Uint8Array(w * h * componentSize);
            this.requiresBuild = true;
        };
        /**
        * This function is called to fill the data of a webgl texture.
        */
        DataTexture.prototype.fillTextureBuffer = function (gl, glFormat, glType, isImagePowerOfTwo, mipmaps) {
            var mipmap;
            // use manually created mipmaps if available
            // if there are no manual mipmaps
            // set 0 level mipmap and then use GL to generate other mipmap levels
            if (mipmaps && mipmaps.length > 0 && isImagePowerOfTwo) {
                for (var i = 0, il = mipmaps.length; i < il; i++) {
                    mipmap = mipmaps[i];
                    gl.texImage2D(gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
            }
            else
                gl.texImage2D(gl.TEXTURE_2D, 0, glFormat, this.width, this.height, 0, glFormat, glType, this.data);
        };
        return DataTexture;
    }(Trike.Texture));
    Trike.DataTexture = DataTexture;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    var DepthTexture = (function (_super) {
        __extends(DepthTexture, _super);
        function DepthTexture(width, height, stencilBuffer) {
            if (stencilBuffer === void 0) { stencilBuffer = true; }
            _super.call(this, width, height, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Nearest, Trike.TextureFilter.Nearest, (stencilBuffer ? Trike.TextureFormat.DepthStencil : Trike.TextureFormat.DepthComponent), (stencilBuffer ? Trike.TextureType.UNSIGNED_INT_24_8_WEBGL :
                Trike.TextureType.UnsignedShortType));
            this.stencilBuffer = stencilBuffer;
        }
        DepthTexture.prototype.compile = function (gl) {
            if (this.webglTexture)
                gl.deleteTexture(this.webglTexture);
            var isTargetPowerOfTwo = Trike.Texture.isPowerOfTwo(this.width) && Trike.Texture.isPowerOfTwo(this.height);
            // Create the depth texture
            this.webglTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.webglTexture);
            Trike.Texture.setFilters(this, gl, gl.TEXTURE_2D, isTargetPowerOfTwo);
            var glFormat = Trike.getGLParam(this.format, gl);
            var glType = Trike.getGLParam(this.type, gl);
            gl.texImage2D(gl.TEXTURE_2D, 0, glFormat, this.width, this.height, 0, glFormat, glType, null);
            gl.bindTexture(gl.TEXTURE_2D, null);
        };
        /**
        * Resizes the target. Will require a re-compile
        */
        DepthTexture.prototype.resize = function (width, height) {
            this.width = width;
            this.height = height;
        };
        /**
        * Cleans up the references and the queues the buffers for removal.
        */
        DepthTexture.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        /**
        * Cleans up the references and frees the memory buffers
        */
        DepthTexture.prototype.destroyBuffers = function (gl) {
            _super.prototype.destroyBuffers.call(this, gl);
        };
        return DepthTexture;
    }(Trike.TextureBase));
    Trike.DepthTexture = DepthTexture;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Render targets are special textures that a webgl render can draw a scene onto. The
    * texture can then be re-used as a texture that can be applied onto other objects.
    */
    var RenderTarget = (function (_super) {
        __extends(RenderTarget, _super);
        /**
        * Creates an instance of the render target
        * @param {number} width The width of this texture
        * @param {number} height The height of this texture
        * @param {TextureType} type The texture type
        * @param {TextureWrapping} wrapS How the texture wraps horizontally
        * @param {TextureWrapping} wrapT How the texture wraps vertically
        * @param {TextureFilter} magFilter The filter to use when the texture is magnified
        * @param {TextureFilter} minfFilter The filter to use when the texture is minified
        * @param {TextureFormat} format The texture format
        * @param {number} anisotropy Can improve the texture quality. Higher values mean better quality textures (max 16 at this time).
        * @param {boolean} depthBuffer If true, this render target will maintain a depth buffer
        * @param {boolean} stencilBuffer If true, this render target will maintain a stencil buffer
        * @param {boolean} renderDepthToTexture If true, this render target will create a depth texture (Not well supported)
        */
        function RenderTarget(width, height, type, wrapS, wrapT, magFilter, minFilter, format, anisotropy, depthBuffer, stencilBuffer, renderDepthToTexture) {
            if (wrapS === void 0) { wrapS = Trike.TextureWrapping.ClampToEdgeWrapping; }
            if (wrapT === void 0) { wrapT = Trike.TextureWrapping.ClampToEdgeWrapping; }
            if (magFilter === void 0) { magFilter = Trike.TextureFilter.Nearest; }
            if (minFilter === void 0) { minFilter = Trike.TextureFilter.Nearest; }
            if (format === void 0) { format = Trike.TextureFormat.RGBAFormat; }
            if (anisotropy === void 0) { anisotropy = 1; }
            if (depthBuffer === void 0) { depthBuffer = true; }
            if (stencilBuffer === void 0) { stencilBuffer = true; }
            if (renderDepthToTexture === void 0) { renderDepthToTexture = false; }
            _super.call(this, width, height, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
            this.width = width;
            this.height = height;
            this.id = RenderTarget.renderTargetCounter;
            RenderTarget.renderTargetCounter++;
            // Some browsers have the ability to render the depth buffer into a texture
            if (renderDepthToTexture)
                this.depthTexture = new Trike.DepthTexture(width, height, stencilBuffer);
            else
                this.depthTexture = null;
            this.depthBuffer = depthBuffer !== undefined ? depthBuffer : true;
            this.stencilBuffer = stencilBuffer !== undefined ? stencilBuffer : true;
            this.frameBuffer = null;
            this.webglTexture = null;
            this.renderBuffer = null;
            this.requiresBuild = true;
            this.generateMipmaps = false;
            this.renderDepthToTexture = renderDepthToTexture;
        }
        /**
        * Cleans up the references and the queues the buffers for removal.
        */
        RenderTarget.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        /**
        * Cleans up the references and frees the memory buffers
        */
        RenderTarget.prototype.destroyBuffers = function (gl) {
            _super.prototype.destroyBuffers.call(this, gl);
            gl.deleteFramebuffer(this.frameBuffer);
            gl.deleteRenderbuffer(this.renderBuffer);
            if (this.depthTexture)
                this.depthTexture.destroyBuffers(gl);
            this.frameBuffer = null;
            this.renderBuffer = null;
            this.depthTexture = null;
            this._sharedRenderBuffer = null;
        };
        /**
        * Resizes the target. Will require a re-compile
        * @param {number} width
        * @param {number} height
        */
        RenderTarget.prototype.resize = function (width, height) {
            this.width = width;
            this.height = height;
            this.requiresBuild = true;
            if (this.renderDepthToTexture)
                this.depthTexture.resize(width, height);
        };
        Object.defineProperty(RenderTarget.prototype, "sharedRenderBuffer", {
            /**
            * Gets the shared render buffer of this target
            * @returns {WebGLRenderbuffer}
            */
            get: function () { return this._sharedRenderBuffer; },
            /**
            * Sets the shared render buffer of this target. Causes a rebuild.
            * @param {WebGLRenderbuffer} val
            */
            set: function (val) {
                this._sharedRenderBuffer = val;
                this.requiresBuild = true;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Builds the frame buffers. Called if requiresBuild is set to true.
        */
        RenderTarget.prototype.compile = function (gl) {
            if (this.webglTexture) {
                gl.deleteTexture(this.webglTexture);
                gl.deleteFramebuffer(this.frameBuffer);
                if (!this._sharedRenderBuffer)
                    gl.deleteRenderbuffer(this.renderBuffer);
            }
            // If this buffer shares its depth and stencil from another, we need to make sure that render buffer
            // is compiled first
            if (this._sharedRenderBuffer && this._sharedRenderBuffer.requiresBuild)
                this._sharedRenderBuffer.compile(gl);
            // Create the texture
            this.webglTexture = gl.createTexture();
            // Setup texture, create render and frame buffers
            var isTargetPowerOfTwo = Trike.Texture.isPowerOfTwo(this.width) && Trike.Texture.isPowerOfTwo(this.height), glFormat = Trike.getGLParam(this.format, gl), glType = Trike.getGLParam(this.type, gl);
            // Create the frame buffer
            this.frameBuffer = gl.createFramebuffer();
            // rendering to that texture type not supported
            if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE)
                return false;
            // Create the render buffer
            if (this._sharedRenderBuffer)
                this.renderBuffer = this._sharedRenderBuffer.renderBuffer;
            else
                this.renderBuffer = gl.createRenderbuffer();
            if (this.renderDepthToTexture && Trike.Capabilities.getSingleton().depthTextureExt)
                this.depthTexture.compile(gl);
            gl.bindTexture(gl.TEXTURE_2D, this.webglTexture);
            Trike.Texture.setFilters(this, gl, gl.TEXTURE_2D, isTargetPowerOfTwo);
            gl.texImage2D(gl.TEXTURE_2D, 0, glFormat, this.width, this.height, 0, glFormat, glType, null);
            // Bind the frame buffer so that its active
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
            // Tell the bound frame buffer its associated with this texture and render buffer
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.webglTexture, 0);
            if (this._sharedRenderBuffer) {
                if (this.depthBuffer && !this.stencilBuffer)
                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderBuffer);
                else if (this.depthBuffer && this.stencilBuffer)
                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.renderBuffer);
            }
            else {
                gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);
                if (this.depthBuffer && !this.stencilBuffer) {
                    if (this.renderDepthToTexture)
                        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.depthTexture.webglTexture, 0);
                    else {
                        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
                        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderBuffer);
                    }
                }
                else if (this.depthBuffer && this.stencilBuffer) {
                    if (this.renderDepthToTexture)
                        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.TEXTURE_2D, this.depthTexture.webglTexture, 0);
                    else {
                        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, this.width, this.height);
                        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.renderBuffer);
                    }
                }
                else
                    gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA4, this.width, this.height);
            }
            // Generate mipmaps
            if (isTargetPowerOfTwo)
                gl.generateMipmap(gl.TEXTURE_2D);
            // Release everything
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            this.requiresBuild = false;
            return true;
        };
        RenderTarget.renderTargetCounter = 0;
        return RenderTarget;
    }(Trike.TextureBase));
    Trike.RenderTarget = RenderTarget;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A special kind of render target that creates a 6 sided cubed texture instead of a regular 2d texture.
    * Cube render targets need separate render calls to draw each of the 6 textures. You can set which side
    * to draw by calling the activeCubeFace property.
    */
    var RenderTargetCube = (function (_super) {
        __extends(RenderTargetCube, _super);
        /**
        * Creates an instance of the render target
        * @param {number} width The width of this texture
        * @param {number} height The height of this texture
        * @param {TextureType} type The texture type
        * @param {TextureWrapping} wrapS How the texture wraps horizontally
        * @param {TextureWrapping} wrapT How the texture wraps vertically
        * @param {TextureFilter} magFilter The filter to use when the texture is magnified
        * @param {TextureFilter} minfFilter The filter to use when the texture is minified
        * @param {TextureFormat} format The texture format
        * @param {number} anisotropy Can improve the texture quality. Higher values mean better quality textures (max 16 at this time).
        * @param {boolean} depthBuffer If true, this render target will maintain a depth buffers
        * @param {boolean} stencilBuffer If true, this render target will maintain a stencil buffers
        * @param {boolean} renderDepthToTexture If true, this render target will create a depth textures (Not well supported)
        */
        function RenderTargetCube(width, height, type, wrapS, wrapT, magFilter, minFilter, format, anisotropy, depthBuffer, stencilBuffer, renderDepthToTexture) {
            if (magFilter === void 0) { magFilter = Trike.TextureFilter.Linear; }
            if (minFilter === void 0) { minFilter = Trike.TextureFilter.Linear; }
            if (depthBuffer === void 0) { depthBuffer = false; }
            if (stencilBuffer === void 0) { stencilBuffer = false; }
            if (renderDepthToTexture === void 0) { renderDepthToTexture = false; }
            _super.call(this, width, height, type, wrapS, wrapT, magFilter, minFilter, format, anisotropy, depthBuffer, stencilBuffer, false);
            this.renderDepthToTexture = renderDepthToTexture;
            if (renderDepthToTexture)
                for (var i = 0, l = 6; i < 6; i++)
                    this._depthTextures[i] = new Trike.DepthTexture(width, height, stencilBuffer);
            this._activeCubeFace = 0;
            this._frameBuffers = [];
            this._renderBuffers = [];
            this._depthTextures = [];
        }
        Object.defineProperty(RenderTargetCube.prototype, "activeCubeFace", {
            /**
            * Gets the currently active texture for this render target
            * @returns {number} index The index from 0 to 5
            */
            get: function () { return this._activeCubeFace; },
            /**
            * Sets the currently active texture for this render target
            * @param {number} index The index from 0 to 5
            */
            set: function (index) {
                if (index > 5)
                    index = 5;
                this._activeCubeFace = index;
                this.frameBuffer = this._frameBuffers[index];
                this.renderBuffer = this._renderBuffers[index];
                this.depthTexture = this._depthTextures[index];
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Cleans up the references and the queues the buffers for removal.
        */
        RenderTargetCube.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        /**
        * Cleans up the references and frees the memory buffers
        */
        RenderTargetCube.prototype.destroyBuffers = function (gl) {
            if (this.renderDepthToTexture)
                for (var i = 0, l = 6; i < 6; i++) {
                    this._depthTextures[i].destroyBuffers(gl);
                    gl.deleteFramebuffer(this._frameBuffers[i]);
                    gl.deleteRenderbuffer(this._renderBuffers[i]);
                }
            this._frameBuffers = null;
            this._renderBuffers = null;
            this._depthTextures = null;
            // Call base
            _super.prototype.destroyBuffers.call(this, gl);
        };
        /**
        * Resizes the target. Will require a re-compile
        */
        RenderTargetCube.prototype.resize = function (width, height) {
            this.width = width;
            this.height = height;
            this.requiresBuild = true;
            if (this.renderDepthToTexture)
                for (var i = 0, l = 6; i < 6; i++)
                    this._depthTextures[i].resize(width, height);
        };
        /**
        * Builds the frame buffers. Called if requiresBuild is set to true.
        */
        RenderTargetCube.prototype.compile = function (gl) {
            if (this.webglTexture) {
                gl.deleteTexture(this.webglTexture);
                for (var i = 0, l = 6; i < 6; i++) {
                    gl.deleteFramebuffer(this._frameBuffers[i]);
                    gl.deleteRenderbuffer(this._renderBuffers[i]);
                }
                this._activeCubeFace = 0;
                this._frameBuffers = [];
                this._renderBuffers = [];
                this._depthTextures = [];
                this.frameBuffer = null;
                this.renderBuffer = null;
                this.depthTexture = null;
            }
            // Create the texture
            this.webglTexture = gl.createTexture();
            // Setup texture, create render and frame buffers
            var isTargetPowerOfTwo = Trike.Texture.isPowerOfTwo(this.width) && Trike.Texture.isPowerOfTwo(this.height), glFormat = Trike.getGLParam(this.format, gl), glType = Trike.getGLParam(this.type, gl);
            // Bind the webgl texture
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.webglTexture);
            // Set the texture filters
            Trike.Texture.setFilters(this, gl, gl.TEXTURE_CUBE_MAP, isTargetPowerOfTwo);
            // Now for each of the 6 sides of a cube texture...
            for (var i = 0, l = 6; i < 6; i++) {
                if (this.renderDepthToTexture && Trike.Capabilities.getSingleton().depthTextureExt)
                    this._depthTextures[i].compile(gl);
                // Create the frame buffers
                this._frameBuffers[i] = gl.createFramebuffer();
                // rendering to that texture type not supported
                if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE)
                    return false;
                // Create the render buffer
                this._renderBuffers[i] = gl.createRenderbuffer();
                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, this.width, this.height, 0, glFormat, glType, null);
                // Bind the frame buffer so that its active
                gl.bindFramebuffer(gl.FRAMEBUFFER, this._frameBuffers[i]);
                // Tell the bound frame buffer its associated with this texture and render buffer
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, this.webglTexture, 0);
                gl.bindRenderbuffer(gl.RENDERBUFFER, this._renderBuffers[i]);
                if (this.depthBuffer && !this.stencilBuffer) {
                    if (this.renderDepthToTexture)
                        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this._depthTextures[i].webglTexture, 0);
                    else {
                        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
                        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._renderBuffers[i]);
                    }
                }
                else if (this.depthBuffer && this.stencilBuffer) {
                    if (this.renderDepthToTexture)
                        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.TEXTURE_2D, this._depthTextures[i].webglTexture, 0);
                    else {
                        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, this.width, this.height);
                        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._renderBuffers[i]);
                    }
                }
                else
                    gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA4, this.width, this.height);
            }
            // Generate mipmaps
            if (isTargetPowerOfTwo && this.generateMipmaps)
                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
            // Release everything
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            this.requiresBuild = false;
            return true;
        };
        return RenderTargetCube;
    }(Trike.RenderTarget));
    Trike.RenderTargetCube = RenderTargetCube;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * An extended render target with a shader for drawing 2D textures
    */
    var ShaderTexture = (function (_super) {
        __extends(ShaderTexture, _super);
        /**
        * Creates an instance of the render target
        * @param {MaterialMulti} material The material to use when drawing this 2d shader
        * @param {number} width The width of this texture
        * @param {number} height The height of this texture
        * @param {boolean} animated If true, this texture will need to get updated each frame
        * @param {TextureType} type The texture type
        * @param {TextureWrapping} wrapS How the texture wraps horizontally
        * @param {TextureWrapping} wrapT How the texture wraps vertically
        * @param {TextureFilter} magFilter The filter to use when the texture is magnified
        * @param {TextureFilter} minfFilter The filter to use when the texture is minified
        * @param {TextureFormat} format The texture format
        * @param {number} anisotropy Can improve the texture quality. Higher values mean better quality textures (max 16 at this time).
        */
        function ShaderTexture(material, width, height, animated, type, wrapS, wrapT, magFilter, minFilter, format, anisotropy) {
            if (animated === void 0) { animated = true; }
            if (wrapS === void 0) { wrapS = Trike.TextureWrapping.ClampToEdgeWrapping; }
            if (wrapT === void 0) { wrapT = Trike.TextureWrapping.ClampToEdgeWrapping; }
            if (magFilter === void 0) { magFilter = Trike.TextureFilter.Nearest; }
            if (minFilter === void 0) { minFilter = Trike.TextureFilter.Nearest; }
            if (format === void 0) { format = Trike.TextureFormat.RGBAFormat; }
            if (anisotropy === void 0) { anisotropy = 1; }
            _super.call(this, width, height, type, wrapS, wrapT, magFilter, minFilter, format, anisotropy, false, false, false);
            this.generateMipmaps = true;
            this.material = material;
            this._animated = animated;
            this.requiresDraw = true;
        }
        /**
        * An update call made before the rendering process begins
        * @param {number} totalTime The total number of milliseconds since the start of the app
        * @param {number} delta The delta time since the last update call
        * @param {Camera} camera The camera being for the render
        * @param {Renderer} renderer The renderer used to draw the scene
        */
        ShaderTexture.prototype.update = function (totalTime, delta, camera, renderer) {
            var mat = this.material.materials[Trike.PassType.Texture];
            if (this._animated) {
                if (mat._uniforms['timeConst'])
                    mat.setUniform('timeConst', mat._uniforms['timeConst'].value + 0.01, false);
                if (mat._uniforms['time'])
                    mat.setUniform('time', totalTime, false);
                if (mat._uniforms['timeDelta'])
                    mat.setUniform('delta', totalTime, false);
            }
        };
        /**
        * Cleans up the references and the queues the buffers for removal.
        */
        ShaderTexture.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        /**
        * Resizes the target. Will require a re-compile
        * @param {number} width
        * @param {number} height
        */
        ShaderTexture.prototype.resize = function (width, height) {
            _super.prototype.resize.call(this, width, height);
            var mat = this.material.materials[Trike.PassType.Texture];
            if (mat._uniforms['texelSize'])
                mat.setUniform('texelSize', mat._uniforms['texelSize'].value.set(1 / width, 1 / height), false);
            if (mat._uniforms['textureWidth'])
                mat.setUniform('textureWidth', width, false);
            if (mat._uniforms['textureHeight'])
                mat.setUniform('textureHeight', height, false);
            if (mat._uniforms['resolution'])
                mat.setUniform('resolution', new Trike.Vec2(width, height), false);
        };
        Object.defineProperty(ShaderTexture.prototype, "animated", {
            /**
            * Gets if this texture is drawn each frame
            * @returns {boolean}
            */
            get: function () { return this._animated; },
            /**
            * Sets if this texture is drawn each frame
            * @param {boolean} val
            */
            set: function (val) {
                if (this._animated === val)
                    return;
                this._animated = val;
                if (val) {
                    this.material.addDefine(Trike.ShaderDefines.ANIMATED);
                    this.requiresDraw = true;
                }
                else
                    this.material.removeDefine(Trike.ShaderDefines.ANIMATED);
            },
            enumerable: true,
            configurable: true
        });
        return ShaderTexture;
    }(Trike.RenderTarget));
    Trike.ShaderTexture = ShaderTexture;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A {CubeTexture} in Trike is a wrapper for a webgl cube texture that is made of 6 images/canvases.
    * You use an index between 0 - 5 to access each of the images. The renderer will transform the
    * images into Canvas objects before being rendered. This is done so that the images are kept at a
    * consistent width and height. Webgl will throw an error if any of the images is a different dimension.
    * You can use the loadImages and setImage function to update the texture.
    */
    var CubeTexture = (function (_super) {
        __extends(CubeTexture, _super);
        /**
        * Creates an instance of the Texture
        * @param {TextureWrapping} wrapS The S wrapping mode for the texture (horizontal)
        * @param {TextureWrapping} wrapT The T wrapping mode for the texture (vertical)
        * @param {TextureFilter} magFilter The filter to use when magnifying the image
        * @param {TextureFilter} minFilter The filter to use when minifying the image
        * @param {TextureFormat} format The texture format
        * @param {TextureType} type The texture type
        * @param {number} anisotropy Higher values give better results but are more expensive
        */
        function CubeTexture(wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
            _super.call(this, 0, 0, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
            this._canvases = new Array(6);
            this._imageLoaders = new Array(6);
            this.requiresBuild = true;
            this._flipY = false;
            this._premultiplyAlpha = false;
            // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
            this._unpackAlignment = 4;
            // Fill the images with the default
            for (var i = 0; i < 6; i++) {
                this._imageLoaders[i] = Trike.TextureBase.defaultImage;
                this._canvases[i] = document.createElement('canvas');
                // Draw the contents of the default image in each canvas
                this._canvases[i].width = Trike.TextureBase.defaultImage.width;
                this._canvases[i].height = Trike.TextureBase.defaultImage.height;
                var context = this._canvases[i].getContext('2d');
                context.drawImage(Trike.TextureBase.defaultImage, 0, 0);
            }
        }
        /**
        * This ensures that all of the images used in the cube texture are a consistent height and width.
        */
        CubeTexture.prototype.resizeImages = function () {
            var maxHeight = 0;
            var maxWidth = 0;
            for (var i = 0; i < 6; i++) {
                if (this._imageLoaders[i].width > maxWidth)
                    maxWidth = this._imageLoaders[i].width;
                if (this._imageLoaders[i].height > maxHeight)
                    maxHeight = this._imageLoaders[i].height;
            }
            // Re-draw each canvas to the max height and width
            for (var i = 0; i < 6; i++) {
                // Resize the canvases so that they are the same size as the biggest image
                this._canvases[i].width = maxWidth;
                this._canvases[i].height = maxHeight;
                var context = this._canvases[i].getContext('2d');
                context.drawImage(this._imageLoaders[i], 0, 0, maxWidth, maxHeight);
            }
            this.width = maxWidth;
            this.height = maxHeight;
        };
        /**
        * Loads an image into this texure.
        * @param {string} url The image file URI we are loading
        * @param {number} index The index of which image we are loading
        * @param {string} crossOrigin The cross origin for the loader. The default is 'anonymous'
        * @returns {CubeTexture}
        */
        CubeTexture.prototype.loadImageAtIndex = function (url, index, crossOrigin) {
            if (crossOrigin === void 0) { crossOrigin = 'anonymous'; }
            if (index > 5)
                throw new Error('You cannot set an index higher than 5. There are 6 sides to a cube (0 is inclusive).');
            // If null or empty use the default image
            if (url === '' || !url) {
                this._imageLoaders[index] = Trike.TextureBase.defaultImage;
                this.requiresBuild = true;
                this.resizeImages();
                return;
            }
            // Create the proxies if not already created
            if (!this._proxyComplete) {
                this._proxyComplete = this._onComplete.bind(this);
                this._proxyProgress = this._onProgress.bind(this);
                this._proxyError = this._onError.bind(this);
            }
            this._imageLoaders[index] = document.createElement('img');
            var loader = this._imageLoaders[index];
            if (crossOrigin !== undefined)
                loader.crossOrigin = crossOrigin;
            loader.addEventListener('load', this._proxyComplete);
            loader.addEventListener('progress', this._proxyProgress);
            loader.addEventListener('error', this._proxyError);
            loader.src = url;
            return this;
        };
        /**
        * Builds the webgl texture and fills the buffer data
        * @param {WebGLRenderingContext} gl The WebGLRenderingContext we are using to compile the texture with
        * @param {number} slot The slot we can use to build this texture. This is provided by the Renderer
        */
        CubeTexture.prototype.compile = function (gl, slot) {
            if (this.webglTexture) {
                gl.deleteTexture(this.webglTexture);
                this.webglTexture = null;
            }
            // Create the texture
            this.webglTexture = gl.createTexture();
            // Bind it so we can set the params
            gl.activeTexture(slot);
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.webglTexture);
            // Now set the texture parameters
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, (this._flipY ? 1 : 0));
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, (this._premultiplyAlpha ? 1 : 0));
            gl.pixelStorei(gl.UNPACK_ALIGNMENT, this._unpackAlignment);
            // Local vars
            var image = this._canvases[0];
            var isImagePowerOfTwo = Trike.Texture.isPowerOfTwo(image.width) && Trike.Texture.isPowerOfTwo(image.height);
            var glFormat = Trike.getGLParam(this.format, gl);
            var glType = Trike.getGLParam(this.type, gl);
            var generateMipmaps = this.generateMipmaps;
            // Sets the different texture filters.
            Trike.Texture.setFilters(this, gl, gl.TEXTURE_CUBE_MAP, isImagePowerOfTwo);
            // Fill the buffers with the texture maps
            for (var i = 0; i < 6; i++)
                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, this._canvases[i]);
            if (this.generateMipmaps && isImagePowerOfTwo)
                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
            this.requiresBuild = false;
            gl.bindTexture(gl.TEXTURE_2D, null);
        };
        /** Each time we make progress on the download */
        CubeTexture.prototype._onProgress = function (e) {
            var index = 0;
            for (var i = 0; i < 6; i++)
                if (this._imageLoaders[i] === e.target) {
                    index = i;
                    break;
                }
            var percentLoaded = e.loaded / e.total * 100;
            this.emit('texture_loader_progress', { texture: this, previousImage: null, progress: percentLoaded, originalEvent: e, index: index });
        };
        /** Error downloading file */
        CubeTexture.prototype._onError = function (e) {
            var imageLoader = null;
            var index = 0;
            for (var i = 0; i < 6; i++)
                if (this._imageLoaders[i] === e.target) {
                    // this._images[i] = e.target;
                    imageLoader = e.target;
                    this._imageLoaders[i] = Trike.TextureBase.defaultImage;
                    index = i;
                    break;
                }
            imageLoader.removeEventListener('load', this._proxyComplete);
            imageLoader.removeEventListener('progress', this._proxyProgress);
            imageLoader.removeEventListener('error', this._proxyError);
            this.emit('texture_loader_error', { texture: this, previousImage: null, progress: 0, originalEvent: e, index: index });
        };
        /** File loaded */
        CubeTexture.prototype._onComplete = function (e) {
            var imageLoader = null;
            var index = 0;
            for (var i = 0; i < 6; i++)
                if (this._imageLoaders[i] === e.target) {
                    this._imageLoaders[i] = e.target;
                    imageLoader = e.target;
                    index = i;
                    break;
                }
            imageLoader.removeEventListener('load', this._proxyComplete);
            imageLoader.removeEventListener('progress', this._proxyProgress);
            imageLoader.removeEventListener('error', this._proxyError);
            this.requiresBuild = true;
            this.resizeImages();
            this.emit('texture_loader_complete', { texture: this, previousImage: null, progress: 100, originalEvent: e, index: index });
        };
        /**
        * Cleans up the references and frees the memory buffers
        */
        CubeTexture.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            var imageLoader;
            for (var i = 0; i < 6; i++) {
                imageLoader = this._imageLoaders[i];
                if (!imageLoader)
                    continue;
                imageLoader.removeEventListener('load', this._proxyComplete);
                imageLoader.removeEventListener('progress', this._proxyProgress);
                imageLoader.removeEventListener('error', this._proxyError);
            }
            this._canvases = null;
            this._imageLoaders = null;
            this._proxyComplete = null;
            this._proxyProgress = null;
            this._proxyError = null;
        };
        return CubeTexture;
    }(Trike.TextureBase));
    Trike.CubeTexture = CubeTexture;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    var NoiseTexture = (function (_super) {
        __extends(NoiseTexture, _super);
        function NoiseTexture(width) {
            if (width === void 0) { width = 1024; }
            var size = width * width;
            var data = new Uint8Array(size);
            // Zero out height data
            for (var i = 0; i < size; i++)
                data[i] = 0;
            var perlin = new Trike.ImprovedNoise();
            var quality = 1;
            var z = Math.random() * 100;
            // Do several passes to get more detail
            for (var iteration = 0; iteration < 4; iteration++) {
                for (var i = 0; i < size; i++) {
                    var x = i % width;
                    var y = Math.floor(i / width);
                    data[i] += Math.abs(perlin.getNoise(x / quality, y / quality, z) * quality);
                }
                quality *= 5;
            }
            _super.call(this, data, width, width, Trike.TextureFormat.AlphaFormat, Trike.TextureType.UnsignedByteType);
        }
        /**
        * This function is called to fill the data of a webgl texture.
        */
        NoiseTexture.prototype.fillTextureBuffer = function (gl, glFormat, glType, isImagePowerOfTwo, mipmaps) {
            _super.prototype.fillTextureBuffer.call(this, gl, glFormat, glType, isImagePowerOfTwo, mipmaps);
        };
        return NoiseTexture;
    }(Trike.DataTexture));
    Trike.NoiseTexture = NoiseTexture;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Base class for all 3d objects
    */
    var Object3D = (function (_super) {
        __extends(Object3D, _super);
        /**
        * Creates a new Object3D instance
        */
        function Object3D() {
            _super.call(this);
            this._castShadows = true;
            this.matrix = new Trike.Matrix4();
            this.worldMatrix = new Trike.Matrix4();
            this.disposed = false;
            this._modelViewMatrix = new Trike.Matrix4();
            this._normalMatrix = new Trike.Matrix3();
            this.parent = null;
            this.children = [];
            this.updateMatrixWorld = true;
            this.updateMatrix = true;
            this.up = new Trike.Vec3(0, 1, 0);
            this.position = new Trike.Vec3();
            this._rotation = new Trike.Euler();
            this.scale = new Trike.Vec3(1, 1, 1);
            this._options = {};
            if (!Object3D._v1) {
                Object3D._v1 = new Trike.Vec3();
                Object3D._v2 = new Trike.Vec3();
            }
        }
        /**
        * Copies the values of the given object into this. Does not copy children, parent or optional variables
        * @param {Object3D} o3d the object to copy from
        * @returns {Object3D}
        */
        Object3D.prototype.copy = function (o3d) {
            this.matrix.copy(o3d.matrix);
            this.worldMatrix.copy(o3d.worldMatrix);
            this.disposed = o3d.disposed;
            this._modelViewMatrix.copy(o3d._modelViewMatrix);
            this._normalMatrix.copy(o3d._normalMatrix);
            this.updateMatrixWorld = o3d.updateMatrixWorld;
            this.updateMatrix = o3d.updateMatrix;
            this.up.copy(o3d.up);
            this.position.copy(o3d.position);
            this._rotation.copy(o3d._rotation);
            this.scale.copy(o3d.scale);
            return this;
        };
        /**
        * Gets or sets if this object can cast shadows
        * @param {number} val
        */
        Object3D.prototype.castShadows = function (val) {
            if (val === undefined)
                return this._castShadows;
            this._castShadows = val;
            return val;
        };
        Object.defineProperty(Object3D.prototype, "rotationX", {
            /**
            * Gets the x rotation in radians
            * @returns {number}
            */
            get: function () { return this._rotation.x; },
            /**
            * Sets the x rotation in radians
            * @param {number} val
            */
            set: function (val) { this._rotation.x = val; this.updateMatrix = true; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "rotationY", {
            /**
            * Gets the y rotation in radians
            * @returns {number}
            */
            get: function () { return this._rotation.y; },
            /**
            * Sets the y rotation in radians
            * @param {number} val
            */
            set: function (val) { this._rotation.y = val; this.updateMatrix = true; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "rotationZ", {
            /**
            * Gets the z rotation in radians
            * @returns {number}
            */
            get: function () { return this._rotation.z; },
            /**
            * Sets the z rotation in radians
            * @param {number} val
            */
            set: function (val) { this._rotation.z = val; this.updateMatrix = true; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scaleX", {
            /**
            * Gets the x scale
            * @returns {number}
            */
            get: function () { return this.scale.x; },
            /**
            * Sets the x scale
            * @param {number} val
            */
            set: function (val) { val = val || 0.00001; this.scale.x = val; this.updateMatrix = true; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scaleY", {
            /**
            * Gets the y scale
            * @returns {number}
            */
            get: function () { return this.scale.y; },
            /**
            * Sets the y scale
            * @param {number} val
            */
            set: function (val) { val = val || 0.00001; this.scale.y = val; this.updateMatrix = true; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "scaleZ", {
            /**
            * Gets the z scale
            * @returns {number}
            */
            get: function () { return this.scale.z; },
            /**
            * Sets the z scale
            * @param {number} val
            */
            set: function (val) { val = val || 0.00001; this.scale.z = val; this.updateMatrix = true; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "positionX", {
            /**
            * Gets the x position
            * @returns {number}
            */
            get: function () { return this.position.x; },
            /**
            * Sets the x position
            * @param {number} val
            */
            set: function (val) { this.position.x = val; this.updateMatrix = true; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "positionY", {
            /**
            * Gets the y position
            * @returns {number}
            */
            get: function () { return this.position.y; },
            /**
            * Sets the y position
            * @param {number} val
            */
            set: function (val) { this.position.y = val; this.updateMatrix = true; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "positionZ", {
            /**
            * Gets the z position
            * @returns {number}
            */
            get: function () { return this.position.z; },
            /**
            * Sets the z position
            * @param {number} val
            */
            set: function (val) { this.position.z = val; this.updateMatrix = true; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "rotation", {
            /**
            * Gets the rotation euluer
            * @returns {Euler}
            */
            get: function () { return this._rotation; },
            /**
            * Sets the rotation euluer
            * @param {Euler} value
            */
            set: function (value) {
                this._rotation = value;
                this._rotation._updateQuaternion();
                this.updateMatrix = true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Object3D.prototype, "quaternion", {
            /**
            * Gets the quaternion of this objects Euler
            * @returns {Quat}
            */
            get: function () { return this._rotation._quaternion; },
            enumerable: true,
            configurable: true
        });
        /**
        * Sets the x, y, z coordinates of the object
        * @param {number} x
        * @param {number} y
        * @param {number} z
        */
        Object3D.prototype.setPosition = function (x, y, z) {
            var p = this.position;
            p.x = x;
            p.y = y;
            p.z = z;
            this.updateMatrix = true;
        };
        /**
        * Sets the x, y, z rotation of the object
        * @param {number} x
        * @param {number} y
        * @param {number} z
        */
        Object3D.prototype.setRotation = function (x, y, z) {
            var r = this._rotation;
            r._x = x;
            r._y = y;
            r._z = z;
            r._updateQuaternion();
            this.updateMatrix = true;
        };
        /**
        * Sets the x, y, z scale of the object
        * @param {number} x
        * @param {number} y
        * @param {number} z
        */
        Object3D.prototype.setScale = function (x, y, z) {
            x = x || 0.00001;
            y = y || 0.00001;
            z = z || 0.00001;
            var s = this.scale;
            s.x = x;
            s.y = y;
            s.z = z;
            this.updateMatrix = true;
        };
        /**
        * Adds a child to this object
        * @param {Object3D} child The child to add
        */
        Object3D.prototype.add = function (child) {
            if (child === this)
                throw new Error('An object can\'t be added as a child of itself');
            if (child.parent)
                child.parent.remove(child);
            child.parent = this;
            this.children.push(child);
            child.updateMatrixWorld = true;
            // add to scene
            var scene = this;
            while (scene.parent)
                scene = scene.parent;
            if (scene !== undefined && scene instanceof Trike.Scene)
                scene._addObject(child);
        };
        /**
        * removes a child from this object
        * @param {Object3D} child The child to remove
        */
        Object3D.prototype.remove = function (child) {
            var index = this.children.indexOf(child);
            if (index !== -1) {
                child.parent = null;
                this.children.splice(index, 1);
            }
            // Remove from scene
            var scene = this;
            while (scene.parent)
                scene = scene.parent;
            if (scene !== undefined && scene instanceof Trike.Scene)
                scene._removeObject(child);
        };
        /**
        * An update call made before the rendering process begins
        * @param {number} totalTime The total number of milliseconds since the start of the app
        * @param {number} delta The delta time since the last update call
        * @param {Camera} camera The camera being for the render
        * @param {Renderer} renderer The renderer used to draw the scene
        */
        Object3D.prototype.update = function (totalTime, delta, camera, renderer) {
            // update children
            var children = this.children;
            for (var i = 0, l = children.length; i < l; i++) {
                children[i].update(totalTime, delta, camera, renderer);
            }
        };
        /**
        * Updates the objects vertices
        * @param {boolean} forceWorldUpdate If true, the world matrices will be forced to update
        * @param {boolean} forceLocalUpdate If true, the local matrices will be forced to update
        */
        Object3D.prototype.updateWorldMatrix = function (forceWorldUpdate, forceLocalUpdate) {
            if (forceWorldUpdate === void 0) { forceWorldUpdate = false; }
            if (forceLocalUpdate === void 0) { forceLocalUpdate = false; }
            if (this.updateMatrix || forceLocalUpdate) {
                this.matrix.compose(this.position, this.quaternion, this.scale);
                this.updateMatrix = false;
                forceWorldUpdate = true;
            }
            if (this.updateMatrixWorld || forceWorldUpdate) {
                var worldMat = this.worldMatrix;
                if (this.parent)
                    worldMat.multiplyMatrices(this.parent.worldMatrix, this.matrix);
                else
                    worldMat.copy(this.matrix);
                this.updateMatrixWorld = false;
                forceWorldUpdate = true;
            }
            // update children
            var children = this.children;
            for (var i = 0, l = children.length; i < l; i++) {
                children[i].updateWorldMatrix(forceWorldUpdate, forceLocalUpdate);
            }
        };
        /**
        * Moves the object in the direction defined by the axis
        * @param {Vec3} axis The direction axis
        * @param {number} distance The amount to move
        * @returns {Object3D}
        */
        Object3D.prototype.translateOnAxis = function (axis, distance) {
            // translate object by distance along axis in object space
            // axis is assumed to be normalized
            var v1 = Object3D._v1.set(0, 0, 0);
            v1.copy(axis);
            v1.applyQuaternion(this.quaternion);
            this.position.add(v1.multiplyScalar(distance));
            return this;
        };
        /**
        * Moves the object along its X axis
        * @param {number} distance The amount to move
        * @returns {Object3D}
        */
        Object3D.prototype.translateX = function (distance) {
            var v1 = Object3D._v2.set(1, 0, 0);
            return this.translateOnAxis(v1, distance);
        };
        /**
        * Moves the object along its Y axis
        * @param {number} distance The amount to move
        * @returns {Object3D}
        */
        Object3D.prototype.translateY = function (distance) {
            var v1 = Object3D._v2.set(0, 1, 0);
            return this.translateOnAxis(v1, distance);
        };
        /**
        * Moves the object along its Z axis
        * @param {number} distance The amount to move
        * @returns {Object3D}
        */
        Object3D.prototype.translateZ = function (distance) {
            var v1 = Object3D._v2.set(0, 0, 1);
            return this.translateOnAxis(v1, distance);
        };
        /**
        * Updates the rotation values to look at a target
        * @param {Vec3} vector the target to look at
        */
        Object3D.prototype.lookAt = function (vector) {
            var m1 = new Trike.Matrix4();
            m1.lookAt(vector, this.position, this.up);
            this.quaternion.setFromRotationMatrix(m1);
            this.updateMatrix = true;
        };
        /**
        * Gets all the children of this node.
        * @param {Array<Object3D>} out Optionally you can pass an array to fill. If none is given an array is created for you.
        * @returns {Array<Object3D>}
        */
        Object3D.prototype.getAllChildren = function (out) {
            if (out === undefined)
                out = [];
            out.push(this);
            var children = this.children;
            for (var i = 0, l = children.length; i < l; i++)
                children[i].getAllChildren(out);
            return out;
        };
        Object.defineProperty(Object3D.prototype, "addedToScene", {
            /**
            * Returns true if the object is added to a scene
            * @returns {boolean}
            */
            get: function () {
                // Check if its added to the stage - if not then do nothing
                var p = this.parent;
                var addedToStage = true;
                while (p) {
                    if (p instanceof Trike.Scene)
                        return true;
                    p = p.parent;
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Creates an option which is associated with this asset. The name of the option must be unique.
        * Use this to add your own custom data
        * @param {string} name the name of the option
        * @param {any} val the value of the option
        */
        Object3D.prototype.createOption = function (name, val) { this._options[name] = val; };
        /**
        * Destroys an option
        * @param {string} name the name of the option to destroy
        */
        Object3D.prototype.removeOption = function (name) { delete this._options[name]; };
        /**
        * Update the value of an option
        * @param {string} name the name of the option
        * @param {any} val the value of the option
        */
        Object3D.prototype.updateOption = function (name, val) { this._options[name] = val; };
        /**
        * Returns the value of an option
        * @param {string} name the name of the option
        * @returns {any} The value of the option
        */
        Object3D.prototype.getOption = function (name) { return this._options[name]; };
        /**
        * Cleans up the object.
        */
        Object3D.prototype.dispose = function () {
            if (this.parent)
                this.parent.remove(this);
            this.disposed = true;
            this._options = null;
        };
        Object3D.defaultEulerOrder = 'XYZ';
        return Object3D;
    }(Trike.EventDispatcher));
    Trike.Object3D = Object3D;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A Mesh object which draws a geometry object using a material
    */
    var Mesh = (function (_super) {
        __extends(Mesh, _super);
        /**
        * Creates a Skybox instance
        * @param {MaterialMulti} material The material used with this mesh
        * @param {Geometry} geometry The geometry to use with this mesh
        */
        function Mesh(material, geometry) {
            _super.call(this);
            this._geometry = geometry;
            this._material = material;
            this.culled = false;
            this._worldSphere = new Trike.Sphere();
            this._worldBox = new Trike.Box3();
            this.updateWorldSphere = true;
            this._visible = true;
            this.pickable = true;
            this.boundsReset = false;
            this.customCulling = false;
            this.sceneCull = true;
            this.buildNumber = -1;
        }
        /**
        * Copies the values of the given mesh
        * @param {Mesh} mesh the mesh to copy from
        * @returns {Object3D}
        */
        Mesh.prototype.copy = function (mesh) {
            _super.prototype.copy.call(this, mesh);
            this._geometry = mesh._geometry;
            this._material = mesh._material;
            this.culled = mesh.culled;
            this._worldSphere.copy(mesh._worldSphere);
            this._worldBox.copy(mesh._worldBox);
            this.updateWorldSphere = mesh.updateWorldSphere;
            this._visible = mesh._visible;
            this.pickable = mesh.pickable;
            this.boundsReset = mesh.boundsReset;
            this.customCulling = mesh.customCulling;
            this.sceneCull = mesh.sceneCull;
            return this;
        };
        /*
        * Called whenever the geometry is updated
        */
        Mesh.prototype.geometryUpdated = function (val) {
            this.updateWorldSphere = true;
            if (!val)
                this.buildNumber = -1;
            else
                this.buildNumber = val.buildCount;
        };
        /*
        * This function is called when customCulling is true. You can perform your own scene culling
        * and return if an object should be culled or not.
        * @param {Camera} camera The camera used to render the scene
        * @param {Frustum} frustum The render target the scene is being drawn to
        * @returns {boolean} Returns false if the mesh must be drawn
        */
        Mesh.prototype.isCulled = function (camera, frustum) { return false; };
        /*
        * This function is called after updating and culling. Its useful for objects
        * that need to sort any geometry before a render call.
        * @param {Camera} camera The camera used to render the scene
        */
        Mesh.prototype.sortGeometry = function (camera) { };
        /*
        * Use this function to perform any pre-renders. Useful if an object needs to do its own render pass before a
        * the render call begins.
        * @param {Scene} scene The scene  being rendered
        * @param {Camera} camera The camera beinf used to render the scene
        * @param {RenderTarget} renderTarget The render target the scene is being drawn to
        * @param {Renderer} renderer The renderer being used to draw the scene
        * @param {boolean} Returns false if an error occurred
        */
        Mesh.prototype.prepRender = function (scene, camera, renderTarget, renderer) { return true; };
        /*
        * Use this function to perform any pre-renders (Called before the solid draws).
        * @param {Scene} scene The scene  being rendered
        * @param {Camera} camera The camera beinf used to render the scene
        * @param {RenderTarget} renderTarget The render target the scene is being drawn to
        * @param {Renderer} renderer The renderer being used to draw the scene
        * @param {boolean} Returns false if an error occurred
        */
        Mesh.prototype.prepRenderSolids = function (scene, camera, renderTarget, renderer) { return true; };
        /*
        * Called just before we render the mesh. The mesh would have passed culling and already be updated.
        * A good place to update custom uniforms.
        * @param {Renderer} renderer The renderer used to draw the scene
        * @param {RenderPass} renderPass The render pass associated with this call
        */
        Mesh.prototype.preRender = function (renderer, renderPass) { };
        /*
        * Called just after we render the mesh
        * @param {WebGLRenderingContext} gl The webgl context
        * @param {RenderPass} renderPass The render pass associated with this call
        */
        Mesh.prototype.postRender = function (gl, renderPass) { };
        /**
        * Updates the world matrix as well as updating the world sphere and bounding boxes.
        * @param {boolean} forceWorldUpdate If true, the world matrices will be forced to update
        * @param {boolean} forceLocalUpdate If true, the local matrices will be forced to update
        */
        Mesh.prototype.updateWorldMatrix = function (forceWorldUpdate, forceLocalUpdate) {
            if (forceWorldUpdate === void 0) { forceWorldUpdate = false; }
            if (forceLocalUpdate === void 0) { forceLocalUpdate = false; }
            this.boundsReset = false;
            var geometry = this._geometry;
            if (geometry) {
                if (forceWorldUpdate || this.updateMatrixWorld || this.updateMatrix || this.updateWorldSphere) {
                    _super.prototype.updateWorldMatrix.call(this, forceWorldUpdate, forceLocalUpdate);
                    this._worldSphere.copy(geometry.boundingSphere);
                    this._worldSphere.applyMatrix4(this.worldMatrix);
                    this._worldBox.copy(geometry.boundingBox);
                    this._worldBox.applyMatrix4(this.worldMatrix);
                    this.boundsReset = true;
                }
                else
                    _super.prototype.updateWorldMatrix.call(this, forceWorldUpdate, forceLocalUpdate);
            }
            else
                _super.prototype.updateWorldMatrix.call(this, forceWorldUpdate, forceLocalUpdate);
        };
        /**
        * Cleans up the object.
        */
        Mesh.prototype.dispose = function () {
            this._geometry = null;
            this._material = null;
            _super.prototype.dispose.call(this);
        };
        /**
        * Use this function to replace the material of this mesh
        * @param {MaterialMulti} val
        */
        Mesh.prototype.setMaterial = function (val) {
            this._material = val;
        };
        /**
        * Use this function to replace one geometry with another
        * @param {Geometry} val
        * @returns {boolean}
        */
        Mesh.prototype.setGeometry = function (val) {
            this._geometry = val;
            // this.updateWorldSphere = true;
            this.buildNumber = -1;
        };
        Object.defineProperty(Mesh.prototype, "visible", {
            /**
            * Gets if the mesh is visible. This will propagate to all child nodes
            * @returns {boolean}
            */
            get: function () { return this._visible; },
            /**
            * Sets if the mesh is visible. This will propagate to all child nodes
            * @param {boolean} val
            */
            set: function (val) {
                this._visible = val;
                var children = this.children;
                for (var i = 0, len = children.length; i < len; i++)
                    if (children[i] instanceof Mesh)
                        children[i].visible = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "geometry", {
            /**
            * Gets the geometry of the mesh. If you want to set a new geometry then use the setGeometry function
            * @returns {Geometry}
            */
            get: function () { return this._geometry; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "material", {
            /**
            * Gets the material associated with this mesh
            * @returns {MaterialMulti}
            */
            get: function () {
                return this._material;
            },
            enumerable: true,
            configurable: true
        });
        return Mesh;
    }(Trike.Object3D));
    Trike.Mesh = Mesh;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A Mesh object which draws a animated geometry object using a material. Skinned meshes are made up
    * by a skeleton of bones.
    * Each vertex in a skinned mesh is influenced by a max of 4 bones. Each vertex therefore
    * has 4 corresponding skin indexes and 4 weight influences. When the vertex position is
    * computed in the shader it fetches the 4 bone matrices assigned to it looking at the indices
    * (from _boneMatrices stored in a texture) and
    * multiples itself with each of the matrices stored there by the corresponding 'weight' or influence.
    * See http://ogldev.atspace.co.uk/www/tutorial38/tutorial38.html for a more detailed explanation.
    */
    var MeshSkinned = (function (_super) {
        __extends(MeshSkinned, _super);
        function MeshSkinned(material, geometry) {
            _super.call(this, material, geometry);
            this._bones = new Array();
            this._boneInverses = new Array();
            this._boneMatrices = null;
            this._boneTextureWidth = 0;
            this._boneTextureHeight = 0;
            this._curGeomBuild = -1;
            this._boneTexture;
            this._animations = new Array();
            this._time = 0;
            if (!MeshSkinned.indentityMatrix) {
                MeshSkinned.indentityMatrix = new Trike.Matrix4();
                MeshSkinned._offsetMatrix = new Trike.Matrix4();
            }
        }
        /**
        * An update call made before the rendering process begins
        * @param {number} totalTime The total number of milliseconds since the start of the app
        * @param {number} delta The delta time since the last update call
        * @param {Camera} camera The camera being for the render
        * @param {Renderer} renderer The renderer used to draw the scene
        */
        MeshSkinned.prototype.update = function (totalTime, delta, camera, renderer) {
            _super.prototype.update.call(this, totalTime, delta, camera, renderer);
            if (!this.geometry)
                return;
            // If the geometry was re-built, then we likely need to re-build the bones too
            if (this.geometry.buildCount !== this._curGeomBuild)
                this.setupBones();
            // update children
            var animations = this._animations;
            for (var i = 0, l = animations.length; i < l; i++)
                animations[i].update(delta);
        };
        /*
        * Called just before we render the mesh. The mesh would have passed culling and already be updated.
        * A good place to update custom uniforms.
        * @param {Renderer} renderer The renderer used to draw the scene
        * @param {RenderPass} renderPass The render pass associated with this call
        */
        MeshSkinned.prototype.preRender = function (renderer, renderPass) {
            _super.prototype.preRender.call(this, renderer, renderPass);
            var mat = this._material;
            if (mat && mat.skinning) {
                mat.setUniform('boneTexture', this._boneTexture, true);
                mat.setUniform('boneTextureWidth', this._boneTextureWidth, true);
                mat.setUniform('boneTextureHeight', this._boneTextureHeight, true);
            }
        };
        MeshSkinned.prototype.getBoneByName = function (name) {
            var bones = this._bones;
            for (var i = 0, l = bones.length; i < l; i++)
                if (bones[i].name === name)
                    return bones[i];
            return null;
        };
        /**
        * Clears the animation data for the object
        */
        MeshSkinned.prototype.cleanup = function () {
            var bones = this._bones;
            // Clean up existing bones / objects
            for (var i = 0, l = bones.length; i < l; i++)
                bones[i].dispose();
            bones.splice(0, bones.length);
            this._boneInverses.splice(0, this._boneInverses.length);
            // Clean up animations
            var animations = this._animations;
            for (var i = 0, l = animations.length; i < l; i++)
                animations[i].dispose();
            this._animations.splice(0, this._animations.length);
            this._boneTextureWidth = 0;
            this._boneTextureHeight = 0;
            if (this._boneTexture)
                this._boneTexture.dispose();
            this._boneTexture = null;
        };
        /** Use this function to replace one geometry with another */
        MeshSkinned.prototype.setGeometry = function (val) {
            this._curGeomBuild = -1; // Reset the geom ID
            _super.prototype.setGeometry.call(this, val);
            this.setupBones();
        };
        /***
        * Helper function to create the bone data from the geometry
        */
        MeshSkinned.prototype.setupBones = function () {
            var b, bone, gbone, p, q, s;
            var geometry = this.geometry, bones = this._bones;
            this.cleanup();
            if (!geometry)
                return;
            this._curGeomBuild = geometry.buildCount;
            // Create new bones and assign them to this mesh
            if (geometry && geometry.bones !== undefined && geometry.bones.length > 0) {
                // First create each of the bones and associate them to this mesh
                for (b = 0; b < geometry.bones.length; b++) {
                    bone = this.addBone();
                    bone.setFromBoneInfo(geometry.bones[b]);
                }
                // Now that we have each of the bones, we add them to either the mesh or the parent bone
                for (b = 0; b < bones.length; b++) {
                    gbone = geometry.bones[b];
                    bone = bones[b];
                    if (gbone.parent === -1)
                        this.add(bone);
                    else
                        bones[gbone.parent].add(bone);
                }
                var nBones = this._bones.length;
                // We store the bone matrices in the RGBA values of a texture.
                // This obviously requires that the user has a video card that supports float textures
                //
                // layout (1 matrix = 4 pixels)
                // RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
                // with  8x8  pixel texture max   16 bones  (8 * 8  / 4)
                //       16x16 pixel texture max   64 bones (16 * 16 / 4)
                //       32x32 pixel texture max  256 bones (32 * 32 / 4)
                //       64x64 pixel texture max 1024 bones (64 * 64 / 4)
                var size = void 0;
                if (nBones > 256)
                    size = 64;
                else if (nBones > 64)
                    size = 32;
                else if (nBones > 16)
                    size = 16;
                else
                    size = 8;
                this._boneTextureWidth = size;
                this._boneTextureHeight = size;
                this._boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
                // Create the texure with the data array which represents the matrices
                this._boneTexture = new Trike.DataTexture(this._boneMatrices, size, size);
                // Set texture properties
                this._boneTexture.minFilter = Trike.TextureFilter.Nearest;
                this._boneTexture.magFilter = Trike.TextureFilter.Nearest;
                this._boneTexture.format = Trike.TextureFormat.RGBAFormat;
                this._boneTexture.type = Trike.TextureType.FloatType;
                this._boneTexture.generateMipmaps = false;
                this._boneTexture.flipY = false;
                this.pose();
            }
        };
        /**
        * Updates the world matrix as well as updating the world sphere and bounding boxes.
        */
        MeshSkinned.prototype.updateWorldMatrix = function (force) {
            if (force === void 0) { force = false; }
            // First update the matrices (including bones)
            // Note that the bones handle updateWorldMatrix slightly differently.
            _super.prototype.updateWorldMatrix.call(this, force);
            if (!this._geometry || !this._material || this.geometry.requiresBuild || !this._boneTexture)
                return;
            // flatten bone matrices to array
            var bones = this._bones;
            var boneInverses = this._boneInverses;
            var offsetMatrix = MeshSkinned._offsetMatrix;
            var boneMatrices = this._boneMatrices;
            for (var b = 0, bl = bones.length; b < bl; b++) {
                // compute the offset between the current and the original transform;
                // TODO: we could get rid of this multiplication step if the skinMatrix
                // was already representing the offset; however, this requires some
                // major changes to the animation system
                offsetMatrix.multiplyMatrices(bones[b].skinMatrix, boneInverses[b]);
                offsetMatrix.flattenToArrayOffset(boneMatrices, b * 16);
            }
            // We've updated the matrices in the texture data, so we need to update the texture.
            this._boneTexture.requiresBuild = true;
        };
        /**
        * Fetches a bone by its name
        * @returns {Bone} Returns the bone or null if one cant be found
        */
        MeshSkinned.prototype.getBone = function (name) {
            var toRet = null;
            var bones = this._bones;
            for (var i = 0, l = bones.length; i < l; i++)
                if (bones[i].name === name)
                    return bones[i];
            return toRet;
        };
        /** Adds a new bone to the mesh */
        MeshSkinned.prototype.addBone = function (bone) {
            if (bone === undefined)
                bone = new Trike.Bone(this);
            this._bones.push(bone);
            return bone;
        };
        MeshSkinned.prototype.pose = function () {
            _super.prototype.updateWorldMatrix.call(this, true);
            this.normalizeSkinWeights();
            // We need to get the bone inverse matrices. This is the same as getting their 'pose' state
            // before being moved around.
            this._boneInverses = [];
            var bones = this._bones;
            for (var b = 0, bl = bones.length; b < bl; b++) {
                var inverse = new Trike.Matrix4();
                inverse.getInverse(bones[b].skinMatrix);
                this._boneInverses.push(inverse);
            }
        };
        /**
        * Adds an animation to the mesh
        * @param {string} name The name of the animation to add. Trike will look for this animation within the geometry
        * @param {number} weight The amount of influence this animation has on the mesh.
        * @param {boolean} looped If true, the animation will loop indefinately
        */
        MeshSkinned.prototype.addAnimation = function (name, weight, looped) {
            if (weight === void 0) { weight = 1.0; }
            if (looped === void 0) { looped = true; }
            if (!this.geometry)
                return null;
            var animSet = this.geometry.getAnimationSet(name);
            if (!animSet)
                return null;
            var toRet = new Trike.AnimationPlayer(this, this.geometry.getAnimationSet(name), name);
            toRet.weight = weight;
            toRet.loop = looped;
            this._animations.push(toRet);
            return toRet;
        };
        /**
        * Adds an animation to the mesh
        * @param {string} name The name of the animation to remove.
        */
        MeshSkinned.prototype.removeAnimation = function (name) {
            var animations = this._animations;
            for (var i = 0, l = animations.length; i < l; i++)
                if (animations[i].name === name) {
                    animations[i].dispose();
                    animations.splice(i, 1);
                    return;
                }
        };
        /**
        * The skin weights must be between 0 and 1
        */
        MeshSkinned.prototype.normalizeSkinWeights = function () {
            var skinWeights = null;
            var skinIndices = null;
            if (this.geometry.buffers[Trike.AttributeType.SKIN_WEIGHT])
                skinWeights = this.geometry.buffers[Trike.AttributeType.SKIN_WEIGHT].data;
            if (this.geometry.buffers[Trike.AttributeType.SKIN_INDEX])
                skinIndices = this.geometry.buffers[Trike.AttributeType.SKIN_INDEX].data;
            if (!skinIndices || !skinWeights) {
                console.error('A skinned mesh must have both indices as well as weights in the geometry.');
                return;
            }
            for (var i = 0; i < skinIndices.length; i++) {
                var sw = skinWeights[i];
                var scale = 1.0 / sw.lengthManhattan();
                if (scale !== Infinity)
                    sw.multiplyScalar(scale);
            }
            this.geometry.dirtyBuffers.push(this.geometry.buffers[Trike.AttributeType.SKIN_WEIGHT]);
        };
        /**
        * Cleans up the mesh for disposal
        */
        MeshSkinned.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.cleanup();
            this._bones = null;
            this._boneInverses = null;
            this._boneMatrices = null;
            this._boneTexture = null;
            this._animations = null;
        };
        Object.defineProperty(MeshSkinned.prototype, "boneTextureWidth", {
            get: function () { return this._boneTextureWidth; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MeshSkinned.prototype, "boneTextureHeight", {
            get: function () { return this._boneTextureHeight; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MeshSkinned.prototype, "boneTexture", {
            get: function () { return this._boneTexture; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MeshSkinned.prototype, "bones", {
            get: function () { return this._bones; },
            enumerable: true,
            configurable: true
        });
        return MeshSkinned;
    }(Trike.Mesh));
    Trike.MeshSkinned = MeshSkinned;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Mirrors are 3D objects typically associated with MirrorMesh objects that hold and prepare a mirror camera,
    * its texture matrix, clip plane and a render target. The mirror render target is used to store the rendering
    * of a reflected scene. The texture matrix and clip plane are used in other materials to properly draw the
    * reflected scenes. Typically you wont work with a mirror, instead use the mirror mesh.
    */
    var Mirror = (function (_super) {
        __extends(Mirror, _super);
        /**
        * Creates a new mirror instance
        * @param {IReflectiveMaterial} material The reflective material
        * @param {number} width The width of the render target
        * @param {number} height The height of the render target
        */
        function Mirror(material, width, height) {
            if (width === void 0) { width = 1024; }
            if (height === void 0) { height = 1024; }
            _super.call(this);
            this.material = material;
            this._width = width;
            this._height = height;
            this._plane = new Trike.Plane();
            this._normal = new Trike.Vec3(0, 0, 1);
            this._mirrorTarget = new Trike.Vec3(0, 0, 0);
            this._mirrorWorldPosition = new Trike.Vec3();
            this._cameraWorldPosition = new Trike.Vec3();
            this._rotationMatrix = new Trike.Matrix4();
            this._lookAtPosition = new Trike.Vec3(0, 0, -1);
            this._mirrowCamPosition = new Trike.Vec3();
            this.clipPlane = new Trike.Vec4();
            this.textureMatrix = new Trike.Matrix4();
            this.passCollection = new Trike.PassCollection();
            this.passCollection.initialize(width, height);
            this.mirrorCamera = new Trike.CameraPerspective();
            this.renderTarget = new Trike.RenderTarget(width, height, Trike.TextureType.HalfFloatType);
            if (!Trike.MathUtils.isPowerOfTwo(width) || !Trike.MathUtils.isPowerOfTwo(height))
                this.renderTarget.generateMipmaps = false;
        }
        /**
        * Prepares the mirror camera and its texture matrix and clip plane
        * @param {CameraPerspective} camera The camera we are rending the current scene with
        */
        Mirror.prototype.updateTextureMatrix = function (camera) {
            var sign = Trike.MathUtils.sign, normal = this._normal, camWorldPos = this._cameraWorldPosition, mirrorWorldPos = this._mirrorWorldPosition, mirrorCamera = this.mirrorCamera, rotMatrix = this._rotationMatrix, lookAt = this._lookAtPosition, textureMatrix = this.textureMatrix, plane = this._plane, clipPlane = this.clipPlane, worldMat = this.worldMatrix, mirrowCamPosition = this._mirrowCamPosition, up = this.up, mirrorTarget = this._mirrorTarget;
            mirrorCamera.copy(camera);
            mirrorWorldPos.getPositionFromMatrix(worldMat);
            camWorldPos.getPositionFromMatrix(camera.worldMatrix);
            rotMatrix.extractRotation(worldMat);
            // Get the direction of the mirror in world space
            normal.set(0, 0, 1);
            normal.applyMatrix4(rotMatrix);
            mirrowCamPosition.copy(mirrorWorldPos).sub(camWorldPos);
            mirrowCamPosition.reflect(normal).negate();
            mirrowCamPosition.add(mirrorWorldPos);
            rotMatrix.extractRotation(camera.worldMatrix);
            lookAt.set(0, 0, -1);
            lookAt.applyMatrix4(rotMatrix);
            lookAt.add(camWorldPos);
            mirrorTarget.copy(mirrorWorldPos).sub(lookAt);
            mirrorTarget.reflect(normal).negate();
            mirrorTarget.add(mirrorWorldPos);
            up.set(0, -1, 0);
            up.applyMatrix4(rotMatrix);
            up.reflect(normal).negate();
            mirrorCamera.position.copy(mirrowCamPosition);
            mirrorCamera.up = up;
            mirrorCamera.lookAt(mirrorTarget);
            mirrorCamera.updateProjectionMatrix();
            mirrorCamera.updateWorldMatrix();
            mirrorCamera.matrixWorldInverse.getInverse(mirrorCamera.worldMatrix);
            // Update the texture matrix
            textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
            textureMatrix.multiply(mirrorCamera.projectionMatrix);
            textureMatrix.multiply(mirrorCamera.matrixWorldInverse);
            // Update the clip plane
            plane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPos);
            plane.applyMatrix4(mirrorCamera.matrixWorldInverse);
            clipPlane.set(plane.normal.x, plane.normal.y, plane.normal.z, plane.constant);
        };
        /**
        * Resizes the mirror so that it uses
        * @param {number} val
        */
        Mirror.prototype.resize = function (val) {
            this.passCollection.setSize(val, val);
            this.renderTarget.resize(val, val);
        };
        /**
        * Cleans up the object.
        */
        Mirror.prototype.dispose = function () {
            this.renderTarget.dispose();
            this.passCollection.dispose();
            this.mirrorCamera.dispose();
            this._plane = null;
            this._normal = null;
            this._mirrorWorldPosition = null;
            this._mirrorTarget = null;
            this._cameraWorldPosition = null;
            this._rotationMatrix = null;
            this._lookAtPosition = null;
            this._mirrowCamPosition = null;
            this.passCollection = null;
            this.mirrorCamera = null;
            this.renderTarget = null;
            this.textureMatrix = null;
            this.clipPlane = null;
            this.material = null;
            _super.prototype.dispose.call(this);
        };
        return Mirror;
    }(Trike.Object3D));
    Trike.Mirror = Mirror;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A mesh that renders the scene reflected into its mirror render target. This is then applied to its
    * mirror reflective material as a texture
    */
    var MirrorMesh = (function (_super) {
        __extends(MirrorMesh, _super);
        /**
        * Creates an instance of the mirror mesh
        */
        function MirrorMesh(material, geom) {
            _super.call(this, material, geom);
            this._mirror = new Trike.Mirror(material);
            this.add(this._mirror);
        }
        /**
        * Use this function to replace the material of this mesh
        * @param {MaterialMulti} val
        */
        MirrorMesh.prototype.setMaterial = function (material) {
            _super.prototype.setMaterial.call(this, material);
            this._mirror.material = material;
        };
        Object.defineProperty(MirrorMesh.prototype, "mirror", {
            /**
            * Gets the mesh's mirror
            * @returns {Mirror}
            */
            get: function () { return this._mirror; },
            enumerable: true,
            configurable: true
        });
        /**
        * Cleans up the object.
        */
        MirrorMesh.prototype.dispose = function () {
            this._mirror.dispose();
            this._mirror = null;
            _super.prototype.dispose.call(this);
        };
        return MirrorMesh;
    }(Trike.Mesh));
    Trike.MirrorMesh = MirrorMesh;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Describes the type of blending to be done on the cloud.
    */
    (function (CloudBlendMode) {
        CloudBlendMode[CloudBlendMode["NONE"] = 0] = "NONE";
        CloudBlendMode[CloudBlendMode["NORMAL"] = 1] = "NORMAL";
        CloudBlendMode[CloudBlendMode["ADD"] = 2] = "ADD";
        CloudBlendMode[CloudBlendMode["MULTIPLY"] = 3] = "MULTIPLY";
        CloudBlendMode[CloudBlendMode["PREMULTIPLIED_ALPHA"] = 4] = "PREMULTIPLIED_ALPHA";
    })(Trike.CloudBlendMode || (Trike.CloudBlendMode = {}));
    var CloudBlendMode = Trike.CloudBlendMode;
    /**
    * A class to draw each vertex of geometry as a screen aligned quad or 'point'. Each vertex is the center of the quad.
    * Point clouds are useful for drawing things like particle systems. The size, rotation and opacity of each quad can also
    * be controlled. To do this, you must enable the particleSizesEnabled and particleRotationsEnabled and call generatePoints.
    * This fills the geometry buffers with data that can then be edited.
    */
    var PointCloud = (function (_super) {
        __extends(PointCloud, _super);
        /**
        * Creates an instance of the point cloud
        * @param {MaterialPointCloud} material [Optional] The MaterialPointCloud to draw the particles with
        * @param {number} numParticles [Optional] The number of initial points
        * @param {boolean} particleRotations [Optional] If true, each point will be rotated
        * @param {boolean} particleSizes [Optional] If true, each point will be sized
        * @param {boolean} particleAlpha [Optional] If true, each point will be a different opacity
        */
        function PointCloud(material, numParticles, particleRotations, particleSizes, particleAlpha) {
            if (numParticles === void 0) { numParticles = 100; }
            if (particleRotations === void 0) { particleRotations = true; }
            if (particleSizes === void 0) { particleSizes = true; }
            if (particleAlpha === void 0) { particleAlpha = true; }
            material = material || new Trike.MaterialPointCloud();
            if (!PointCloud._meshes) {
                PointCloud._meshes = [];
                PointCloud._vec = new Trike.Vec3();
                PointCloud._numClouds = 0;
                PointCloud._matrix = new Trike.Matrix4();
                PointCloud._sortArray = [];
            }
            _super.call(this, material, new Trike.GeometryPoints());
            this._particleSizes = particleSizes;
            this._particleRotations = particleRotations;
            this._particleAlpha = particleAlpha;
            this._blendMode = CloudBlendMode.NONE;
            this.sortParticles = false;
            this._blendAlpha = 1;
            this._emitter = null;
            this.invWorld = new Trike.Matrix4();
            PointCloud._numClouds++;
            this._mapPass = new Trike.RenderPass(null, null, Trike.PassType.PointsTextureMap);
            this._normalPass = new Trike.RenderPass(null, null, Trike.PassType.PointsNormalMap);
            this._mapTarget = new Trike.RenderTarget(512, 512, Trike.TextureType.UnsignedByteType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Nearest, Trike.TextureFilter.Nearest, Trike.TextureFormat.RGBAFormat, 1, false, false);
            this._normalTarget = new Trike.RenderTarget(512, 512, Trike.TextureType.UnsignedByteType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Nearest, Trike.TextureFilter.Nearest, Trike.TextureFormat.RGBAFormat, 1, false, false);
            // Generate initial buffers
            this.generatePoints(numParticles);
        }
        /*
        * Sorts the particles from farthest to closest
        * @param {Array<number>} a
        * @param {Array<number>} b
        */
        PointCloud.prototype.numericalSort = function (a, b) {
            return b[0] - a[0];
        };
        /*
        * Sorts the buffers of the point cloud so that the farthest point from the camera is drawn first
        * while the one closest to the camera is drawn last
        * @param {Camera} camera The camera used to render the scene
        */
        PointCloud.prototype.sortGeometry = function (camera) {
            if (this.culled || this.sortParticles === false)
                return;
            var m = PointCloud._matrix;
            var v = PointCloud._vec;
            var sortArray = PointCloud._sortArray;
            sortArray.splice(0, sortArray.length);
            m.copy(camera._projScreenMatrix);
            m.multiply(this.worldMatrix);
            var buffers = this._geometry.buffers;
            var verts = buffers[Trike.AttributeType.POSITION].data;
            var vl = verts.length;
            for (var i = 0; i < vl; i++) {
                v.copy(verts[i]);
                v.applyProjection(m);
                sortArray[i] = [v.z, i];
            }
            // Uses a fast sorting algorithm to sort the particles based on their distance to the camera
            sortArray = Trike.AdaptiveSort.sort(sortArray, 0);
            // We need to reverse the sort as its from closest to farthest
            sortArray = sortArray.reverse();
            var data;
            var datum;
            var geometry = this._geometry;
            var buffer;
            var vl2 = vl * 2;
            var bl = buffers.length;
            // For each of the geom buffers, add the datums of the sorted array
            // to the end of the buffers.
            for (var i = 0, l = sortArray.length; i < l; i++) {
                for (var b = 0; b < bl; b++) {
                    buffer = buffers[b];
                    if (!buffer)
                        continue;
                    data = buffer.data;
                    datum = data[sortArray[i][1]];
                    data.push(datum);
                }
            }
            // do the same for any emitter buffers, if present
            if (this._emitter)
                this._emitter.sort(sortArray);
            // The buffers are now exactly twice as big as before, but the later
            // half of the buffers are the sorted datums, so we simply slice the
            // the first half
            for (var b = 0; b < bl; b++) {
                buffer = buffers[b];
                if (!buffer)
                    continue;
                buffer.data = buffer.data.slice(vl, vl2);
                if (geometry.dirtyBuffers.indexOf(buffer) === -1)
                    geometry.dirtyBuffers.push(buffer);
            }
        };
        /*
        * Use this function to perform any pre-renders. Useful if an object needs to do its own render pass before a
        * the render call begins.
        * @param {Scene} scene The scene  being rendered
        * @param {Camera} camera The camera beinf used to render the scene
        * @param {RenderTarget} renderTarget The render target the scene is being drawn to
        * @param {Renderer} renderer The renderer being used to draw the scene
        * @param {boolean} Returns false if an error occurred
        */
        PointCloud.prototype.prepRenderSolids = function (scene, camera, renderTarget, renderer) {
            if (this.culled)
                return true;
            // Get the material and size of the render target
            var material = this._material;
            // If there is no map, then there is no point in doing the prep render
            if (!material.map)
                return true;
            var rendererW = renderer.width, rendererH = renderer.height, mapTarget = this._mapTarget, normalTarget = this._normalTarget;
            // We have a map and pass. Just make sure the sizes are the same as the renderer may
            // have been resized
            if (mapTarget.width !== rendererW || mapTarget.height !== rendererH) {
                mapTarget.resize(rendererW, rendererH);
                normalTarget.resize(rendererW, rendererH);
            }
            // If no blending, then we use the map as normal.
            if (this._blendMode === CloudBlendMode.NONE)
                return true;
            var clearColor = renderer.autoClearColor;
            var clearDepth = renderer.autoClearDepth;
            var clearStencil = renderer.autoClearStencil;
            renderer.autoClearDepth = true;
            renderer.autoClearStencil = true;
            renderer.autoClearColor = true;
            renderer.ssq.updateWorldMatrix(true);
            PointCloud._meshes.splice(0, 1, this);
            // Render the points onto the map render target
            this._mapPass.renderTarget = mapTarget;
            if (!renderer.renderObjects(PointCloud._meshes, camera, this._mapPass))
                return false;
            this._normalPass.renderTarget = normalTarget;
            if (!renderer.renderObjects(PointCloud._meshes, camera, this._normalPass))
                return false;
            renderer.autoClearColor = clearColor;
            renderer.autoClearDepth = clearDepth;
            renderer.autoClearStencil = clearStencil;
            return true;
        };
        /**
        * Updates the world matrix as well as updating the world sphere and bounding boxes.
        * @param {boolean} forceWorldUpdate If true, the world matrices will be forced to update
        * @param {boolean} forceLocalUpdate If true, the local matrices will be forced to update
        */
        PointCloud.prototype.updateWorldMatrix = function (forceWorldUpdate, forceLocalUpdate) {
            if (forceWorldUpdate === void 0) { forceWorldUpdate = false; }
            if (forceLocalUpdate === void 0) { forceLocalUpdate = false; }
            var updateInverse = false;
            if (forceWorldUpdate || forceLocalUpdate || this.updateMatrixWorld || this.updateMatrix)
                updateInverse = true;
            _super.prototype.updateWorldMatrix.call(this, forceWorldUpdate, forceLocalUpdate);
            if (forceWorldUpdate)
                this.invWorld.getInverse(this.invWorld.extractRotation(this.worldMatrix));
        };
        /*
        * Called just before we render the mesh. The mesh would have passed culling and already be updated.
        * A good place to update custom uniforms.
        * @param {Renderer} renderer The renderer used to draw the scene
        * @param {RenderPass} renderPass The render pass associated with this call
        */
        PointCloud.prototype.preRender = function (renderer, pass) {
            _super.prototype.preRender.call(this, renderer, pass);
            var material = this._material;
            // If this is the normal depth pass
            if (pass.passType === Trike.PassType.GBuffer2 && material.uvCoordinates() === Trike.UVCoordinates.ScreenBased && material.map()) {
                // We have to override the way depth is recorded for point clouds.
                // The cloud uses screen quads which use a map that is blended however the quads cannot
                // represent this. for example if a light is in the middle of the cloud, the quads in front
                // would be darker than those at the back. But this looks bad because the points are one
                // blended object.
                // To solve this we get the view space center of the particle system and subtract its radius.
                // This value is essentially the further quad away from the camera. We normalized this by dividing
                // The value to get it in a value from 0 to 1 so that it can play nice with the depth pass.
                // We then assign this back value to all particle quads (making the depth essentially uniform
                // accross the whole cloud).
                // Finally, to make the depths a bit more varied, we subtract the normalized alpha value of the
                // blended texture multiplied by its normalized radius. That means each pixel starts with a value
                // of the furthest depth, and then depth is added based on the alpha in the diffuse map.
                // Get the center of the point cloud in view space
                var tempVS = PointCloud._vec;
                tempVS.getPositionFromMatrix(this.worldMatrix);
                tempVS.applyMatrix4(pass.camera.matrixWorldInverse);
                // normalize the depth to 0 - 1
                tempVS.z = Math.abs(tempVS.z - this._worldSphere.radius) / (pass.camera.far - pass.camera.near);
                // Get the normalized radius
                var normalizedRadius = (this._worldSphere.radius / pass.camera.far);
                material.materials[Trike.PassType.GBuffer].setUniform('map', this._mapTarget, false);
                material.materials[Trike.PassType.GBuffer2].setUniform('map', this._mapTarget, false);
                material.materials[Trike.PassType.ShadowLightPass].setUniform('map', this._mapTarget, false);
                material.materials[Trike.PassType.GBuffer2].setUniform('normalMap', this._normalTarget, false);
                material.uniformDepth(tempVS.z);
                material.normalizedRadius(normalizedRadius);
            }
        };
        /*
        * Updates the boundaries of the geometry
        */
        PointCloud.prototype.updateBounds = function () {
            this.geometry.computeBoundingSphere();
            this.updateWorldSphere = true;
        };
        /**
        * An update call made before the rendering process begins
        * @param {number} totalTime The total number of milliseconds since the start of the app
        * @param {number} delta The delta time since the last update call
        * @param {Camera} camera The camera being for the render
        * @param {Renderer} renderer The renderer used to draw the scene
        */
        PointCloud.prototype.update = function (totalTime, delta, camera, renderer) {
            _super.prototype.update.call(this, totalTime, delta, camera, renderer);
            if (this._emitter)
                this._emitter.update(totalTime, delta);
        };
        /*
        * Generates the quads, rotations and sizes of each point of this point cloud. The rotations, sizes and
        * opacity are also generated based on whether or not the particleSizesEnabled and particleRotationsEnabled
        * are true.
        * @param {number} numPoints the number of points to create (default is 100)
        */
        PointCloud.prototype.generatePoints = function (numPoints) {
            if (numPoints === void 0) { numPoints = 100; }
            var geom = this._geometry;
            // Assume the geometry has all attributes. Remove them all
            geom.removeAttribute(Trike.AttributeType.POSITION);
            geom.removeAttribute(Trike.AttributeType.SCALE);
            geom.removeAttribute(Trike.AttributeType.ROTATION);
            geom.removeAttribute(Trike.AttributeType.ALPHA);
            var material = this._material;
            // Remove any defines
            material.removeDefine(Trike.ShaderDefines.ATTR_SIZE);
            material.removeDefine(Trike.ShaderDefines.ATTR_ROTATION);
            material.removeDefine(Trike.ShaderDefines.ATTR_ALPHA);
            material.removeAttribute(Trike.AttributeType.ROTATION);
            material.removeAttribute(Trike.AttributeType.ALPHA);
            material.removeAttribute(Trike.AttributeType.SCALE);
            // Now for each point create the buffer entries
            var pts = [], rotations = (this._particleRotations ? [] : null), scales = (this._particleSizes ? [] : null), alphas = (this._particleAlpha ? [] : null);
            for (var i = 0, l = numPoints; i < l; i++) {
                pts.push(new Trike.Vec3());
                if (this._particleRotations)
                    rotations.push(0);
                if (this._particleSizes)
                    scales.push(1);
                if (this._particleAlpha)
                    alphas.push(1);
            }
            geom.addAttributes(new Trike.GeometryBuffer(pts, 3, Trike.AttributeType.POSITION));
            if (this._particleRotations) {
                geom.addAttributes(new Trike.GeometryBuffer(rotations, 1, Trike.AttributeType.ROTATION));
                material.addDefine(Trike.ShaderDefines.ATTR_ROTATION);
                material.addAttribute(new Trike.AttributeVar('rotation', Trike.AttributeType.ROTATION));
            }
            if (this._particleSizes) {
                geom.addAttributes(new Trike.GeometryBuffer(scales, 1, Trike.AttributeType.SCALE));
                material.addDefine(Trike.ShaderDefines.ATTR_SIZE);
                material.addAttribute(new Trike.AttributeVar('size', Trike.AttributeType.SCALE));
            }
            if (this._particleAlpha) {
                geom.addAttributes(new Trike.GeometryBuffer(alphas, 1, Trike.AttributeType.ALPHA));
                material.addDefine(Trike.ShaderDefines.ATTR_ALPHA);
                material.addAttribute(new Trike.AttributeVar('alpha', Trike.AttributeType.ALPHA));
            }
            // Update the emitter
            if (this._emitter)
                this._emitter.generatePoints(numPoints);
            this.updateBounds();
        };
        Object.defineProperty(PointCloud.prototype, "emitter", {
            /*
            * Gets the emitter of this point cloud
            * @returns {Emitter}
            */
            get: function () { return this._emitter; },
            /*
            * Sets the emitter of this point cloud
            * @param {Emitter} val
            */
            set: function (val) {
                if (val) {
                    if (val.pointCloud)
                        val.pointCloud.emitter = null;
                    val.pointCloud = this;
                }
                this._emitter = val;
                if (val)
                    val.generatePoints(this.numPoints);
                this.updateBounds();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointCloud.prototype, "particleAlphasEnabled", {
            /**
            * Gets if each point has an individual alpha
            * @returns {boolean}
            */
            get: function () { return this._particleAlpha; },
            /**
            * Sets if each point has an individual alpha
            * @param {boolean} val
            */
            set: function (val) {
                if (this._particleAlpha === val)
                    return;
                this._particleAlpha = val;
                this.generatePoints(this._geometry.buffers[Trike.AttributeType.POSITION].data.length);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointCloud.prototype, "particleSizesEnabled", {
            /**
            * Gets if each point has an individual size
            * @returns {boolean}
            */
            get: function () { return this._particleSizes; },
            /**
            * Sets if each point has an individual size
            * @param {boolean} val
            */
            set: function (val) {
                if (this._particleSizes === val)
                    return;
                this._particleSizes = val;
                this.generatePoints(this._geometry.buffers[Trike.AttributeType.POSITION].data.length);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointCloud.prototype, "particleRotationsEnabled", {
            /**
            * Gets if each point has an individual rotation
            * @returns {boolean}
            */
            get: function () { return this._particleRotations; },
            /**
            * Sets if each point has an individual rotation
            * @param {boolean} val
            */
            set: function (val) {
                if (this._particleRotations === val)
                    return;
                this._particleRotations = val;
                this.generatePoints(this._geometry.buffers[Trike.AttributeType.POSITION].data.length);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointCloud.prototype, "blendMode", {
            /**
            * Gets the type of blending used on the map.
            * @returns {CloudBlendMode}
            */
            get: function () { return this._blendMode; },
            /**
            * Describes the type of blending to be done on the cloud. If CloudBlendMode.NONE
            * then any diffuse map texture is applied to each point as is. If any other type
            * of blending, then the cloud has to render a separate pass to combine the quad
            * maps into a single blended texture.
            * @param {CloudBlendMode} val
            */
            set: function (val) {
                var cloudMat = this._material;
                var material = this._material;
                this._blendMode = val;
                if (val === CloudBlendMode.NONE)
                    cloudMat.uvCoordinates(Trike.UVCoordinates.PerPoint);
                else {
                    cloudMat.uvCoordinates(Trike.UVCoordinates.ScreenBased);
                    if (val === CloudBlendMode.ADD)
                        material.materials[Trike.PassType.PointsTextureMap].blendMode = Trike.BlendMode.Additive;
                    else if (val === CloudBlendMode.MULTIPLY)
                        material.materials[Trike.PassType.PointsTextureMap].blendMode = Trike.BlendMode.Multiplication;
                    else if (val === CloudBlendMode.NORMAL)
                        material.materials[Trike.PassType.PointsTextureMap].blendMode = Trike.BlendMode.Normal;
                    else if (val === CloudBlendMode.PREMULTIPLIED_ALPHA)
                        material.materials[Trike.PassType.PointsTextureMap].blendMode = Trike.BlendMode.PremultipliedAlpha;
                }
                // Reset the map uniforms
                if (cloudMat.map) {
                    var map = cloudMat.map;
                    cloudMat.map = null;
                    cloudMat.map = map;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointCloud.prototype, "particleScale", {
            /*
            * Gets the scale multiplier for each particle
            * @returns {number}
            */
            get: function () { return this._material._uniforms['particleScale'].value; },
            /*
            * Sets the scale multiplier for each particle
            * @param {number} val
            */
            set: function (val) {
                this._material.setUniform('particleScale', val, true);
                this._geometry.pointsScale = val;
                this.updateBounds();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PointCloud.prototype, "numPoints", {
            /*
            * Gets the number of points for this cloud
            * @returns {number}
            */
            get: function () {
                var geom = this._geometry;
                if (!geom)
                    return 0;
                var pBuffer = geom.buffers[Trike.AttributeType.POSITION];
                if (pBuffer)
                    return pBuffer.data.length;
                return 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Cleans up any references or resources
        */
        PointCloud.prototype.dispose = function () {
            PointCloud._numClouds--;
            if (PointCloud._numClouds === 0) {
                PointCloud._meshes = null;
                PointCloud._vec = null;
            }
            if (this._mapPass) {
                this._mapPass.dispose();
                this._normalPass.dispose();
                this._mapPass = null;
                this._normalPass = null;
            }
            this._blendMode = null;
            this._geometry.dispose();
            this._material.dispose();
            this._emitter.pointCloud = null;
            this._emitter = null;
            _super.prototype.dispose.call(this);
        };
        return PointCloud;
    }(Trike.Mesh));
    Trike.PointCloud = PointCloud;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * The emitter class is used to control the geometry buffers of point clouds. Each emitter
    * is responsible for the birth position, velocity and lifespan of each point cloud particle.
    * Sub classes of the Emitter will specialize in setting the birth position of each particle
    * by overriding the updateLocation function. The updateLocation is called whenever a particle
    * lifespan goes over the maxLife (which it does as it ages).
    * Each emitter has an array of optional modules that are used to modify
    * the position, and other, buffers of the point cloud geometry over time.
    */
    var Emitter = (function () {
        /**
        * Creates an  instance of this emitter
        * @param {number} maxLife The max lifetime of each particle in milliseconds
        * @param {PointCloud} cloud The point cloud associated with this emitter
        */
        function Emitter(maxLife, cloud) {
            if (maxLife === void 0) { maxLife = 2000; }
            this._modules = [];
            this._lifetimes = null;
            this._velocities = null;
            this.maxLife = maxLife;
            this._numPoints = 0;
            this.pointCloud = cloud;
            this._lifeSorter = [];
            this._velSorter = [];
            this.boundingBox = new Trike.Box3();
            this.frameSpeed = 10;
            this.randomizeLifespan = true;
            this.worldSpace = true;
            this.loop = true;
            this._loopArray = [];
            this._v = new Trike.Vec3();
        }
        /**
        * Updates the position of a point so that its back within the boundary of the emitter.
        * The updateLocation is called whenever a particle lifespan goes over the maxLife.
        * @param {Vec3} position The position vector to update
        */
        Emitter.prototype.updateLocation = function (position) { };
        /**
        * An update call made before the rendering process begins
        * @param {number} totalTime The total number of milliseconds since the start of the app
        * @param {number} delta The delta time since the last update call
        */
        Emitter.prototype.update = function (totalTime, delta) {
            var pointCloud = this._pointCloud, mods = this._modules, lifetimes = this._lifetimes, velocities = this._velocities, geom = pointCloud._geometry, pBuffer = geom.buffers[Trike.AttributeType.POSITION], maxLife = this.maxLife, verts = pBuffer.data, frameSpeed = this.frameSpeed, worldSpace = this.worldSpace, velocityLocal = this._v, invWorldMat = pointCloud.invWorld, loop = this.loop, loopArray = this._loopArray;
            var position, updatePBuffer = false, i3 = 0, life = 0;
            // Update each of the modules
            for (var i = 0, l = mods.length; i < l; i++)
                if (mods[i].update(totalTime, delta, lifetimes, velocities, loopArray, this))
                    updatePBuffer = true;
            // Age each of the particles
            for (var i = 0, l = lifetimes.length; i < l; i++) {
                i3 = i * 3;
                life = lifetimes[i];
                life += frameSpeed;
                if (life > maxLife) {
                    life = 0;
                    loopArray[i] = loop;
                }
                lifetimes[i] = life;
                if (updatePBuffer) {
                    position = verts[i];
                    if (life === 0) {
                        velocities[i3] = 0;
                        velocities[i3 + 1] = 0;
                        velocities[i3 + 2] = 0;
                        this.updateLocation(position);
                    }
                    else {
                        if (worldSpace) {
                            velocityLocal.set(velocities[i3], velocities[i3 + 1], velocities[i3 + 2]);
                            velocityLocal.applyMatrix4(invWorldMat);
                            position.x += velocityLocal.x;
                            position.y += velocityLocal.y;
                            position.z += velocityLocal.z;
                        }
                        else {
                            position.x += velocities[i3];
                            position.y += velocities[i3 + 1];
                            position.z += velocities[i3 + 2];
                        }
                    }
                }
            }
            // Put the position buffer in the firty queue if it needs to be updated
            if (updatePBuffer && geom.dirtyBuffers.indexOf(pBuffer) === -1) {
                pointCloud.updateWorldSphere = true;
                geom.dirtyBuffers.push(pBuffer);
            }
        };
        /*
        * Cleans up all class references
        */
        Emitter.prototype.dispose = function () {
            this._modules = null;
            this._lifetimes = null;
            this._velocities = null;
            this._pointCloud = null;
            this._lifeSorter = null;
            this._velSorter = null;
        };
        /*
        * If the point cloud is sorted, it will call this function. Any internal buffers representing vertex buffers
        * will need to be sorted as well. The array passed to this function represents the sorted order. Each item is
        * an array of [depth, originalIndex]. You should really only focus on the originalIndex, which is the index
        * of the item before it was sorted.
        * @param {Array<Array<number>>} sortArray An array representing the new sorted order. Each item is
        * an array of [depth, originalIndex]
        */
        Emitter.prototype.sort = function (sortArray) {
            var lifeSorter = this._lifeSorter, velSorter = this._velSorter, velocities = this._velocities, lifetimes = this._lifetimes, loopArray = this._loopArray;
            var prevIndex, vi = 0;
            lifeSorter.splice(0, lifeSorter.length);
            velSorter.splice(0, velSorter.length);
            var l = sortArray.length;
            for (var i = 0; i < l; i++) {
                prevIndex = sortArray[i][1];
                vi = prevIndex * 3;
                loopArray.push(loopArray[prevIndex]);
                lifeSorter.push(lifetimes[prevIndex]);
                velSorter.push(velocities[vi]);
                velSorter.push(velocities[vi + 1]);
                velSorter.push(velocities[vi + 2]);
            }
            lifetimes.set(lifeSorter, 0);
            velocities.set(velSorter, 0);
            loopArray.splice(l, l * 2);
        };
        /*
        * When a point cloud is updated with new points, this function needs to be called so that it
        * can update its internal buffers
        * @param {number} numPoints the number of points to create
        */
        Emitter.prototype.generatePoints = function (numPoints) {
            if (numPoints === 0) {
                this._lifetimes = null;
                this._velocities = null;
                return;
            }
            this._numPoints = numPoints;
            numPoints = this._numPoints;
            this._lifetimes = new Float32Array(numPoints);
            this._loopArray = new Array(numPoints);
            this._velocities = new Float32Array(numPoints * 3);
            this.reset();
        };
        /*
        * Resets the emitters particles arrays
        */
        Emitter.prototype.reset = function () {
            if (!this._pointCloud || this._numPoints === 0)
                return;
            var numPoints = this._numPoints, lifetimes = this._lifetimes, velocities = this._velocities, geom = this._pointCloud._geometry, pBuffer = geom.buffers[Trike.AttributeType.POSITION], verts = pBuffer.data, loopArray = this._loopArray, maxLife = this.maxLife, randomizeLifespan = this.randomizeLifespan;
            var i3 = 0;
            // Age each of the particles
            for (var i = 0, l = lifetimes.length; i < l; i++) {
                i3 = i * 3;
                if (randomizeLifespan)
                    lifetimes[i] = Math.random() * maxLife;
                else
                    lifetimes[i] = 0;
                loopArray[i] = true;
                velocities[i3] = 0;
                velocities[i3 + 1] = 0;
                velocities[i3 + 2] = 0;
                this.updateLocation(verts[i]);
            }
            // Put the position buffer in the firty queue if it needs to be updated
            if (geom.dirtyBuffers.indexOf(pBuffer) === -1)
                geom.dirtyBuffers.push(pBuffer);
        };
        Object.defineProperty(Emitter.prototype, "pointCloud", {
            /*
            * Gets the point cloud of this emitter
            * @returns {PointCloud}
            */
            get: function () { return this._pointCloud; },
            /*
            * Sets the point cloud of this emitter
            * @param {PointCloud}
            */
            set: function (val) {
                this._pointCloud = val;
                if (val)
                    this.generatePoints(val.numPoints);
                else {
                    this._lifetimes = null;
                    this._velocities = null;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Emitter.prototype, "modules", {
            /*
            * Gets the modules affecting this emitter
            * @returns {Array<Module>}
            */
            get: function () { return this._modules; },
            enumerable: true,
            configurable: true
        });
        /*
        * Adds a module to this emitter
        * @param {Module} val The module to add
        */
        Emitter.prototype.addModule = function (val) {
            var modules = this._modules;
            if (modules.indexOf(val) === -1)
                modules.push(val);
        };
        /*
        * Removes a module from this emitter
        * @param {Module} val The module to remove
        */
        Emitter.prototype.removeModule = function (val) {
            var modules = this._modules;
            if (modules.indexOf(val) !== -1)
                modules.splice(modules.indexOf(val), 1);
        };
        /*
        * Removes all modules from this emitter
        */
        Emitter.prototype.clearModules = function () {
            var modules = this._modules;
            modules.splice(0, modules.length);
        };
        return Emitter;
    }());
    Trike.Emitter = Emitter;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * The cube emitter will place each particle in a cube centered at its position and using its dimensions
    */
    var EmitterCube = (function (_super) {
        __extends(EmitterCube, _super);
        /**
        * Creates an  instance of this emitter
        * @param {number} width The width of this emitter
        * @param {number} height The width of this emitter
        * @param {number} depth The width of this emitter
        * @param {number} maxLife The lifetime of each particle in milliseconds
        * @param {PointCloud} cloud The point cloud associated with this emitter
        */
        function EmitterCube(width, height, depth, maxLife, cloud) {
            if (maxLife === void 0) { maxLife = 2000; }
            _super.call(this, maxLife, cloud);
            this.width = width;
            this.height = height;
            this.depth = depth;
        }
        /**
        * Updates the position of a point so that its back within the boundary of the emitter
        * @param {Vec3} position The position vector to update
        */
        EmitterCube.prototype.updateLocation = function (position) {
            Trike.Random.pointInsideBox(this.width, this.height, this.depth, null, position);
        };
        /*
        * Cleans up all class references
        */
        EmitterCube.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        return EmitterCube;
    }(Trike.Emitter));
    Trike.EmitterCube = EmitterCube;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * The sphere emitter will place each particle in a sphere centered at its position and radius
    */
    var EmitterSphere = (function (_super) {
        __extends(EmitterSphere, _super);
        /**
        * Creates an  instance of this emitter
        * @param {number} radius The radius of this emitter
        * @param {number} maxLife The lifetime of each particle in milliseconds
        * @param {PointCloud} cloud The point cloud associated with this emitter
        */
        function EmitterSphere(radius, maxLife, cloud) {
            if (maxLife === void 0) { maxLife = 2000; }
            _super.call(this, maxLife, cloud);
            this.radius = radius;
        }
        /**
        * Updates the position of a point so that its back within the boundary of the emitter
        * @param {Vec3} position The position vector to update
        */
        EmitterSphere.prototype.updateLocation = function (position) {
            Trike.Random.pointInsideSphere(this.radius, null, position);
        };
        /*
        * Cleans up all class references
        */
        EmitterSphere.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        return EmitterSphere;
    }(Trike.Emitter));
    Trike.EmitterSphere = EmitterSphere;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * The base class for all emitter modules. Each module manipulates a point cloud buffer
    * typically over time.
    */
    var Module = (function () {
        /*
        * Creates an instance of a module
        * @param {Emitter} parent The parent Emitter this belongs to
        */
        function Module() {
        }
        /*
        * Updates buffers of the parent emitters point cloud, based on the life of each particle
        * @param {number} totalTime The total time in milliseconds from the start of the application
        * @param {number} delta The delta time since the last frame update
        * @param {Float32Array} lifetimes The lifespan of each point of the emitter's point cloud. The length of this array matches the number of points in the cloud.
        * @param {Float32Array} velocities The velocities of each point of the emitter's point cloud. The length of this array matches the number of points in the cloud times by 3.
        * @param {Array<boolean>} loopArray An array indicating if a specific particle has reached the end of its track
        * @param {Emitter} The emitter calling this module
        * @returns {boolean} If false is returned, then the position buffer will not be updated. If true, it will.
        */
        Module.prototype.update = function (totalTime, delta, lifetimes, velocities, loopArray, parent) {
            return false;
        };
        /*
        * Cleans up all class references
        */
        Module.prototype.dispose = function () {
        };
        return Module;
    }());
    Trike.Module = Module;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * The acceleration module is used to accelerate or deccelerate the point cloud velocities over time
    */
    var ModuleAcceleration = (function (_super) {
        __extends(ModuleAcceleration, _super);
        /*
        * Creates an instance of a module
        */
        function ModuleAcceleration() {
            _super.call(this);
            this.acceleration = new Trike.Vec3();
        }
        /*/*
        * Updates buffers of the parent emitters point cloud, based on the life of each particle
        * @param {number} totalTime The total time in milliseconds from the start of the application
        * @param {number} delta The delta time since the last frame update
        * @param {Float32Array} lifetimes The lifespan of each point of the emitter's point cloud. The length of this array matches the number of points in the cloud.
        * @param {Float32Array} velocities The velocities of each point of the emitter's point cloud. The length of this array matches the number of points in the cloud times by 3.
        * @param {Array<boolean>} loopArray An array indicating if a specific particle has reached the end of its track
        * @param {Emitter} The emitter calling this module
        * @returns {boolean} If false is returned, then the position buffer will not be updated. If true, it will.
        */
        ModuleAcceleration.prototype.update = function (totalTime, delta, lifetimes, velocities, loopArray, parent) {
            var acceleration = this.acceleration;
            var vi = 0;
            var updateBuffers = false;
            for (var i = 0, l = lifetimes.length; i < l; i++) {
                if (loopArray[i] === false)
                    continue;
                vi = i * 3;
                velocities[vi] *= acceleration.x;
                velocities[vi + 1] *= acceleration.y;
                velocities[vi + 2] *= acceleration.z;
                updateBuffers = true;
            }
            return updateBuffers;
        };
        /*
        * Cleans up all class references
        */
        ModuleAcceleration.prototype.dispose = function () {
            this.acceleration = null;
            _super.prototype.dispose.call(this);
        };
        return ModuleAcceleration;
    }(Trike.Module));
    Trike.ModuleAcceleration = ModuleAcceleration;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * The acceleration module is used to change the opacity of each point cloud particle over time
    */
    var ModuleOpacity = (function (_super) {
        __extends(ModuleOpacity, _super);
        /*
        * Creates an instance of a module
        */
        function ModuleOpacity() {
            _super.call(this);
            this.birthOpacity = 1;
            this.deathOpacity = 0;
            this.velocityScale = 0;
            this._v = new Trike.Vec3();
        }
        /*
        * Updates buffers of the parent emitters point cloud, based on the life of each particle
        * @param {number} totalTime The total time in milliseconds from the start of the application
        * @param {number} delta The delta time since the last frame update
        * @param {Float32Array} lifetimes The lifespan of each point of the emitter's point cloud. The length of this array matches the number of points in the cloud.
        * @param {Float32Array} velocities The velocities of each point of the emitter's point cloud. The length of this array matches the number of points in the cloud times by 3.
        * @param {Array<boolean>} loopArray An array indicating if a specific particle has reached the end of its track
        * @param {Emitter} The emitter calling this module
        * @returns {boolean} If false is returned, then the position buffer will not be updated. If true, it will.
        */
        ModuleOpacity.prototype.update = function (totalTime, delta, lifetimes, velocities, loopArray, parent) {
            var geom = parent._pointCloud._geometry, opacityBuffer = geom.buffers[Trike.AttributeType.ALPHA];
            if (!opacityBuffer)
                return false;
            var opacityData = opacityBuffer.data, birthOpacity = this.birthOpacity, deathOpacity = this.deathOpacity, d = parent.frameSpeed, maxlife = parent.maxLife, velocityScale = this.velocityScale;
            var normalizedLife = 0, vi = 0, velocity = this._v, velocityFactor = 0, updateBuffers = false;
            for (var i = 0, l = lifetimes.length; i < l; i++) {
                if (loopArray[i] === false)
                    continue;
                updateBuffers = true;
                if (lifetimes[i] + d <= maxlife)
                    normalizedLife = lifetimes[i] / maxlife;
                else
                    normalizedLife = 0;
                if (velocityScale) {
                    vi = i * 3;
                    velocity.set(velocities[vi], velocities[vi + 1], velocities[vi + 2]);
                    velocityFactor = velocityScale * velocity.length();
                    opacityData[i] = Trike.Interpolater.interpolate(birthOpacity * velocityFactor, deathOpacity * velocityFactor, normalizedLife);
                }
                else
                    opacityData[i] = Trike.Interpolater.interpolate(birthOpacity, deathOpacity, normalizedLife);
            }
            if (updateBuffers && geom.dirtyBuffers.indexOf(opacityBuffer) === -1)
                geom.dirtyBuffers.push(opacityBuffer);
            return false;
        };
        /*
        * Cleans up all class references
        */
        ModuleOpacity.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        return ModuleOpacity;
    }(Trike.Module));
    Trike.ModuleOpacity = ModuleOpacity;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * The size module is used to change the size of each point cloud particle over time
    */
    var ModuleSize = (function (_super) {
        __extends(ModuleSize, _super);
        /*
        * Creates an instance of a module
        */
        function ModuleSize() {
            _super.call(this);
            this.birthSize = 1;
            this.deathSize = 0;
            this.velocityScale = 0;
            this._v = new Trike.Vec3();
        }
        /*
        * Updates buffers of the parent emitters point cloud, based on the life of each particle
        * @param {number} totalTime The total time in milliseconds from the start of the application
        * @param {number} delta The delta time since the last frame update
        * @param {Float32Array} lifetimes The lifespan of each point of the emitter's point cloud. The length of this array matches the number of points in the cloud.
        * @param {Float32Array} velocities The velocities of each point of the emitter's point cloud. The length of this array matches the number of points in the cloud times by 3.
        * @param {Array<boolean>} loopArray An array indicating if a specific particle has reached the end of its track
        * @param {Emitter} The emitter calling this module
        * @returns {boolean} If false is returned, then the position buffer will not be updated. If true, it will.
        */
        ModuleSize.prototype.update = function (totalTime, delta, lifetimes, velocities, loopArray, parent) {
            var geom = parent._pointCloud._geometry, sizeBuffer = geom.buffers[Trike.AttributeType.SCALE];
            if (!sizeBuffer)
                return false;
            var sizeData = sizeBuffer.data, birthSize = this.birthSize, deathSize = this.deathSize, d = parent.frameSpeed, maxlife = parent.maxLife, velocityScale = this.velocityScale, velocity = this._v;
            var vi = 0, normalizedLife = 0, velocityFactor = 0, updateBuffers = false;
            for (var i = 0, l = lifetimes.length; i < l; i++) {
                if (loopArray[i] === false)
                    continue;
                updateBuffers = true;
                if (lifetimes[i] + d <= maxlife)
                    normalizedLife = lifetimes[i] / maxlife;
                else
                    normalizedLife = 0;
                if (velocityScale) {
                    vi = i * 3;
                    velocity.set(velocities[vi], velocities[vi + 1], velocities[vi + 2]);
                    velocityFactor = velocityScale * velocity.length();
                    sizeData[i] = Trike.Interpolater.interpolate(birthSize * velocityFactor, deathSize * velocityFactor, normalizedLife);
                }
                else
                    sizeData[i] = Trike.Interpolater.interpolate(birthSize, deathSize, normalizedLife);
            }
            if (loopArray && geom.dirtyBuffers.indexOf(sizeBuffer) === -1)
                geom.dirtyBuffers.push(sizeBuffer);
            return false;
        };
        /*
        * Cleans up all class references
        */
        ModuleSize.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        return ModuleSize;
    }(Trike.Module));
    Trike.ModuleSize = ModuleSize;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * The rotation module is used to change the rotation of each point cloud particle over time
    */
    var ModuleRotation = (function (_super) {
        __extends(ModuleRotation, _super);
        /*
        * Creates an instance of a module
        */
        function ModuleRotation() {
            _super.call(this);
            this.birthRotation = 0;
            this.deathRotation = Math.PI * 2;
            this.randomize = true;
            this.velBirthScale = 1;
            this.velDeathScale = 1;
            this.velocityScale = 0;
            this._v = new Trike.Vec3();
        }
        /*
        * Updates buffers of the parent emitters point cloud, based on the life of each particle
        * @param {number} totalTime The total time in milliseconds from the start of the application
        * @param {number} delta The delta time since the last frame update
        * @param {Float32Array} lifetimes The lifespan of each point of the emitter's point cloud. The length of this array matches the number of points in the cloud.
        * @param {Float32Array} velocities The velocities of each point of the emitter's point cloud. The length of this array matches the number of points in the cloud times by 3.
        * @param {Array<boolean>} loopArray An array indicating if a specific particle has reached the end of its track
        * @param {Emitter} The emitter calling this module
        * @returns {boolean} If false is returned, then the position buffer will not be updated. If true, it will.
        */
        ModuleRotation.prototype.update = function (totalTime, delta, lifetimes, velocities, loopArray, parent) {
            var geom = parent._pointCloud._geometry, rotationBuffer = geom.buffers[Trike.AttributeType.ROTATION];
            if (!rotationBuffer)
                return false;
            var rotationData = rotationBuffer.data, birthRotation = this.birthRotation, deathRotation = this.deathRotation, d = parent.frameSpeed, deltaRot = deathRotation - birthRotation, maxlife = parent.maxLife, timeFrac = delta / parent.maxLife, normalizedLife = 0, velocityScale = this.velocityScale, velocity = this._v;
            var vi = 0, velocityFactor = 0, updateBuffers = false;
            for (var i = 0, l = lifetimes.length; i < l; i++) {
                if (loopArray[i] === false)
                    continue;
                updateBuffers = true;
                if (this.randomize && lifetimes[i] + d > maxlife)
                    rotationData[i] = (Math.random() * Math.PI * 4) - Math.PI * 2;
                if (velocityScale) {
                    vi = i * 3;
                    velocity.set(velocities[vi], velocities[vi + 1], velocities[vi + 2]);
                    velocityFactor = velocityScale * velocity.length();
                    if (rotationData[i] > 0)
                        rotationData[i] += deltaRot * timeFrac * velocityFactor;
                    else
                        rotationData[i] -= deltaRot * timeFrac * velocityFactor;
                }
                else {
                    if (rotationData[i] > 0)
                        rotationData[i] += deltaRot * timeFrac;
                    else
                        rotationData[i] -= deltaRot * timeFrac;
                }
            }
            if (updateBuffers && geom.dirtyBuffers.indexOf(rotationBuffer) === -1)
                geom.dirtyBuffers.push(rotationBuffer);
            return false;
        };
        /*
        * Cleans up all class references
        */
        ModuleRotation.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        return ModuleRotation;
    }(Trike.Module));
    Trike.ModuleRotation = ModuleRotation;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    (function (ForceType) {
        ForceType[ForceType["Spherical"] = 0] = "Spherical";
        ForceType[ForceType["Cone"] = 1] = "Cone";
        ForceType[ForceType["Box"] = 2] = "Box";
        ForceType[ForceType["Directional"] = 3] = "Directional";
    })(Trike.ForceType || (Trike.ForceType = {}));
    var ForceType = Trike.ForceType;
    /**
    * Sets the velocity/initial force of each particle
    */
    var ModuleForce = (function (_super) {
        __extends(ModuleForce, _super);
        /*
        * Creates an instance of a module
        */
        function ModuleForce(forceType) {
            if (forceType === void 0) { forceType = ForceType.Directional; }
            _super.call(this);
            this.scale = 1;
            this.direction = new Trike.Vec3(0, 0, 1);
            this.coneDirection = new Trike.Vec3(0, 0, 1);
            this.coneAngle = Math.PI * 0.5;
            this._v = new Trike.Vec3(0, 0, 0);
            this._v2 = new Trike.Vec3(0, 0, 0);
            this._q = new Trike.Quat();
            this.forceType = forceType;
        }
        /*
        * Updates buffers of the parent emitters point cloud, based on the life of each particle
        * @param {number} totalTime The total time in milliseconds from the start of the application
        * @param {number} delta The delta time since the last frame update
        * @param {Float32Array} lifetimes The lifespan of each point of the emitter's point cloud. The length of this array matches the number of points in the cloud.
        * @param {Float32Array} velocities The velocities of each point of the emitter's point cloud. The length of this array matches the number of points in the cloud times by 3.
        * @param {Array<boolean>} loopArray An array indicating if a specific particle has reached the end of its track
        * @param {Emitter} The emitter calling this module
        * @returns {boolean} If false is returned, then the position buffer will not be updated. If true, it will.
        */
        ModuleForce.prototype.update = function (totalTime, delta, lifetimes, velocities, loopArray, parent) {
            var scale = this.scale, d = parent.frameSpeed, maxlife = parent.maxLife, v = this._v, v2 = this._v2, q = this._q, forceType = this.forceType, direction = this.direction, coneDirection = this.coneDirection, coneAngle = this.coneAngle;
            var vi = 0, updateBuffers = false;
            for (var i = 0, l = lifetimes.length; i < l; i++) {
                if (loopArray[i] === false)
                    continue;
                vi = i * 3;
                updateBuffers = true;
                if (lifetimes[i] === 0) {
                    if (forceType === ForceType.Directional) {
                        velocities[vi] += direction.x * scale;
                        velocities[vi + 1] += direction.y * scale;
                        velocities[vi + 2] += direction.z * scale;
                    }
                    else if (forceType === ForceType.Spherical) {
                        Trike.Random.pointOnSphere(1, null, v);
                        velocities[vi] += v.x * scale;
                        velocities[vi + 1] += v.y * scale;
                        velocities[vi + 2] += v.z * scale;
                    }
                    else if (forceType === ForceType.Box) {
                        Trike.Random.pointInsideBox(1, 1, 1, v.set(0, 0, 0), v);
                        velocities[vi] += v.x * scale;
                        velocities[vi + 1] += v.y * scale;
                        velocities[vi + 2] += v.z * scale;
                    }
                    else if (forceType === ForceType.Cone) {
                        // Create random axis
                        v.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
                        v.normalize();
                        v2.copy(coneDirection);
                        v2.applyQuaternion(q.setFromAxisAngle(v, coneAngle));
                        velocities[vi] += v2.x * scale;
                        velocities[vi + 1] += v2.y * scale;
                        velocities[vi + 2] += v2.z * scale;
                    }
                }
            }
            return updateBuffers;
        };
        /*
        * Cleans up all class references
        */
        ModuleForce.prototype.dispose = function () {
            this.direction = null;
            this._v = null;
            this._q = null;
            _super.prototype.dispose.call(this);
        };
        return ModuleForce;
    }(Trike.Module));
    Trike.ModuleForce = ModuleForce;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Creates a mesh with a plane that is always facing the camera. This is achieved through the MaterialSprite shader.
    */
    var Sprite = (function (_super) {
        __extends(Sprite, _super);
        /**
        * Creates an instance
        */
        function Sprite(material) {
            if (!Sprite._geom)
                Sprite._geom = new Trike.GeometryPlane(1, 1, 1, 1);
            Sprite._count++;
            _super.call(this, material, Sprite._geom);
        }
        /**
        * Cleans up the sprite and removes any outstanding geometry
        */
        Sprite.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            Sprite._count--;
            if (Sprite._count === 0) {
                Sprite._geom.dispose();
                Sprite._geom = null;
            }
        };
        Sprite._count = 0;
        return Sprite;
    }(Trike.Mesh));
    Trike.Sprite = Sprite;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    (function (Edge) {
        Edge[Edge["NONE"] = 0] = "NONE";
        Edge[Edge["TOP"] = 1] = "TOP";
        Edge[Edge["LEFT"] = 2] = "LEFT";
        Edge[Edge["BOTTOM"] = 4] = "BOTTOM";
        Edge[Edge["RIGHT"] = 8] = "RIGHT";
    })(Trike.Edge || (Trike.Edge = {}));
    var Edge = Trike.Edge;
    /**
    * The viewspace grid class is used to draw a collection of viewspace tiles.
    * Each grid uses a common geometry and material to draw each of its tiles. The shader
    * of the material is updated with position and scale on each prerender based on the values of each tile.
    * Each grid can optionally have a heightmap from where it gets its height data.
    */
    var ViewspaceGrid = (function (_super) {
        __extends(ViewspaceGrid, _super);
        /**
        * Creates an instance of the terrain class
        * @param {IGridMaterial} material The material associated with this grid
        * @param {number} drawDistance Determines how far off the terrain is drawn. Its recommended you use multiples of 2 as it can cause holes in the terrain if you don't
        * @param {number} levels The number of resolution levels. Closer levels are higher density mesh triangulations and far ones are less.
        * @param {number} resolution The resolution of the terrain tiles. This must be a multiple of 2. Anything lower than 16 or greater than 128 is not advisable.
        */
        function ViewspaceGrid(material, drawDistance, levels, resolution) {
            if (drawDistance === void 0) { drawDistance = 1024; }
            if (levels === void 0) { levels = 4; }
            if (resolution === void 0) { resolution = 32; }
            _super.call(this);
            this._material = material;
            this._drawDistance = drawDistance;
            this._levels = levels;
            this._resolution = resolution;
            this._tiles = new Array();
            this._altitude = 50;
            this._heightOffset = 0;
            this._material.altitude(this._altitude);
            this._material.heightOffset(this._heightOffset);
            // set the resolution and builds the geometry
            this.resolution(resolution);
            this._picker = new Trike.ViewspaceGridPicker(this);
        }
        /**
        * Gets or sets if this object can cast shadows
        * @param {number} val
        */
        ViewspaceGrid.prototype.castShadows = function (val) {
            if (val === undefined)
                return _super.prototype.castShadows.call(this, val);
            var tiles = this._tiles;
            for (var i = 0, l = tiles.length; i < l; i++)
                tiles[i].castShadows(val);
            return _super.prototype.castShadows.call(this, val);
        };
        /**
        * Gets or sets how far off the grid is drawn. Its recommended you use multiples of 2 as it can cause holes in the terrain if you don't
        * @param {number} val [Optional]
        * @returns {number}
        */
        ViewspaceGrid.prototype.drawDistance = function (val) {
            if (val === undefined)
                return this._drawDistance;
            this._drawDistance = val;
            this._build();
            return val;
        };
        /**
        * Gets the grid picker associated with this grid
        * @returns {ViewspaceGridPicker}
        */
        ViewspaceGrid.prototype.picker = function () { return this._picker; };
        /**
        * If the texture is updated, we need to re-draw the context
        */
        ViewspaceGrid.prototype.onHeightmapChanged = function (e, event, sender) {
            this._picker.updateHeightData(sender);
        };
        /**
        * Gets or sets the texute we use to sample height data from
        * @param {Texture} val [Optional]
        * @returns {Texture}
        */
        ViewspaceGrid.prototype.heightfield = function (val) {
            if (val === undefined)
                return this._heightTexture;
            var heightfield = this._heightTexture;
            if (heightfield)
                heightfield.off('texture_loader_complete', this.onHeightmapChanged, this);
            this._heightTexture = val;
            this._material.heightmap(val);
            this._picker.updateHeightData(val);
            if (val) {
                val.on('texture_loader_complete', this.onHeightmapChanged, this);
                this.onHeightmapChanged('texture_loader_complete', null, val);
            }
            return val;
        };
        /**
        * Gets or sets the number of resolution levels. Closer levels are higher density mesh triangulations and far ones are less.
        * @param {number} val [Optional]
        * @returns {number}
        */
        ViewspaceGrid.prototype.levels = function (val) {
            if (val === undefined)
                return this._levels;
            this._levels = val;
            this._build();
            return val;
        };
        /**
        * Sets the number of altitude of the grid
        * @param {number} val [Optional]
        * @returns {number}
        */
        ViewspaceGrid.prototype.altitude = function (val) {
            if (val === undefined)
                return this._altitude;
            this._altitude = val;
            this._material.altitude(val);
            var tiles = this._tiles;
            for (var i = 0, l = tiles.length; i < l; i++)
                tiles[i].altitude = val;
            return val;
        };
        /**
        * Sets the number of height offset of the grid.
        * @param {number} val [Optional]
        * @returns {number}
        */
        ViewspaceGrid.prototype.heightOffset = function (val) {
            if (val === undefined)
                return this._heightOffset;
            this._heightOffset = val;
            this._material.heightOffset(val);
            var tiles = this._tiles;
            for (var i = 0, l = tiles.length; i < l; i++)
                tiles[i].heightOffset = val;
            return val;
        };
        /**
        * Sets resolution of the grid tiles. This must be a multiple of 2. Anything lower than 16 or greater than 128 is not advisable.
        * @param {number} val [Optional]
        * @returns {number}
        */
        ViewspaceGrid.prototype.resolution = function (val) {
            if (val === undefined)
                return this._resolution;
            this._resolution = val;
            if (this._tileGeom)
                this._tileGeom.dispose();
            // Create geometry that we'll use for each tile, just a standard plane
            this._tileGeom = new Trike.GeometryPlane(1, 1, val, val);
            // Rotate the geometry so its flat on the ground.
            // Also place origin at bottom left corner, rather than center. So that all verts are possitive.
            // 1 _ _ 1
            // |   / |
            // |  /  |
            // | /   |
            // 0/_ _ 1
            var m = new Trike.Matrix4();
            m.makeTranslation(0.5, 0.5, 0);
            this._tileGeom.applyMatrix(m);
            m.makeRotationX(90 * Math.PI / 180);
            this._tileGeom.applyMatrix(m);
            this._tileGeom.reverseFaceOrder();
            this._tileGeom.computeFaceNormals();
            this._tileGeom.generateNormals(false);
            // Tell the material what the resolution is
            this._material.tileResolution(val);
            this._build();
            return val;
        };
        /**
        * Builds the grid - should not be called outside of the grid class
        */
        ViewspaceGrid.prototype._build = function () {
            var worldWidth = this._drawDistance;
            var levels = this._levels;
            var tiles = this._tiles;
            for (var i = 0, l = tiles.length; i < l; i++)
                tiles[i].dispose();
            tiles.splice(0, tiles.length);
            // Create collection of tiles to fill required space
            var initialScale = worldWidth / Math.pow(2, levels);
            // Create center layer first
            //    +---+---+
            //    | O | O |
            //    +---+---+
            //    | O | O |
            //    +---+---+
            this.createTile(-initialScale, -initialScale, initialScale, Edge.NONE);
            this.createTile(-initialScale, 0, initialScale, Edge.NONE);
            this.createTile(0, 0, initialScale, Edge.NONE);
            this.createTile(0, -initialScale, initialScale, Edge.NONE);
            // Create 'quadtree' of tiles, with smallest in center
            // Each added layer consists of the following tiles (marked 'A'), with the tiles
            // in the middle being created in previous layers
            // +---+---+---+---+
            // | A | A | A | A |
            // +---+---+---+---+
            // | A |   |   | A |
            // +---+---+---+---+
            // | A |   |   | A |
            // +---+---+---+---+
            // | A | A | A | A |
            // +---+---+---+---+
            for (var scale = initialScale; scale < worldWidth; scale *= 2) {
                this.createTile(-2 * scale, -2 * scale, scale, Edge.BOTTOM | Edge.LEFT);
                this.createTile(-2 * scale, -scale, scale, Edge.LEFT);
                this.createTile(-2 * scale, 0, scale, Edge.LEFT);
                this.createTile(-2 * scale, scale, scale, Edge.TOP | Edge.LEFT);
                this.createTile(-scale, -2 * scale, scale, Edge.BOTTOM);
                // 2 tiles 'missing' here are in previous layer
                this.createTile(-scale, scale, scale, Edge.TOP);
                this.createTile(0, -2 * scale, scale, Edge.BOTTOM);
                // 2 tile
                this.createTile(0, scale, scale, Edge.TOP);
                this.createTile(scale, -2 * scale, scale, Edge.BOTTOM | Edge.RIGHT);
                this.createTile(scale, -scale, scale, Edge.RIGHT);
                this.createTile(scale, 0, scale, Edge.RIGHT);
                this.createTile(scale, scale, scale, Edge.TOP | Edge.RIGHT);
            }
        };
        /**
        * Creates each grid tile
        */
        ViewspaceGrid.prototype.createTile = function (x, y, scale, edgeMorph) {
            var tiles = this._tiles;
            var plane = new Trike.ViewspaceTile(this._material, this._tileGeom);
            plane.castShadows(this.castShadows());
            plane.edgeMorh = edgeMorph;
            plane.tileOffset = new Trike.Vec2(x, y);
            plane.tileScale = scale;
            plane.altitude = this._altitude;
            plane.heightOffset = this._heightOffset;
            this.add(plane);
            tiles.push(plane);
        };
        Object.defineProperty(ViewspaceGrid.prototype, "material", {
            /**
            * Gets the material assigned to this terrain
            * @returns {MaterialMulti}
            */
            get: function () { return this._material; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewspaceGrid.prototype, "tiles", {
            /**
            * Gets the tiles of this terrain
            * @returns {Array<ViewspaceTile>}
            */
            get: function () { return this._tiles; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewspaceGrid.prototype, "geometry", {
            /**
            * Gets the geometrt of this terrain
            * @returns {Geometry}
            */
            get: function () { return this._tileGeom; },
            enumerable: true,
            configurable: true
        });
        /**
        * Cleans up the grid
        */
        ViewspaceGrid.prototype.dispose = function () {
            if (this._heightTexture)
                this._heightTexture.off('texture_loader_complete', this.onHeightmapChanged, this);
            var tiles = this._tiles;
            for (var i = 0, l = tiles.length; i < l; i++)
                tiles[i].dispose();
            if (this._tileGeom)
                this._tileGeom.dispose();
            this._material = null;
            this._picker.dispose();
            this._material = null;
            this._tiles = null;
            this._heightTexture = null;
            this._tileGeom = null;
            this._picker = null;
            _super.prototype.dispose.call(this);
        };
        return ViewspaceGrid;
    }(Trike.Object3D));
    Trike.ViewspaceGrid = ViewspaceGrid;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A simple mesh, used as part of a viewspace grid. All tiles of a given grid share the same material & geometry
    * but update the uniforms before each render. The geometry of the tile is a horizontal planar geometry with a width and depth
    * of 1. The tesselation can be high, but the dimensions are always 1 unit. In the material, each of the vertices
    * of this unit geometry are scaled based on the tileScale and moved based on the tileOffset.
    * So even though the geometry is shared, the vertices
    * are scaled and offset by the tiles respective vectors. This means each tile is drawn and scaled in different positions.
    * Good example from here: http://www.pheelicks.com/2014/03/rendering-large-terrains/
    */
    var ViewspaceTile = (function (_super) {
        __extends(ViewspaceTile, _super);
        /**
        * Creates an instance of the terrain tile
        */
        function ViewspaceTile(mat, geom) {
            _super.call(this, mat, geom);
            this._vec = new Trike.Vec3();
            this._box = new Trike.Box3();
            this.pickable = false;
            // We do custom pre-render culling
            this.customCulling = true;
        }
        /**
        * An update call made before the rendering process begins
        * @param {number} totalTime The total number of milliseconds since the start of the app
        * @param {number} delta The delta time since the last update call
        * @param {Camera} camera The camera being for the render
        * @param {Renderer} renderer The renderer used to draw the scene
        */
        ViewspaceTile.prototype.update = function (totalTime, delta, camera, renderer) {
            _super.prototype.update.call(this, totalTime, delta, camera, renderer);
            var box = this._box;
            var tileOffset = this.tileOffset;
            var altitude = this.altitude;
            var heightOffset = this.heightOffset;
            var v = this._vec;
            var scale = this.tileScale;
            v.getPositionFromMatrix(camera.worldMatrix);
            box.min.set(v.x + tileOffset.x, heightOffset, v.z + tileOffset.y);
            box.max.set(v.x + tileOffset.x + scale, altitude + heightOffset, v.z + tileOffset.y + scale);
        };
        /**
        * Updates the world matrix as well as updating the world sphere and bounding boxes.
        * @param {boolean} forceWorldUpdate If true, the world matrices will be forced to update
        * @param {boolean} forceLocalUpdate If true, the local matrices will be forced to update
        */
        ViewspaceTile.prototype.updateWorldMatrix = function (forceWorldUpdate, forceLocalUpdate) {
            if (forceWorldUpdate === void 0) { forceWorldUpdate = false; }
            if (forceLocalUpdate === void 0) { forceLocalUpdate = false; }
            _super.prototype.updateWorldMatrix.call(this, forceWorldUpdate, forceLocalUpdate);
            // Customly set the bounding volumes
            // First the bounding box
            var box = this._box;
            this._worldBox.copy(box);
            // Now the sphere
            box.center(this._worldSphere.center);
            var x = box.max.x - this._worldSphere.center.x;
            var z = box.max.z - this._worldSphere.center.z;
            this._worldSphere.radius = Math.sqrt((x * x) + (z * z));
        };
        /*
        * This function is called
        * @param {Camera} camera The camera used to render the scene
        * @param {Frustum} frustum The render target the scene is being drawn to
        * @returns {boolean} Returns false if the mesh must be drawn
        */
        ViewspaceTile.prototype.isCulled = function (camera, frustum) {
            var inView = frustum.intersectsBox(this._box);
            if (inView === false)
                return true;
            else
                return false;
        };
        /*
        * Called just before we render the mesh. The mesh would have passed culling and already be updated.
        * A good place to update custom uniforms.
        * @param {Renderer} renderer The renderer used to draw the scene
        * @param {RenderPass} renderPass The render pass associated with this call
        */
        ViewspaceTile.prototype.preRender = function (renderer, renderPass) {
            _super.prototype.preRender.call(this, renderer, renderPass);
            var mat = this._material;
            mat.setUniform('camPosition', this._vec, true);
            mat.setUniform('uEdgeMorph', this.edgeMorh, true);
            mat.setUniform('uTileOffset', this.tileOffset, true);
            mat.setUniform('uScale', this.tileScale, true);
        };
        /**
        * Cleans up the tile
        */
        ViewspaceTile.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.tileOffset = null;
            this._vec = null;
        };
        return ViewspaceTile;
    }(Trike.Mesh));
    Trike.ViewspaceTile = ViewspaceTile;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * The viewspace grid picker is used to get contact points on a grid instance.
    */
    var ViewspaceGridPicker = (function () {
        /**
        * Creates an instance of the picker
        */
        function ViewspaceGridPicker(grid) {
            this._grid = grid;
            this._canvas = document.createElement('canvas');
            this._tempVec = new Trike.Vec2();
            this._intersection = new Trike.Intersection(0, null, null, null);
        }
        /**
        * Nullifies values for GC
        */
        ViewspaceGridPicker.prototype.dispose = function () {
            this._grid = null;
            this._canvas = null;
            this._heightData = null;
            this._canvas = null;
            this._tempVec = null;
            this._intersection.object = null;
            this._intersection = null;
        };
        /**
        * Updates the height data stored in the picker. This must be updated whenever the heightfield texture is changed.
        * @param {Texture} texture The updated texture
        */
        ViewspaceGridPicker.prototype.updateHeightData = function (texture) {
            var context = this._canvas.getContext('2d');
            if (texture) {
                var w = texture.image.width;
                var h = texture.image.height;
                this._canvas.width = w;
                this._canvas.height = h;
                context.drawImage(texture.image, 0, 0, w, h);
                this._heightData = context.getImageData(0, 0, w, h).data;
            }
            else
                this._heightData = null;
        };
        /**
        * Clamps a number p within the range of l determined by the wrapping function
        * @returns {number} Number within the range of l
        */
        ViewspaceGridPicker.prototype.clampFragment = function (p, l, wrapping) {
            // Wrap the coordinates based on the wrapping style
            if (wrapping === Trike.TextureWrapping.RepeatWrapping) {
                if (p >= 0)
                    return p = p % l;
                else
                    return (l - Math.abs(p % l));
            }
            else if (wrapping === Trike.TextureWrapping.MirroredRepeatWrapping) {
                p = Math.abs(p);
                return (p % (l * 2) < l ? p % l : (l * 2) - (p % (l * 2)));
            }
            else if (wrapping === Trike.TextureWrapping.ClampToEdgeWrapping) {
                if (p > l)
                    p = l;
                else if (p < 0)
                    p = 0;
            }
            return p;
        };
        /**
        * Gets normalized UV coordinates of the grid from the world x and z position
        * @param {number} x The world x position
        * @param {number} z The world z position
        * @param {TextureWrapping} wrappingS The S wrapping of the heightfield texture
        * @param {TextureWrapping} wrappingU The U wrapping of the heightfield texture
        * @param {Vec2} out Specify a vector to store the data in.
        * @returns {Vec2} The normalized UV coordinates
        */
        ViewspaceGridPicker.prototype.getUVCoordinate = function (x, z, wrappingS, wrappingT, out) {
            if (out === void 0) { out = new Trike.Vec2(); }
            var grid = this._grid;
            var worldSize = grid.material.worldScale();
            var u, v;
            // Gets the normalized UV coordinates of the position on the heightfield map
            u = x / worldSize + 0.5;
            v = 1 - (z / worldSize + 0.5);
            u = this.clampFragment(u, 1, wrappingS);
            v = this.clampFragment(v, 1, wrappingT);
            return out.set(u, v);
        };
        /**
        * Gets the height of the terrain at x and z world coordinates
        * @param {number} x The world x position
        * @param {number} z The world z position
        * @returns {number} The height of the terrain at that point
        */
        ViewspaceGridPicker.prototype.getHeight = function (x, z) {
            var heightData = this._heightData;
            if (heightData) {
                var grid = this._grid;
                var heightTexture = grid.heightfield();
                if (heightTexture instanceof Trike.CanvasTexture)
                    heightData = heightTexture.imageData.data;
                else if (heightTexture instanceof Trike.DataTexture)
                    heightData = heightTexture.data;
                else
                    heightData = heightData;
                var test = new Uint8Array(20);
                var altitude = grid.altitude();
                var heightOffset = grid.heightOffset();
                // Gets the normalized UV coordinates of the position on the heightfield map
                var heightUv = this._tempVec;
                this.getUVCoordinate(x, z, heightTexture.wrapS, heightTexture.wrapT, heightUv);
                var componentSize = heightTexture.getNumberComponents();
                var val = this.sample(heightData, heightTexture.width, heightTexture.height, componentSize, heightUv.x, heightUv.y, heightTexture);
                return val * altitude + heightOffset;
            }
            else
                return 0.0;
        };
        /**
        * Gets the normalized value of an image's  pixel from the x and y coordinates. Assumes the height is in the r channel.
        * The x and y coordinates expected here must be between 0 and 1. This sampler will get the interpolated value
        * of a pixel. I.e. if the coorindates are a fraction between two pixels, this function will get the interpolated
        * value between them (essentially performing a bilinear texture sample)
        * returns {number} Colour information from 0 to 1 from the red channel
        */
        ViewspaceGridPicker.prototype.sample = function (data, width, height, componentSize, x, y, texture) {
            var interpolator = Trike.Interpolater.interpolate;
            var clamp = this.clampFragment;
            var catmul = Trike.Interpolater.catmullRom;
            var hWidthLimit, hHeightLimit;
            if (texture.wrapS === Trike.TextureWrapping.ClampToEdgeWrapping)
                hWidthLimit = width - 1;
            else
                hWidthLimit = width;
            if (texture.wrapT === Trike.TextureWrapping.ClampToEdgeWrapping)
                hHeightLimit = height - 1;
            else
                hHeightLimit = height;
            // Make sure the x and y are clamped by looking at the wrapping functions
            x = clamp(x, 1, texture.wrapS);
            y = clamp(y, 1, texture.wrapT);
            var fracX = ((x * width) % 1);
            var fracY = ((y * height) % 1);
            var pixX = Math.floor(x * width);
            var pixY = Math.floor(y * height);
            // The pixels values are actually located in the middle. So we have to shift
            // The values so that they reflect this.
            if (fracX < 0.5) {
                pixX = clamp(pixX - 1, hWidthLimit, texture.wrapS);
                fracX += 0.5;
            }
            else
                fracX = fracX - 0.5;
            if (fracY < 0.5) {
                pixY = clamp(pixY - 1, hHeightLimit, texture.wrapT);
                fracY += 0.5;
            }
            else
                fracY = fracY - 0.5;
            // If the filter is nearest, then return the absolute pixel
            if (texture.magFilter === Trike.TextureFilter.Nearest)
                return data[((width * clamp(pixY, hHeightLimit, texture.wrapT)) + clamp(pixX, hWidthLimit, texture.wrapS)) * componentSize] / 255;
            // Texture is linear, so we need to do some bicubic interpolatoion
            // Collects all pixels around the center pixel
            var h = [], i = 0, sx, sy;
            for (sy = -1; sy <= 2; ++sy)
                for (sx = -1; sx <= 2; ++sx)
                    h[i++] = data[((width * clamp(pixY + sy, hHeightLimit, texture.wrapT)) + clamp(pixX + sx, hWidthLimit, texture.wrapS)) * componentSize];
            // Gets an average pixel value by assessing each of the pixels around the center pixel
            return catmul(catmul(h[0], h[1], h[2], h[3], fracX), catmul(h[4], h[5], h[6], h[7], fracX), catmul(h[8], h[9], h[10], h[11], fracX), catmul(h[12], h[13], h[14], h[15], fracX), fracY) / 255.0;
        };
        ViewspaceGridPicker.prototype.heightRayDelta = function (lambda, rayDirX, rayDirY, rayDirZ, rayOriginX, rayOriginY, rayOriginZ) {
            // Project the ray along its direction by the lamda
            rayDirX = rayDirX * lambda + rayOriginX;
            rayDirY = rayDirY * lambda + rayOriginY;
            rayDirZ = rayDirZ * lambda + rayOriginZ;
            // Now we are at some point along the ray - lets get the grid height at that point
            var gridHeight = this.getHeight(rayDirX, rayDirZ);
            return gridHeight - rayDirY;
        };
        ViewspaceGridPicker.prototype.zeroCrossing = function (lower, upper, rayDirX, rayDirY, rayDirZ, rayOriginX, rayOriginY, rayOriginZ, iterations) {
            if (iterations === void 0) { iterations = 4; }
            var fnLower = this.heightRayDelta(lower, rayDirX, rayDirY, rayDirZ, rayOriginX, rayOriginY, rayOriginZ);
            var fnUpper = this.heightRayDelta(upper, rayDirX, rayDirY, rayDirZ, rayOriginX, rayOriginY, rayOriginZ);
            // Approximate the function as a line.
            var gradient = (fnUpper - fnLower) / (upper - lower);
            var constant = fnLower - gradient * lower;
            var crossing = -constant / gradient;
            if (iterations <= 1)
                return crossing;
            var fnCrossing = this.heightRayDelta(crossing, rayDirX, rayDirY, rayDirZ, rayOriginX, rayOriginY, rayOriginZ);
            if (fnCrossing < 0)
                return this.zeroCrossing(crossing, upper, rayDirX, rayDirY, rayDirZ, rayOriginX, rayOriginY, rayOriginZ, iterations - 1);
            else
                return this.zeroCrossing(lower, crossing, rayDirX, rayDirY, rayDirZ, rayOriginX, rayOriginY, rayOriginZ, iterations - 1);
        };
        /**
        * Returns an intersection with the grid against a Ray
        * @param {Ray} ray The ray we are testing
        * returns {Intersection} Returns the intersection or null
        */
        ViewspaceGridPicker.prototype.intersectRay = function (ray) {
            // lamda defines how far down the ray we are sampling
            var lambda = 0;
            // Increments the lamda along the Ray direction by a given step
            var step = 0.2;
            var nextLambda;
            var dX = ray.direction.x, dY = ray.direction.y, dZ = ray.direction.z, oX = ray.origin.x, oY = ray.origin.y, oZ = ray.origin.z;
            // We test the ray along a max distance of 200,000 units
            while (lambda < 200000) {
                nextLambda = lambda + step;
                if (this.heightRayDelta(nextLambda, dX, dY, dZ, oX, oY, oZ) > 0) {
                    lambda = this.zeroCrossing(lambda, nextLambda, dX, dY, dZ, oX, oY, oZ);
                    // Get the contact Vec of the grid against the grid based on the lamda along the ray
                    var rayProjX = dX * lambda + oX;
                    var rayProjY = dY * lambda + oY;
                    var rayProjZ = dZ * lambda + oZ;
                    var contact = new Trike.Vec3(rayProjX, this.getHeight(rayProjX, rayProjZ), rayProjZ);
                    this._intersection.distance = lambda;
                    this._intersection.point = contact;
                    this._intersection.object = this._grid;
                    return this._intersection;
                }
                lambda = nextLambda;
                // Increment the step each time as the grid could potentially be huge
                step *= 1.1;
            }
            return null;
        };
        return ViewspaceGridPicker;
    }());
    Trike.ViewspaceGridPicker = ViewspaceGridPicker;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * The Terrain class is used to draw vast areas of land based on a height map texture.
    * Trike's Terrain system uses Geom Clipmapping, which allows for expansive terrains
    * that are heavily based on the GPU as opposed to the CPU.
    */
    var Terrain = (function (_super) {
        __extends(Terrain, _super);
        /**
        * Creates an instance of the terrain class
        * @param {number} drawDistance Determines how far off the terrain is drawn. Its recommended you use multiples of 2 as it can cause holes in the terrain if you don't
        * @param {number} levels The number of resolution levels. Closer levels are higher density mesh triangulations and far ones are less.
        * @param {number} resolution The resolution of the terrain tiles. This must be a multiple of 2. Anything lower than 16 or greater than 128 is not advisable.
        */
        function Terrain(drawDistance, levels, resolution) {
            if (drawDistance === void 0) { drawDistance = 1024; }
            if (levels === void 0) { levels = 4; }
            if (resolution === void 0) { resolution = 32; }
            _super.call(this, new Trike.MaterialTerrain(resolution, drawDistance), drawDistance, levels, resolution);
        }
        /**
        * If the texture is updated, we need to re-draw the context
        */
        Terrain.prototype.onHeightmapChanged = function (e, event, sender) {
            _super.prototype.onHeightmapChanged.call(this, e, event, sender);
            // Remove the previous heightfield size define
            if (event && event.previousImage)
                this._material.removeDefine('#define HEIGHTFIELD_SIZE ' + event.previousImage.width.toFixed(1));
            this._material.heightmap(sender);
        };
        /**
        * Cleans up the terrain
        */
        Terrain.prototype.dispose = function () {
            this._material.dispose();
            _super.prototype.dispose.call(this);
        };
        return Terrain;
    }(Trike.ViewspaceGrid));
    Trike.Terrain = Terrain;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Creates an ocean object along with its ocean material
    */
    var Ocean = (function (_super) {
        __extends(Ocean, _super);
        /**
        * Creates an instance of the terrain class
        * @param {number} mirrorSize The texture size of the reflection mirror.
        * @param {number} drawDistance Determines how far off the terrain is drawn. Its recommended you use multiples of 2 as it can cause holes in the terrain if you don't
        * @param {number} levels The number of resolution levels. Closer levels are higher density mesh triangulations and far ones are less.
        * @param {number} resolution The resolution of the terrain tiles. This must be a multiple of 2. Anything lower than 16 or greater than 128 is not advisable.
        * @param {MaterialTerrain} material Optionally use a custom terrain shader
        */
        function Ocean(mirrorSize, drawDistance, levels, resolution) {
            if (mirrorSize === void 0) { mirrorSize = 512; }
            if (drawDistance === void 0) { drawDistance = 1024; }
            if (levels === void 0) { levels = 6; }
            if (resolution === void 0) { resolution = 32; }
            _super.call(this, new Trike.MaterialOcean(resolution, drawDistance), drawDistance, levels, resolution);
            this.mirror = new Trike.Mirror(this.material, mirrorSize, mirrorSize);
            this.add(this.mirror);
            this.mirror.rotationX = Trike.MathUtils.degToRad(-90);
        }
        /**
        * An update call made before the rendering process begins
        * @param {number} totalTime The total number of milliseconds since the start of the app
        * @param {number} delta The delta time since the last update call
        * @param {Camera} camera The camera being for the render
        * @param {Renderer} renderer The renderer used to draw the scene
        */
        Ocean.prototype.update = function (totalTime, delta, camera, renderer) {
            _super.prototype.update.call(this, totalTime, delta, camera, renderer);
        };
        /**
        * If the texture is updated, we need to re-draw the context
        */
        Ocean.prototype.onHeightmapChanged = function (e, event, sender) {
            _super.prototype.onHeightmapChanged.call(this, e, event, sender);
            // Remove the previous heightfield size define
            if (event && event.previousImage)
                this._material.removeDefine('#define HEIGHTFIELD_SIZE ' + event.previousImage.width.toFixed(1));
            this._material.heightmap(sender);
        };
        /**
        * Cleans up the terrain
        */
        Ocean.prototype.dispose = function () {
            this._material.dispose();
            _super.prototype.dispose.call(this);
        };
        return Ocean;
    }(Trike.ViewspaceGrid));
    Trike.Ocean = Ocean;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    // http://jsperf.com/pixel-interpolation/2
    var Sampler = (function () {
        function Sampler() {
        }
        Sampler.clamp = function (lo, value, hi) {
            return value < lo ? lo : value > hi ? hi : value;
        };
        Sampler.nearest = function (pixels, x, y, offset, width) {
            return pixels[offset + Math.round(y) * width * 4 + Math.round(x) * 4];
        };
        Sampler.nearest_unrolled = function (pixels, x, y, width) {
            var yw4x4 = ((y + 0.5) ^ 0) * width * 4 + ((x + 0.5) ^ 0) * 4;
            return [
                pixels[yw4x4],
                pixels[yw4x4 + 1],
                pixels[yw4x4 + 2]
            ];
        };
        Sampler.bilinear = function (pixels, x, y, offset, width) {
            var percentX = 1.0 - (x - Math.floor(x));
            var percentY = y - Math.floor(y);
            var top = pixels[offset + Math.ceil(y) * width * 4 + Math.floor(x) * 4] * percentX + pixels[offset + Math.ceil(y) * width * 4 + Math.ceil(x) * 4] * (1.0 - percentX);
            var bottom = pixels[offset + Math.floor(y) * width * 4 + Math.floor(x) * 4] * percentX + pixels[offset + Math.floor(y) * width * 4 + Math.ceil(x) * 4] * (1.0 - percentX);
            return top * percentY + bottom * (1.0 - percentY);
        };
        Sampler.bilinear_optimized = function (pixels, x, y, offset, width) {
            var percentX = x - (x ^ 0);
            var percentX1 = 1.0 - percentX;
            var percentY = y - (y ^ 0);
            var fx4 = (x ^ 0) * 4;
            var cx4 = fx4 + 4;
            var fy4 = (y ^ 0) * 4;
            var cy4wo = (fy4 + 4) * width + offset;
            var fy4wo = fy4 * width + offset;
            var top = pixels[cy4wo + fx4] * percentX1 + pixels[cy4wo + cx4] * percentX;
            var bottom = pixels[fy4wo + fx4] * percentX1 + pixels[fy4wo + cx4] * percentX;
            return top * percentY + bottom * (1.0 - percentY);
        };
        Sampler.bilinear_unrolled = function (pixels, x, y, width) {
            var percentX = x - (x ^ 0);
            var percentX1 = 1.0 - percentX;
            var percentY = y - (y ^ 0);
            var percentY1 = 1.0 - percentY;
            var fx4 = (x ^ 0) * 4;
            var cx4 = fx4 + 4;
            var fy4 = (y ^ 0) * 4;
            var cy4wr = (fy4 + 4) * width;
            var fy4wr = fy4 * width;
            var cy4wg = cy4wr + 1;
            var fy4wg = fy4wr + 1;
            var cy4wb = cy4wr + 2;
            var fy4wb = fy4wr + 2;
            var top, bottom, r, g, b;
            top = pixels[cy4wr + fx4] * percentX1 + pixels[cy4wr + cx4] * percentX;
            bottom = pixels[fy4wr + fx4] * percentX1 + pixels[fy4wr + cx4] * percentX;
            r = top * percentY + bottom * percentY1;
            top = pixels[cy4wg + fx4] * percentX1 + pixels[cy4wg + cx4] * percentX;
            bottom = pixels[fy4wg + fx4] * percentX1 + pixels[fy4wg + cx4] * percentX;
            g = top * percentY + bottom * percentY1;
            top = pixels[cy4wb + fx4] * percentX1 + pixels[cy4wb + cx4] * percentX;
            bottom = pixels[fy4wb + fx4] * percentX1 + pixels[fy4wb + cx4] * percentX;
            b = top * percentY + bottom * percentY1;
            return [r, g, b];
        };
        Sampler.bicubic_value = function (x, a, b, c, d) {
            return Sampler.clamp(0, 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * x) * x) * x + b, 255);
        };
        Sampler.bicubic = function (pixels, x, y, offset, width) {
            var v = [0, 0, 0, 0];
            var fx = Math.floor(x);
            var fy = Math.floor(y);
            var percentX = x - fx;
            var percentY = y - fy;
            for (var i = -1; i < 3; i++) {
                var yw4o = (fy + i) * width * 4 + offset;
                v[i + 1] = (Sampler.bicubic_value(percentX, pixels[(fy + i) * width * 4 + (fx - 1) * 4 + offset], pixels[(fy + i) * width * 4 + fx * 4 + offset], pixels[(fy + i) * width * 4 + (fx + 1) * 4 + offset], pixels[(fy + i) * width * 4 + (fx + 2) * 4 + offset]));
            }
            return Math.floor(Sampler.bicubic_value(percentY, v[0], v[1], v[2], v[3]));
        };
        Sampler.bicubic_optimized = function (pixels, x, y, offset, width) {
            var a, b, c, d, v0, v1, v2, v3;
            var fx = x ^ 0;
            var fy = y ^ 0;
            var percentX = x - fx;
            var percentY = y - fy;
            var fx14 = fx * 4;
            var fx04 = fx14 - 4;
            var fx24 = fx14 + 4;
            var fx34 = fx14 + 8;
            var w4 = width * 4;
            var yw14o = fy * w4 + offset;
            var yw04o = yw14o - w4;
            var yw24o = yw14o + w4;
            var yw34o = yw14o + w4 + w4;
            a = pixels[yw04o + fx04];
            b = pixels[yw04o + fx14];
            c = pixels[yw04o + fx24];
            d = pixels[yw04o + fx34];
            v0 = 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * percentX) * percentX) * percentX + b;
            v0 = v0 > 255 ? 255 : v0 < 0 ? 0 : v0;
            a = pixels[yw14o + fx04];
            b = pixels[yw14o + fx14];
            c = pixels[yw14o + fx24];
            d = pixels[yw14o + fx34];
            v1 = 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * percentX) * percentX) * percentX + b;
            v1 = v1 > 255 ? 255 : v1 < 0 ? 0 : v1;
            a = pixels[yw24o + fx04];
            b = pixels[yw24o + fx14];
            c = pixels[yw24o + fx24];
            d = pixels[yw24o + fx34];
            v2 = 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * percentX) * percentX) * percentX + b;
            v2 = v2 > 255 ? 255 : v2 < 0 ? 0 : v2;
            a = pixels[yw34o + fx04];
            b = pixels[yw34o + fx14];
            c = pixels[yw34o + fx24];
            d = pixels[yw34o + fx34];
            v3 = 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * percentX) * percentX) * percentX + b;
            v3 = v3 > 255 ? 255 : v3 < 0 ? 0 : v3;
            a = v0;
            b = v1;
            c = v2;
            d = v3;
            a = 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * percentY) * percentY) * percentY + b;
            return a > 255 ? 255 : a < 0 ? 0 : a ^ 0;
        };
        Sampler.bicubic_unrolled = function (pixels, x, y, width) {
            var a, b, c, d, v0, v1, v2, v3, r, g;
            var fx = x ^ 0;
            var fy = y ^ 0;
            var percentX = x - fx;
            var percentY = y - fy;
            var fx14 = fx * 4;
            var fx04 = fx14 - 4;
            var fx24 = fx14 + 4;
            var fx34 = fx14 + 8;
            var w4 = width * 4;
            var yw14r = fy * w4;
            var yw04r = yw14r - w4;
            var yw24r = yw14r + w4;
            var yw34r = yw14r + w4 + w4;
            var yw14g = yw14r + 1;
            var yw04g = yw04r + 1;
            var yw24g = yw24r + 1;
            var yw34g = yw34r + 1;
            var yw14b = yw14r + 2;
            var yw04b = yw04r + 2;
            var yw24b = yw24r + 2;
            var yw34b = yw34r + 2;
            // Red
            a = pixels[yw04r + fx04];
            b = pixels[yw04r + fx14];
            c = pixels[yw04r + fx24];
            d = pixels[yw04r + fx34];
            v0 = 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * percentX) * percentX) * percentX + b;
            v0 = v0 > 255 ? 255 : v0 < 0 ? 0 : v0;
            a = pixels[yw14r + fx04];
            b = pixels[yw14r + fx14];
            c = pixels[yw14r + fx24];
            d = pixels[yw14r + fx34];
            v1 = 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * percentX) * percentX) * percentX + b;
            v1 = v1 > 255 ? 255 : v1 < 0 ? 0 : v1;
            a = pixels[yw24r + fx04];
            b = pixels[yw24r + fx14];
            c = pixels[yw24r + fx24];
            d = pixels[yw24r + fx34];
            v2 = 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * percentX) * percentX) * percentX + b;
            v2 = v2 > 255 ? 255 : v2 < 0 ? 0 : v2;
            a = pixels[yw34r + fx04];
            b = pixels[yw34r + fx14];
            c = pixels[yw34r + fx24];
            d = pixels[yw34r + fx34];
            v3 = 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * percentX) * percentX) * percentX + b;
            v3 = v3 > 255 ? 255 : v3 < 0 ? 0 : v3;
            a = v0;
            b = v1;
            c = v2;
            d = v3;
            r = 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * percentY) * percentY) * percentY + b;
            r = r > 255 ? 255 : r < 0 ? 0 : r ^ 0;
            // Green
            a = pixels[yw04g + fx04];
            b = pixels[yw04g + fx14];
            c = pixels[yw04g + fx24];
            d = pixels[yw04g + fx34];
            v0 = 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * percentX) * percentX) * percentX + b;
            v0 = v0 > 255 ? 255 : v0 < 0 ? 0 : v0;
            a = pixels[yw14g + fx04];
            b = pixels[yw14g + fx14];
            c = pixels[yw14g + fx24];
            d = pixels[yw14g + fx34];
            v1 = 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * percentX) * percentX) * percentX + b;
            v1 = v1 > 255 ? 255 : v1 < 0 ? 0 : v1;
            a = pixels[yw24g + fx04];
            b = pixels[yw24g + fx14];
            c = pixels[yw24g + fx24];
            d = pixels[yw24g + fx34];
            v2 = 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * percentX) * percentX) * percentX + b;
            v2 = v2 > 255 ? 255 : v2 < 0 ? 0 : v2;
            a = pixels[yw34g + fx04];
            b = pixels[yw34g + fx14];
            c = pixels[yw34g + fx24];
            d = pixels[yw34g + fx34];
            v3 = 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * percentX) * percentX) * percentX + b;
            v3 = v3 > 255 ? 255 : v3 < 0 ? 0 : v3;
            a = v0;
            b = v1;
            c = v2;
            d = v3;
            g = 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * percentY) * percentY) * percentY + b;
            g = g > 255 ? 255 : g < 0 ? 0 : g ^ 0;
            // Blue
            a = pixels[yw04b + fx04];
            b = pixels[yw04b + fx14];
            c = pixels[yw04b + fx24];
            d = pixels[yw04b + fx34];
            v0 = 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * percentX) * percentX) * percentX + b;
            v0 = v0 > 255 ? 255 : v0 < 0 ? 0 : v0;
            a = pixels[yw14b + fx04];
            b = pixels[yw14b + fx14];
            c = pixels[yw14b + fx24];
            d = pixels[yw14b + fx34];
            v1 = 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * percentX) * percentX) * percentX + b;
            v1 = v1 > 255 ? 255 : v1 < 0 ? 0 : v1;
            a = pixels[yw24b + fx04];
            b = pixels[yw24b + fx14];
            c = pixels[yw24b + fx24];
            d = pixels[yw24b + fx34];
            v2 = 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * percentX) * percentX) * percentX + b;
            v2 = v2 > 255 ? 255 : v2 < 0 ? 0 : v2;
            a = pixels[yw34b + fx04];
            b = pixels[yw34b + fx14];
            c = pixels[yw34b + fx24];
            d = pixels[yw34b + fx34];
            v3 = 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * percentX) * percentX) * percentX + b;
            v3 = v3 > 255 ? 255 : v3 < 0 ? 0 : v3;
            a = v0;
            b = v1;
            c = v2;
            d = v3;
            b = 0.5 * (c - a + (2.0 * a - 5.0 * b + 4.0 * c - d + (3.0 * (b - c) + d - a) * percentY) * percentY) * percentY + b;
            b = b > 255 ? 255 : b < 0 ? 0 : b ^ 0;
            return [r, g, b];
        };
        return Sampler;
    }());
    Trike.Sampler = Sampler;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    var CubeRenderer = (function (_super) {
        __extends(CubeRenderer, _super);
        /**
        * Creates an instance of the cube renderer
        * @param {number} width The width of the renderer cube texture
        * @param {number} height The height of the renderer cube texture
        * @param {TextureType} type The renderer cube texture type
        * @param {TextureWrapping} wrapS How the renderer cube texture wraps horizontally
        * @param {TextureWrapping} wrapT How the renderer cube texture wraps vertically
        * @param {TextureFilter} magFilter The filter to use when the renderer cube texture is magnified
        * @param {TextureFilter} minfFilter The filter to use when the renderer cube texture is minified
        * @param {TextureFormat} format The renderer cube texture format
        * @param {number} anisotropy Can improve the renderer cube texture quality. Higher values mean better quality textures (max 16 at this time).
        * @param {boolean} depthBuffer If true, this render target will maintain a depth buffers
        * @param {boolean} stencilBuffer If true, this render target will maintain a stencil buffers
        * @param {boolean} renderDepthToTexture If true, this render target will create a depth textures (Not well supported)
        */
        function CubeRenderer(width, height, type, wrapS, wrapT, magFilter, minFilter, format, anisotropy, depthBuffer, stencilBuffer, renderDepthToTexture) {
            if (magFilter === void 0) { magFilter = Trike.TextureFilter.Linear; }
            if (minFilter === void 0) { minFilter = Trike.TextureFilter.NearestMipMapLinear; }
            if (anisotropy === void 0) { anisotropy = 1; }
            if (depthBuffer === void 0) { depthBuffer = true; }
            if (stencilBuffer === void 0) { stencilBuffer = true; }
            if (renderDepthToTexture === void 0) { renderDepthToTexture = false; }
            _super.call(this);
            this.cubeTarget = new Trike.RenderTargetCube(width, height, type, wrapS, wrapT, magFilter, minFilter, format, anisotropy, depthBuffer, stencilBuffer, renderDepthToTexture);
            this.cubeTarget.generateMipmaps = true;
            this._camRef = null;
            this.passCollection = new Trike.PassCollection();
            this.passCollection.initialize(width, height);
            this.setupCameras();
        }
        /**
        * Resizes the mirror so that it uses
        * @param {number} val
        */
        CubeRenderer.prototype.resize = function (val) {
            this.passCollection.setSize(val, val);
            this.cubeTarget.resize(val, val);
        };
        /**
        * Activates a cube side and fetches the camera for drawing it.
        */
        CubeRenderer.prototype.activateCamera = function (index) {
            var cubeTarget = this.cubeTarget;
            cubeTarget.activeCubeFace = index;
            if (index === 0)
                return this._atmosphereCamPX;
            if (index === 1)
                return this._atmosphereCamNX;
            if (index === 2)
                return this._atmosphereCamPY;
            if (index === 3)
                return this._atmosphereCamNY;
            if (index === 4)
                return this._atmosphereCamPZ;
            if (index === 5)
                return this._atmosphereCamNZ;
            return null;
        };
        /**
        * Cleans up the object for garbage collection
        */
        CubeRenderer.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.passCollection.dispose();
            this.cubeTarget.dispose();
            this._atmosphereCamPX.dispose();
            this._atmosphereCamNX.dispose();
            this._atmosphereCamPY.dispose();
            this._atmosphereCamNY.dispose();
            this._atmosphereCamPZ.dispose();
            this._atmosphereCamNZ.dispose();
            this.cubeTarget = null;
            this._atmosphereCamPX = null;
            this._atmosphereCamNX = null;
            this._atmosphereCamPY = null;
            this._atmosphereCamNY = null;
            this._atmosphereCamPZ = null;
            this._atmosphereCamNZ = null;
            this.passCollection = null;
            this._camArray = null;
            _super.prototype.dispose.call(this);
        };
        /*
        * Called before the cube rendering process - updates the cameras to reflect the target's
        */
        CubeRenderer.prototype.updateCameras = function () {
            var camera = this._camRef;
            if (!camera)
                return;
            if (camera.disposed) {
                this._camRef = null;
                return;
            }
            var cameras = this._camArray;
            for (var i = 0, l = cameras.length; i < l; i++) {
                cameras[i].near = camera.near;
                cameras[i].far = camera.far;
                cameras[i].compositionMaterial.fogColor(camera.compositionMaterial.fogColor());
                cameras[i].compositionMaterial.fogDensity(camera.compositionMaterial.fogDensity());
                cameras[i].compositionMaterial.fogHeightDensity(camera.compositionMaterial.fogHeightDensity());
                cameras[i].compositionMaterial.fogHeightMax(camera.compositionMaterial.fogHeightMax());
                cameras[i].compositionMaterial.fogHeightMin(camera.compositionMaterial.fogHeightMin());
                cameras[i].compositionMaterial.fogType(camera.compositionMaterial.fogType());
                cameras[i].compositionMaterial.fogConvolver(camera.compositionMaterial.fogConvolver());
            }
        };
        /*
        * Sets the camera reference from which the renderer gets its camera properties from. This is optional
        * but can be useful if the renderer is meant to have the same effects as an active camera
        * @param {CameraPerspective | CameraCombined} camera
        */
        CubeRenderer.prototype.cameraReference = function (camera) {
            this._camRef = camera;
        };
        /*
        * Gets or sets the cameras far distance
        * @param {number} val [Optional]
        * @returns {number}
        */
        CubeRenderer.prototype.far = function (val) {
            if (val === undefined)
                return this._atmosphereCamPX.far;
            var cameras = this._camArray;
            for (var i = 0, l = cameras.length; i < l; i++)
                cameras[i].near = val;
            return val;
        };
        /*
        * Gets or sets the cameras near distance
        * @param {number} val [Optional]
        * @returns {number}
        */
        CubeRenderer.prototype.near = function (val) {
            if (val === undefined)
                return this._atmosphereCamPX.near;
            var cameras = this._camArray;
            for (var i = 0, l = cameras.length; i < l; i++)
                cameras[i].far = val;
            return val;
        };
        /*
        * Sets up the cameras for the cube rendering
        */
        CubeRenderer.prototype.setupCameras = function (near, far) {
            if (near === void 0) { near = 0.5; }
            if (far === void 0) { far = 20000; }
            this._atmosphereCamPX = new Trike.CameraPerspective(90, 1, near, far);
            this._atmosphereCamPX.up.set(0, -1, 0);
            this._atmosphereCamPX.lookAt(new Trike.Vec3(1, 0, 0));
            this._atmosphereCamPX.updateWorldMatrix(true);
            this._atmosphereCamPX.updateProjectionMatrix();
            this._atmosphereCamNX = new Trike.CameraPerspective(90, 1, near, far, this._atmosphereCamPX.passes);
            this._atmosphereCamNX.up.set(0, -1, 0);
            this._atmosphereCamNX.lookAt(new Trike.Vec3(-1, 0, 0));
            this._atmosphereCamNX.updateWorldMatrix(true);
            this._atmosphereCamNX.updateProjectionMatrix();
            this._atmosphereCamPY = new Trike.CameraPerspective(90, 1, near, far, this._atmosphereCamPX.passes);
            this._atmosphereCamPY.up.set(0, 0, 1);
            this._atmosphereCamPY.lookAt(new Trike.Vec3(0, 1, 0));
            this._atmosphereCamPY.updateWorldMatrix(true);
            this._atmosphereCamPY.updateProjectionMatrix();
            this._atmosphereCamNY = new Trike.CameraPerspective(90, 1, near, far, this._atmosphereCamPX.passes);
            this._atmosphereCamNY.up.set(0, 0, -1);
            this._atmosphereCamNY.lookAt(new Trike.Vec3(0, -1, 0));
            this._atmosphereCamNY.updateWorldMatrix(true);
            this._atmosphereCamNY.updateProjectionMatrix();
            this._atmosphereCamPZ = new Trike.CameraPerspective(90, 1, near, far, this._atmosphereCamPX.passes);
            this._atmosphereCamPZ.up.set(0, -1, 0);
            this._atmosphereCamPZ.lookAt(new Trike.Vec3(0, 0, 1));
            this._atmosphereCamPZ.updateWorldMatrix(true);
            this._atmosphereCamPZ.updateProjectionMatrix();
            this._atmosphereCamNZ = new Trike.CameraPerspective(90, 1, near, far, this._atmosphereCamPX.passes);
            this._atmosphereCamNZ.up.set(0, -1, 0);
            this._atmosphereCamNZ.lookAt(new Trike.Vec3(0, 0, -1));
            this._atmosphereCamNZ.updateWorldMatrix(true);
            this._atmosphereCamNZ.updateProjectionMatrix();
            this.add(this._atmosphereCamPX);
            this.add(this._atmosphereCamNX);
            this.add(this._atmosphereCamPY);
            this.add(this._atmosphereCamNY);
            this.add(this._atmosphereCamPZ);
            this.add(this._atmosphereCamNZ);
            this._camArray = [this._atmosphereCamPX,
                this._atmosphereCamNX,
                this._atmosphereCamPY,
                this._atmosphereCamNY,
                this._atmosphereCamPZ,
                this._atmosphereCamNZ];
            var cameras = this._camArray;
            for (var i = 0, l = cameras.length; i < l; i++)
                cameras[i].compositionMaterial.toneMapper(Trike.ToneMapper.None);
        };
        return CubeRenderer;
    }(Trike.Object3D));
    Trike.CubeRenderer = CubeRenderer;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    var PassCollection = (function () {
        function PassCollection() {
            this._allPasses = [];
            this.gBuffer2Pass = null;
            this.gBufferPass = null;
            this.lightPass = null;
            this.tLightPass = null;
            this.skyPass = null;
            this.texturePass = null;
            this.shadowLightPass = null;
            this.shadowMapPass = null;
            this.compositionPass = null;
            this.framePass = null;
        }
        PassCollection.prototype.initialize = function (width, height) {
            this.width = width;
            this.height = height;
            this._allPasses = [
                this.gBuffer2Pass = new Trike.GBuffer2Pass(width, height),
                this.gBufferPass = new Trike.GBufferPass(width, height),
                this.lightPass = new Trike.LightPass(width, height, false),
                this.tLightPass = new Trike.LightPass(width, height, true),
                this.skyPass = new Trike.SkyPass(null),
                this.texturePass = new Trike.TexturePass(),
                this.shadowLightPass = new Trike.ShadowLightPass(),
                this.shadowMapPass = new Trike.RenderPass(null, new Trike.RenderTarget(width, height, Trike.TextureType.UnsignedIntType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Nearest, Trike.TextureFilter.Nearest, Trike.TextureFormat.RGBAFormat, 1, true, true), Trike.PassType.ShadowPass),
                this.compositionPass = new Trike.ScreenPass(new Trike.RenderTarget(width, height, Trike.TextureType.HalfFloatType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Nearest, Trike.TextureFilter.Nearest, Trike.TextureFormat.RGBAFormat, 1, true, true)),
                this.framePass = new Trike.FramePass(this.compositionPass.renderTarget)
            ];
            // The material and light passes share the same depth / stencil buffer as the normal
            this.shadowMapPass.renderTarget.sharedRenderBuffer = this.gBufferPass.renderTarget;
            this.gBuffer2Pass.renderTarget.sharedRenderBuffer = this.gBufferPass.renderTarget;
            this.lightPass.renderTarget.sharedRenderBuffer = this.gBufferPass.renderTarget;
            this.tLightPass.renderTarget.sharedRenderBuffer = this.gBufferPass.renderTarget;
            this.compositionPass.renderTarget.sharedRenderBuffer = this.gBufferPass.renderTarget;
            return true;
        };
        /**
        * Sets the base size for all passes
        * @param {number} width The new width
        * @param {number} height The new height
        */
        PassCollection.prototype.setSize = function (width, height) {
            this.width = width;
            this.height = height;
            for (var i = 0, l = this._allPasses.length; i < l; i++)
                this._allPasses[i].resize(width, height);
        };
        /**
        * Cleans up the renderer
        */
        PassCollection.prototype.dispose = function () {
            for (var i = 0, l = this._allPasses.length; i < l; i++)
                this._allPasses[i].dispose();
            this._allPasses = null;
            this.gBuffer2Pass = null;
            this.gBufferPass = null;
            this.lightPass = null;
            this.tLightPass = null;
            this.skyPass = null;
            this.texturePass = null;
            this.shadowLightPass = null;
            this.shadowMapPass = null;
            this.compositionPass = null;
            this.framePass = null;
        };
        return PassCollection;
    }());
    Trike.PassCollection = PassCollection;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A skybox is a Mesh that typically uses a cube / sphere or planar geometry that is very large so as to mimic a sky covering the scene.
    */
    var Skybox = (function (_super) {
        __extends(Skybox, _super);
        /**
        * Creates a Skybox instance
        */
        function Skybox(size) {
            if (size === void 0) { size = 100000; }
            _super.call(this, new Trike.MaterialSkybox(), null);
            this._material.depthRead = false;
            this._material.depthWrite = false;
            this._skyTexture = null;
            this._geomCube = new Trike.GeometryCube(1, 1, 1);
            this.setGeometry(this._geomCube);
            this.size(size);
            this._prevFar = 0;
            this.sceneCull = false;
            this._prevCamPos = new Trike.Vec3();
            this.pickable = false;
            this.castShadows(false);
        }
        /*
        * Gets or sets the brightness of the sky
        * @param {number} val [Optional]
        * @returns {number}
        */
        Skybox.prototype.brightness = function (val) {
            if (val === undefined)
                return this.material._uniforms['brightness'].value;
            this.material.setUniform('brightness', val, true);
            return val;
        };
        /*
        * Gets or sets the sky texture
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        Skybox.prototype.skyTexture = function (val) {
            if (val === undefined)
                return this._skyTexture;
            if (this._skyTexture && val) {
                this._skyTexture = val;
                this._material.setUniform('skybox', val, true);
            }
            else if (!this._skyTexture && val) {
                this._skyTexture = val;
                this._material.addUniform(new Trike.UniformVar('skybox', Trike.UniformType.TEXTURE_CUBE, val));
                this._material.addUniform(new Trike.UniformVar('modelMatrix', Trike.UniformType.MAT4), true);
                this._material.addDefine('#define USE_TEXTURE');
            }
            else {
                this._skyTexture = null;
                this._material.removeUniform('skybox');
                this._material.removeUniform('modelMatrix');
                this._material.removeDefine('#define USE_TEXTURE');
            }
            return val;
        };
        /*
        * Cleans up the references
        */
        Skybox.prototype.dispose = function () {
            this._geomCube.dispose();
            this._geomCube = null;
            _super.prototype.dispose.call(this);
        };
        /*
        * Called just before we render the mesh. The mesh would have passed culling and already be updated.
        * A good place to update custom uniforms.
        * @param {Renderer} renderer The renderer used to draw the scene
        * @param {RenderPass} renderPass The render pass associated with this call
        */
        Skybox.prototype.preRender = function (renderer, renderPass) {
            var camera = renderPass.camera;
            _super.prototype.preRender.call(this, renderer, renderPass);
            var far;
            var sizeHalf = this._worldSphere.radius;
            if (camera instanceof Trike.CameraCombined)
                far = camera.far;
            else if (camera instanceof Trike.CameraPerspective)
                far = camera.far;
            else if (camera instanceof Trike.CameraOrthographic)
                far = camera.far;
            if (sizeHalf > far) {
                this._prevFar = far;
                this.size(far - 1);
                this.updateWorldMatrix();
            }
            else
                this._prevFar = -1;
            // Get the current position
            this._prevCamPos.getPositionFromMatrix(camera.matrixWorldInverse);
            // Now set the position of the camera to be 0,0,0
            camera.matrixWorldInverse.elements[12] = 0;
            camera.matrixWorldInverse.elements[13] = 0;
            camera.matrixWorldInverse.elements[14] = 0;
        };
        /*
        * Called just after we render the mesh
        * @param {WebGLRenderingContext} gl The webgl context
        * @param {RenderPass} renderPass The render pass associated with this call
        */
        Skybox.prototype.postRender = function (gl, renderPass) {
            var camera = renderPass.camera;
            if (this._prevFar !== -1)
                this.size(this._prevFar);
            // Now revert the camera back
            camera.matrixWorldInverse.elements[12] = this._prevCamPos.x;
            camera.matrixWorldInverse.elements[13] = this._prevCamPos.y;
            camera.matrixWorldInverse.elements[14] = this._prevCamPos.z;
        };
        /*
        * Gets or sets the size of the cube
        * @param {number} val [Optional]
        * @returns {number}
        */
        Skybox.prototype.size = function (val) {
            if (val === undefined)
                return this._size;
            if (val === 0)
                val = 0.00001;
            this._size = val;
            this.setScale(val, val, val);
            return val;
        };
        return Skybox;
    }(Trike.Mesh));
    Trike.Skybox = Skybox;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Creates a simple sky box that draws a day / night component from cube maps.
    * A separate shader is used to first draw the skybox into a cube texture. The texture
    * is then used by the default skybox material. We do this to save some render cycles.
    */
    var SkyboxSimple = (function (_super) {
        __extends(SkyboxSimple, _super);
        /**
        * Creates a Skybox instance
        */
        function SkyboxSimple(textureSize) {
            if (textureSize === void 0) { textureSize = 1024; }
            _super.call(this);
            this.renderCount = 0;
            // Day
            this._day = null;
            this._dayColor = new Trike.Color(0x65A3E0);
            this._eulerDay = new Trike.Euler();
            // Night
            this._night = null;
            this._nightColor = new Trike.Color(0x1F3245);
            this._eulerNight = new Trike.Euler();
            // Other properties
            this._ratio = 1;
            this._fogHazeEnabled = false;
            this._fogMin = 0.4;
            this._fogMax = 0.6;
            this._fogColor = new Trike.Color(0xE3DBCA);
            // The material to draw the cube map
            this._skyMat = new Trike.MaterialSkySimple(this._dayColor, this._nightColor);
            // The day night Renderer
            this._cubeRenderer = new Trike.CubeRenderer(textureSize, textureSize, Trike.TextureType.UnsignedByteType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Linear, Trike.TextureFilter.NearestMipMapLinear, Trike.TextureFormat.RGBAFormat);
            this._cubeRenderer.far(2000000);
            this._cubeRenderer.cubeTarget.generateMipmaps = true;
            this._cubeRenderer.cubeTarget.anisotropy = 1;
            // Pass for drawing the cube
            this._pass = new Trike.RenderPass(this._skyMat, this._cubeRenderer.cubeTarget, Trike.PassType.Albedo);
            // Set the skybox default material properties
            this.dayColor(new Trike.Color(0xffffff));
            this.fogEnabled(false);
            this.ratio(1);
            // The mesh for drawing the sky material
            var mesh = new Trike.Mesh(this._skyMat, this.geometry);
            mesh.setScale(100000, 100000, 100000);
            mesh.updateWorldMatrix(true, true);
            this._skyMeshArr = [mesh];
            // Set the skybox texture
            this.skyTexture(this._cubeRenderer.cubeTarget);
        }
        /*
        * Gests the material responsible for rendering atmospheric scattering
        * @returns {MaterialSkySimple}
        */
        SkyboxSimple.prototype.skyMaterial = function () { return this._skyMat; };
        /*
        * Gets or sets the texture size of the cube texture we use to draw the atmosphere
        * @param {number} The size of the cube texture. Ideall should be a multiple of 2
        * @returns {number}
        */
        SkyboxSimple.prototype.textureSize = function (val) {
            if (val === undefined)
                return this._cubeRenderer.cubeTarget.width;
            this._cubeRenderer.cubeTarget.resize(val, val);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /**
        * Cleans up the object for garbage collection
        */
        SkyboxSimple.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._night = null;
            this._nightColor = null;
            this._eulerNight = null;
            this._day = null;
            this._dayColor = null;
            this._eulerDay = null;
            this._cubeRenderer.dispose();
            this._pass.dispose();
            this._skyMat.dispose();
            this._cubeRenderer = null;
            this._pass = null;
            this._skyMat = null;
            this._skyMeshArr = null;
        };
        /*
        * Use this function to perform any pre-renders. Useful if an object needs to do its own render pass before a
        * the render call begins.
        * @param {Scene} scene The scene  being rendered
        * @param {Camera} camera The camera beinf used to render the scene
        * @param {RenderTarget} renderTarget The render target the scene is being drawn to
        * @param {Renderer} renderer The renderer being used to draw the scene
        * @param {boolean} Returns false if an error occurred
        */
        SkyboxSimple.prototype.prepRender = function (scene, camera, renderTarget, renderer) {
            // If nothing needs update, then return
            if (!this._skyMat.uniformUpdated)
                return true;
            this._skyMat.uniformUpdated = false;
            this.renderCount++;
            // Setup the depth / stencil clears
            var clearDepth = renderer.autoClearDepth, clearStencil = renderer.autoClearStencil, pass = this._pass, meshArr = this._skyMeshArr, cubeRenderer = this._cubeRenderer;
            var c;
            renderer.autoClearDepth = true;
            renderer.autoClearStencil = true;
            // Turn off mipmaps for most of the targets
            var mipmaps = cubeRenderer.cubeTarget.generateMipmaps;
            cubeRenderer.cubeTarget.generateMipmaps = false;
            // Render the world into its 6 cube textures
            for (var i = 0; i < 6; i++) {
                c = cubeRenderer.activateCamera(i);
                if (i === 5)
                    cubeRenderer.cubeTarget.generateMipmaps = mipmaps;
                if (!renderer.renderObjects(meshArr, c, pass))
                    return false;
            }
            // Tell the skybox to use this environment texture
            this.skyTexture(cubeRenderer.cubeTarget);
            // Revert the clear values
            renderer.autoClearDepth = clearDepth;
            renderer.autoClearStencil = clearStencil;
            return true;
        };
        /*
        * Gets or sets if the fog haze is enabled
        * @param {boolean} val.
        * @returns {boolean}
        */
        SkyboxSimple.prototype.fogEnabled = function (val) {
            if (val === undefined)
                return this._fogHazeEnabled;
            if (this._fogHazeEnabled === val)
                return;
            this._fogHazeEnabled = val;
            if (val) {
                this._skyMat.addDefine('#define FOG');
                this._skyMat.addUniform(new Trike.UniformVar('fogMin', Trike.UniformType.FLOAT, this._fogMin));
                this._skyMat.addUniform(new Trike.UniformVar('fogMax', Trike.UniformType.FLOAT, this._fogMax));
                this._skyMat.addUniform(new Trike.UniformVar('fogColor', Trike.UniformType.COLOR3, this._fogColor));
            }
            else {
                this._skyMat.removeDefine('#define FOG');
                this._skyMat.removeUniform('fogMin');
                this._skyMat.removeUniform('fogMax');
                this._skyMat.removeUniform('fogColor');
            }
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /*
        * Gets or sets the haze fog lower limit (from 0 - 1)
        * @param {number} val.
        * @returns {number}
        */
        SkyboxSimple.prototype.fogMin = function (val) {
            if (val === undefined)
                return this._fogMin;
            this._fogMin = val;
            if (this._skyMat._uniforms['fogMin'])
                this._skyMat.setUniform('fogMin', val);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /*
        * Gets or sets the haze fog upper limit (from 0 - 1)
        * @param {number} val.
        * @returns {number}
        */
        SkyboxSimple.prototype.fogMax = function (val) {
            if (val === undefined)
                return this._fogMax;
            this._fogMax = val;
            if (this._skyMat._uniforms['fogMax'])
                this._skyMat.setUniform('fogMax', val);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /*
        * Gets or sets the color of the fog haze
        * @param {Color} val.
        * @returns {Color}
        */
        SkyboxSimple.prototype.fogColor = function (val) {
            if (val === undefined)
                return this._fogColor;
            this._fogColor = val;
            if (this._skyMat._uniforms['fogColor'])
                this._skyMat.setUniform('fogColor', val);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /*
        * Gest or sets the color multiplier for day
        * @param {Color} val
        * @returns {Color}
        */
        SkyboxSimple.prototype.dayColor = function (val) {
            if (val === undefined)
                return this._skyMat._uniforms['dayColor'].value;
            this._skyMat.setUniform('dayColor', val);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /*
        * Sets the cube texture or render target that is drawn for day time
        * @param {TextureBase} val The texture can be either a RenderTargetCube or a CubeTexture
        * @returns {TextureBase} The texture can be either a RenderTargetCube or a CubeTexture
        */
        SkyboxSimple.prototype.day = function (val) {
            if (val === undefined)
                return this._day;
            if (this._day && val) {
                this._day = val;
                this._skyMat.setUniform('daySampler', val);
            }
            else if (!this._day && val) {
                this._day = val;
                this._skyMat.addUniform(new Trike.UniformVar('daySampler', Trike.UniformType.TEXTURE_CUBE, val));
                this._skyMat.addUniform(new Trike.UniformVar('quatDay', Trike.UniformType.QUAT, this._eulerDay._quaternion));
                this._skyMat.addDefine(Trike.ShaderDefines.DAY_MAP);
            }
            else {
                this._day = null;
                this._skyMat.removeUniform('daySampler');
                this._skyMat.removeUniform('quatDay');
                this._skyMat.removeDefine(Trike.ShaderDefines.DAY_MAP);
            }
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /*
        * Gets or sets the ratio of day to night. 0 Is fully daylight and 1 is fully night
        * @param {number} val A normalised value usually from 0 to 1
        * @returns {number} A normalised value usually from 0 to 1
        */
        SkyboxSimple.prototype.ratio = function (val) {
            if (val === undefined)
                return this._ratio;
            if (this._ratio === val)
                return;
            this._ratio = val;
            this._skyMat.setUniform('ratio', val);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /**
        * Gets or sets the rotation euler of the day cube texture
        * @param {Euler} val The euler object
        * @returns {Euler}
        */
        SkyboxSimple.prototype.eulerDay = function (val) {
            if (val === undefined)
                return this._eulerDay;
            this._eulerDay = val;
            if (!this._day)
                return;
            this._skyMat.setUniform('quatDay', val._quaternion);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /*
        * Gets or sets the cube texture or render target that is drawn for day time
        * @param {TextureBase} val The texture can be either a RenderTargetCube or a CubeTexture
        * @returns {TextureBase} The texture can be either a RenderTargetCube or a CubeTexture
        */
        SkyboxSimple.prototype.night = function (val) {
            if (val === undefined)
                return this._night;
            if (this._night && val) {
                this._night = val;
                this._skyMat.setUniform('nightSampler', val);
            }
            else if (!this._night && val) {
                this._night = val;
                this._skyMat.addUniform(new Trike.UniformVar('nightSampler', Trike.UniformType.TEXTURE_CUBE, val));
                this._skyMat.addUniform(new Trike.UniformVar('quatNight', Trike.UniformType.QUAT, this._eulerNight._quaternion));
                this._skyMat.addDefine(Trike.ShaderDefines.NIGHT_MAP);
            }
            else {
                this._night = null;
                this._skyMat.removeUniform('nightSampler');
                this._skyMat.removeUniform('quatNight');
                this._skyMat.removeDefine(Trike.ShaderDefines.NIGHT_MAP);
            }
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /**
        * Gets or sets the rotation euler of the night skybox
        * @param {Euler} val The euler object
        * @returns {Euler} The euler object
        */
        SkyboxSimple.prototype.eulerNight = function (val) {
            if (val === undefined)
                return this._eulerNight;
            this._eulerNight = val;
            if (!this._night)
                return;
            this._skyMat.setUniform('quatNight', val._quaternion);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /*
        * Gest or sets the color multiplier for night
        * @param {Color} val
        * @returns {Color}
        */
        SkyboxSimple.prototype.nightColor = function (val) {
            if (val === undefined)
                return this._skyMat._uniforms['nightColor'].value;
            this._skyMat.setUniform('nightColor', val);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        return SkyboxSimple;
    }(Trike.Skybox));
    Trike.SkyboxSimple = SkyboxSimple;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Creates a realistic skybox using planet & light scattering algorithms.
    * A separate scattering shader is used to first draw the skybox into a cube texture. The texture
    * is then used by the default skybox material. We do this to save some render cycles.
    * Inspired from the article by Sean O'Neil
    * http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html
    */
    var SkyboxAtmospheric = (function (_super) {
        __extends(SkyboxAtmospheric, _super);
        /**
        * Creates a Skybox instance
        */
        function SkyboxAtmospheric(textureSize) {
            if (textureSize === void 0) { textureSize = 1024; }
            _super.call(this);
            //
            this.renderCount = 0;
            // Night properties
            this._night = null;
            this._nightColor = new Trike.Color(0x1F3245);
            this._eulerNight = new Trike.Euler();
            // Night fog properties
            this._fogHazeEnabled = false;
            this._fogMin = 0.4;
            this._fogMax = 0.6;
            this._fogColor = new Trike.Color(0xE3DBCA);
            // Scattering sun properties
            this._sunPosition = new Trike.Vec3();
            this._sunDistance = 400000;
            // The material to draw the scattering
            this._skyMat = new Trike.MaterialSkyAtmospheric();
            // The scattering renderer
            this._cubeRenderer = new Trike.CubeRenderer(textureSize, textureSize, Trike.TextureType.HalfFloatType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Linear, Trike.TextureFilter.NearestMipMapLinear, Trike.TextureFormat.RGBAFormat);
            this._cubeRenderer.far(2000000);
            this._cubeRenderer.cubeTarget.generateMipmaps = true;
            this._cubeRenderer.cubeTarget.anisotropy = 1;
            // Pass for drawing the scattering
            this._pass = new Trike.RenderPass(this._skyMat, this._cubeRenderer.cubeTarget, Trike.PassType.Albedo);
            // Creating the drawables for the scattering
            this._atmosphere = new Trike.GeometrySphere(450000, 32, 15);
            this._atmosphereMesh = new Trike.Mesh(this._skyMat, this._atmosphere);
            this._atmosphereArr = [this._atmosphereMesh];
            this._atmosphereMesh.updateWorldMatrix(true, true);
            // Set the initial values
            this.inclination(0.49);
            this.azimuth(0.25);
            this.nightFogEnabled(false);
            // Set the skybox texture
            this.skyTexture(this._cubeRenderer.cubeTarget);
        }
        /*
        * Gests the material responsible for rendering atmospheric scattering
        * @returns {MaterialSkyAtmospheric}
        */
        SkyboxAtmospheric.prototype.atmosphericShader = function () { return this._skyMat; };
        /*
        * Gets or sets the texture size of the cube texture we use to draw the atmosphere
        * @param {number} The size of the cube texture. Ideall should be a multiple of 2
        * @returns {number}
        */
        SkyboxAtmospheric.prototype.textureSize = function (val) {
            if (val === undefined)
                return this._cubeRenderer.cubeTarget.width;
            this._cubeRenderer.resize(val);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /**
        * Cleans up the object for garbage collection
        */
        SkyboxAtmospheric.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._night = null;
            this._eulerNight = null;
            this._nightColor = null;
            this._cubeRenderer.dispose();
            this._pass.dispose();
            this._skyMat.dispose();
            this._atmosphere.dispose();
            this._atmosphereMesh.dispose();
            this._cubeRenderer = null;
            this._pass = null;
            this._atmosphereMesh = null;
            this._atmosphereArr = null;
            this._sunPosition = null;
            this._skyMat = null;
            this._atmosphere = null;
            this._atmosphereMesh = null;
        };
        /*
        * Use this function to perform any pre-renders. Useful if an object needs to do its own render pass before a
        * the render call begins.
        * @param {Scene} scene The scene  being rendered
        * @param {Camera} camera The camera beinf used to render the scene
        * @param {RenderTarget} renderTarget The render target the scene is being drawn to
        * @param {Renderer} renderer The renderer being used to draw the scene
        * @param {boolean} Returns false if an error occurred
        */
        SkyboxAtmospheric.prototype.prepRender = function (scene, camera, renderTarget, renderer) {
            // If nothing needs update, then return
            if (!this._skyMat.uniformUpdated)
                return true;
            this._skyMat.uniformUpdated = false;
            this.renderCount++;
            // Setup the depth / stencil clears
            var clearDepth = renderer.autoClearDepth, clearStencil = renderer.autoClearStencil, pass = this._pass, cubeRenderer = this._cubeRenderer, meshArr = this._atmosphereArr;
            var c;
            // Set the depth and stencil properties
            renderer.autoClearDepth = true;
            renderer.autoClearStencil = true;
            // Turn off mipmaps for most of the targets
            var mipmaps = pass.renderTarget.generateMipmaps;
            pass.renderTarget.generateMipmaps = false;
            // Render the world into its 6 cube textures
            for (var i = 0; i < 6; i++) {
                c = cubeRenderer.activateCamera(i);
                if (i === 5)
                    pass.renderTarget.generateMipmaps = mipmaps;
                if (!renderer.renderObjects(meshArr, c, pass))
                    return false;
            }
            // Set the skybox texture
            this.skyTexture(cubeRenderer.cubeTarget);
            // Revert the clear values
            renderer.autoClearDepth = clearDepth;
            renderer.autoClearStencil = clearStencil;
            return true;
        };
        /**
        * Calculates the sun position for the scattering shader
        */
        SkyboxAtmospheric.prototype.calculateSunPosition = function () {
            var theta = Math.PI * (this._inclination - 0.5);
            var phi = 2 * Math.PI * (this._azimuth - 0.5);
            this._sunPosition.x = this._sunDistance * Math.cos(phi);
            this._sunPosition.y = this._sunDistance * Math.sin(phi) * Math.sin(theta);
            this._sunPosition.z = this._sunDistance * Math.sin(phi) * Math.cos(theta);
            this._skyMat.setUniform('sunPosition', this._sunPosition, true);
            this._skyMat.uniformUpdated = true;
        };
        /**
        * Gets or sets the sun inclination
        * @param {number} val [Optional] In radians
        * @returns {number}
        */
        SkyboxAtmospheric.prototype.inclination = function (val) {
            if (val === undefined)
                return this._inclination;
            this._inclination = val;
            this.calculateSunPosition();
            return val;
        };
        /**
        * Gets or sets the sun azimuth - The azimuth is the angle between the north vector
        * and the perpendicular projection of the star down onto the horizon.
        * @param {number} val [Optional] In radians
        * @returns {number}
        */
        SkyboxAtmospheric.prototype.azimuth = function (val) {
            if (val === undefined)
                return this._azimuth;
            this._azimuth = val;
            this.calculateSunPosition();
            return val;
        };
        /**
        * Gets or sets the atmosphere turbidity - which is the cloudiness or haziness of the atmosphere
        * @param {number} val [Optional]
        * @returns {number}
        */
        SkyboxAtmospheric.prototype.turbidity = function (val) {
            if (val === undefined)
                return this._skyMat._uniforms['turbidity'].value;
            this._skyMat.setUniform('turbidity', val, true);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /**
        * Gets or sets the reileigh factor of the atmosphere
        * @param {number} val [Optional]
        * @returns {number}
        */
        SkyboxAtmospheric.prototype.reileigh = function (val) {
            if (val === undefined)
                return this._skyMat._uniforms['reileigh'].value;
            this._skyMat.setUniform('reileigh', val, true);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /**
        * Gets or sets the mie coefficient factor of the atmosphere
        * @param {number} val [Optional]
        * @returns {number}
        */
        SkyboxAtmospheric.prototype.mieCoefficient = function (val) {
            if (val === undefined)
                return this._skyMat._uniforms['mieCoefficient'].value;
            this._skyMat.setUniform('mieCoefficient', val, true);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /**
        * Gets or sets the sky alpha. The alpha multiplier helps determine the ratio of day texture to night
        * @param {number} val [Optional]
        * @returns {number}
        */
        SkyboxAtmospheric.prototype.alpha = function (val) {
            if (val === undefined)
                return this._skyMat._uniforms['alpha'].value;
            this._skyMat.setUniform('alpha', val, true);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /**
        * Gets or sets the mie direction factor of the atmosphere
        * @param {number} val [Optional]
        * @returns {number}
        */
        SkyboxAtmospheric.prototype.mieDirectional = function (val) {
            if (val === undefined)
                return this._skyMat._uniforms['mieDirectional'].value;
            this._skyMat.setUniform('mieDirectionalG', val, true);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /**
        * Gets or sets the luminance factor of the atmosphere
        * @param {number} val [Optional]
        * @returns {number}
        */
        SkyboxAtmospheric.prototype.luminance = function (val) {
            if (val === undefined)
                return this._skyMat._uniforms['luminance'].value;
            this._skyMat.setUniform('luminance', val, true);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /*
        * Gets or sets the cube texture or render target that is drawn for day time
        * @param {TextureBase} val The texture can be either a RenderTargetCube or a CubeTexture
        * @returns {TextureBase} The texture can be either a RenderTargetCube or a CubeTexture
        */
        SkyboxAtmospheric.prototype.night = function (val) {
            if (val === undefined)
                return this._night;
            if (this._night && val) {
                this._night = val;
                this._skyMat.setUniform('night', val);
            }
            else if (!this._night && val) {
                this._night = val;
                this._skyMat.addUniform(new Trike.UniformVar('night', Trike.UniformType.TEXTURE_CUBE, val));
                this._skyMat.addUniform(new Trike.UniformVar('quatNight', Trike.UniformType.QUAT, this._eulerNight._quaternion));
                this._skyMat.addDefine(Trike.ShaderDefines.NIGHT_MAP);
            }
            else {
                this._night = null;
                this._skyMat.removeUniform('night');
                this._skyMat.removeUniform('quatNight');
                this._skyMat.removeDefine(Trike.ShaderDefines.NIGHT_MAP);
            }
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /*
        * Gets or sets the color of the fog haze eminating from the earth
        * @param {Color} val.
        * @returns {Color}
        */
        SkyboxAtmospheric.prototype.earthAmbience = function (val) {
            if (val === undefined)
                return this._fogColor;
            this._fogColor = val;
            if (this._skyMat._uniforms['earthAmbience'])
                this._skyMat.setUniform('earthAmbience', val);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /**
        * Gets or sets the rotation euler of the night skybox
        * @param {Euler} val The euler object
        * @returns {Euler} The euler object
        */
        SkyboxAtmospheric.prototype.eulerNight = function (val) {
            if (val === undefined)
                return this._eulerNight;
            this._eulerNight = val;
            if (!this._night)
                return;
            this._skyMat.setUniform('quatNight', val._quaternion);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /*
        * Gest or sets the color multiplier for night
        * @param {Color} val
        * @returns {Color}
        */
        SkyboxAtmospheric.prototype.nightColor = function (val) {
            if (val === undefined)
                return this._skyMat._uniforms['nightColor'].value;
            this._skyMat.setUniform('nightColor', val);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /*
        * Gets or sets if the fog haze is enabled
        * @param {boolean} val.
        * @returns {boolean}
        */
        SkyboxAtmospheric.prototype.nightFogEnabled = function (val) {
            if (val === undefined)
                return this._fogHazeEnabled;
            if (this._fogHazeEnabled === val)
                return;
            this._fogHazeEnabled = val;
            if (val) {
                this._skyMat.addDefine('#define FOG');
                this._skyMat.addUniform(new Trike.UniformVar('fogMin', Trike.UniformType.FLOAT, this._fogMin));
                this._skyMat.addUniform(new Trike.UniformVar('fogMax', Trike.UniformType.FLOAT, this._fogMax));
                this._skyMat.addUniform(new Trike.UniformVar('fogColor', Trike.UniformType.COLOR3, this._fogColor));
            }
            else {
                this._skyMat.removeDefine('#define FOG');
                this._skyMat.removeUniform('fogMin');
                this._skyMat.removeUniform('fogMax');
                this._skyMat.removeUniform('fogColor');
            }
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /*
        * Gets or sets the haze fog lower limit (from 0 - 1)
        * @param {number} val.
        * @returns {number}
        */
        SkyboxAtmospheric.prototype.nightFogMin = function (val) {
            if (val === undefined)
                return this._fogMin;
            this._fogMin = val;
            if (this._skyMat._uniforms['fogMin'])
                this._skyMat.setUniform('fogMin', val);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /*
        * Gets or sets the haze fog upper limit (from 0 - 1)
        * @param {number} val.
        * @returns {number}
        */
        SkyboxAtmospheric.prototype.nightFogMax = function (val) {
            if (val === undefined)
                return this._fogMax;
            this._fogMax = val;
            if (this._skyMat._uniforms['fogMax'])
                this._skyMat.setUniform('fogMax', val);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        /*
        * Gets or sets the color of the fog haze
        * @param {Color} val.
        * @returns {Color}
        */
        SkyboxAtmospheric.prototype.nightFogColor = function (val) {
            if (val === undefined)
                return this._fogColor;
            this._fogColor = val;
            if (this._skyMat._uniforms['fogColor'])
                this._skyMat.setUniform('fogColor', val);
            this._skyMat.uniformUpdated = true;
            return val;
        };
        return SkyboxAtmospheric;
    }(Trike.Skybox));
    Trike.SkyboxAtmospheric = SkyboxAtmospheric;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    var KeySetRef = (function () {
        function KeySetRef() {
        }
        return KeySetRef;
    }());
    Trike.KeySetRef = KeySetRef;
    var KeySet = (function () {
        function KeySet() {
            this.prevKey = new KeySetRef();
            this.nextKey = new KeySetRef();
        }
        return KeySet;
    }());
    Trike.KeySet = KeySet;
    /**
    * Represents a bone that transforms vertices in a skinned mesh.
    * It acts pretty the same a bone in real life.
    */
    var Bone = (function (_super) {
        __extends(Bone, _super);
        /**
        * Creates a bone and assigngs its mesh
        * @param {MeshSkinned} mesh The mesh associated with this bone
        */
        function Bone(mesh) {
            _super.call(this);
            this.mesh = mesh;
            this.skinMatrix = new Trike.Matrix4();
            this.activeKeySets = {};
        }
        /**
        * Fills the values of the bone from a geometry bone
        * @param {BoneInfo} gBone The node we are getting data from
        */
        Bone.prototype.setFromBoneInfo = function (gBone) {
            this.name = gBone.name;
            this.position.set(gBone.position[0], gBone.position[1], gBone.position[2]);
            this.quaternion.set(gBone.rotation[0], gBone.rotation[1], gBone.rotation[2], gBone.rotation[3]);
            if (gBone.scale !== undefined)
                this.scale.set(gBone.scale[0], gBone.scale[1], gBone.scale[2]);
            else
                this.scale.set(1, 1, 1);
        };
        /**
        * Overloaded the update world matrix for bones. We need to set the skin matrix
        * @param {boolean} forceWorldUpdate If true, the world matrices will be forced to update
        * @param {boolean} forceLocalUpdate If true, the local matrices will be forced to update
        */
        Bone.prototype.updateWorldMatrix = function (forceWorldUpdate, forceLocalUpdate) {
            if (forceWorldUpdate === void 0) { forceWorldUpdate = false; }
            if (forceLocalUpdate === void 0) { forceLocalUpdate = false; }
            var skinMatrix = this.skinMatrix;
            if (this.updateMatrix) {
                this.matrix.compose(this.position, this.quaternion, this.scale);
                this.updateMatrix = false;
                forceWorldUpdate = true;
            }
            if (this.updateMatrixWorld || forceWorldUpdate) {
                // Added for the skin matrix
                if (this.parent instanceof Trike.MeshSkinned)
                    skinMatrix.multiplyMatrices(Trike.MeshSkinned.indentityMatrix, this.matrix);
                else if (this.parent instanceof Bone)
                    skinMatrix.multiplyMatrices(this.parent.skinMatrix, this.matrix);
                else
                    skinMatrix.copy(this.matrix);
                var worldMat = this.worldMatrix;
                if (this.parent)
                    worldMat.multiplyMatrices(this.parent.worldMatrix, this.matrix);
                else
                    worldMat.copy(this.matrix);
                this.updateMatrixWorld = false;
                forceWorldUpdate = true;
            }
            // update children
            var children = this.children;
            for (var i = 0, l = children.length; i < l; i++)
                children[i].updateWorldMatrix(forceWorldUpdate, forceLocalUpdate);
        };
        /**
        * Cleans up and nullifies the bone
        */
        Bone.prototype.dispose = function () {
            if (this.parent)
                this.parent.remove(this);
            _super.prototype.dispose.call(this);
            this.name = null;
            this.mesh = null;
            this.skinMatrix = null;
        };
        return Bone;
    }(Trike.Object3D));
    Trike.Bone = Bone;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    (function (TransparencyQuality) {
        TransparencyQuality[TransparencyQuality["SinglePass"] = 0] = "SinglePass";
        TransparencyQuality[TransparencyQuality["Multipass"] = 1] = "Multipass";
    })(Trike.TransparencyQuality || (Trike.TransparencyQuality = {}));
    var TransparencyQuality = Trike.TransparencyQuality;
    /**
    * The renderer class can be used to render a 3D scene.
    */
    var Renderer = (function () {
        /**
        * Creates an instance of the Renderer
        */
        function Renderer() {
            if (!Renderer._matrix) {
                Renderer._matrix = new Trike.Matrix4();
                Renderer._v = new Trike.Vec3();
            }
            this._glContext = null;
            this._statPopup = null;
            this._errors = '';
            this._clearColor = Trike.Color.darkgray();
            this._clearAlpha = 1;
            this._depthTest = true;
            this._prevProgram = null;
            this._prevMaterial = null;
            this._prevGeometry = null;
            this._prevCullMode = null;
            this._currentFramebuffer = null;
            this._drawingMirrorPasses = false;
            this._curMirror = null;
            this._curCube = null;
            this._resizeId = 1;
            this._texSlotArray = [];
            this._corners = new Trike.FrustumCorners();
            this.drawingCubeTargets = false;
            this.autoClearColor = true;
            this.autoClearDepth = true;
            this.autoClearStencil = false;
            this._prevDepthWrite = true;
            this._prevDepthRead = true;
            this._preLineWidth = 0;
            this._curTextureUnit = 0;
            this._texSlotMap = {};
            this._camPositionPos = new Trike.Vec3();
            this._timeElapsed = 0;
            this._timeDelta = 0;
            this._timePrev = 0;
            this._frameCount = 0;
            this._FPS = 0;
            this._FPSTimer = 0;
            this._frustum = new Trike.Frustum();
            this._viewport = { x: 0, y: 0, height: 500, width: 500 };
            this._activeAttributes = {};
            this.transparencyQuality = TransparencyQuality.Multipass;
        }
        /**
        * Creates and initializes the Webgl Context. Will return false if the webgl context fails
        * to initialize. Check the errors string for initialization errors.
        * @param {number} width The width of the renderer in pixels
        * @param {number} height The width of the renderer in pixels
        * @returns {boolean}
        */
        Renderer.prototype.initialize = function (width, height) {
            if (width === void 0) { width = 500; }
            if (height === void 0) { height = 500; }
            // Create the canvas object
            var canvas = document.createElement('canvas');
            if (!canvas)
                return false;
            this._width = width;
            this._height = height;
            canvas.width = width;
            canvas.height = height;
            this._canvas = canvas;
            var glContext = null;
            try {
                var attributes = {
                    alpha: false,
                    premultipliedAlpha: false,
                    antialias: false,
                    stencil: true,
                    preserveDrawingBuffer: false
                };
                glContext = (canvas.getContext('webgl', attributes) || canvas.getContext('experimental-webgl', attributes));
            }
            catch (e) {
                this._errors = 'Your browser does not seem to support webgl.';
                return false;
            }
            // No webgl support
            if (!glContext)
                return false;
            this._transparentObjects = [];
            this._visuals = [];
            this._shadowMeshes = [];
            this._shaderTextures = [];
            this._shadowLights = [];
            this._solidObjects = [];
            this._glContext = glContext;
            this.depthTest = true;
            this.clearColor = this._clearColor;
            this.setViewport();
            Trike.Capabilities.getSingleton(this._glContext);
            // We require floating point textures
            if (!Trike.Capabilities.getSingleton().glExtensionTextureFloat) {
                this._errors = 'Floating point textures required, but not supported.';
                return false;
            }
            // Setup defaults
            glContext.frontFace(glContext.CCW);
            glContext.cullFace(glContext.BACK);
            glContext.enable(glContext.CULL_FACE);
            glContext.clearStencil(0);
            // Create the passes
            this._SSQ = new Trike.SceneScreenQuad();
            this._defaultPassCollection = new Trike.PassCollection();
            this._defaultPassCollection.initialize(width, height);
            this._currentPassCollection = this._defaultPassCollection;
            this._screenPass = new Trike.ScreenPass(null);
            // Build the screen quad mesh geometry
            for (var i = 0, l = this._SSQ.meshes.length; i < l; i++) {
                if (this._SSQ.meshes[i]._geometry.buildGeometry(glContext) === false) {
                    this._errors = this._SSQ.meshes[i]._geometry.compileStatus;
                    return false;
                }
            }
            return true;
        };
        /**
        * Must be called before each call to render. Used to traverse the scene and do any pre-render updates
        * @param {Scene} scene The scene object to update
        * @param {Camera} camera The camera we are drawing the scene with
        */
        Renderer.prototype.update = function (scene, camera) {
            this._frameCount++;
            var now = new Date().getTime(), deltaTime = now - this._timePrev, shaderTextures = this._shaderTextures;
            this._timePrev = now;
            this._timeElapsed += deltaTime;
            this._timeDelta = deltaTime;
            this._FPSTimer += deltaTime;
            // Calculate the FPS
            if (this._FPSTimer >= 1000) {
                this._FPS = this._frameCount;
                this._frameCount = 0;
                this._FPSTimer = 0;
            }
            // Update all animated textures
            for (var i = 0, l = shaderTextures.length; i < l; i++)
                shaderTextures[i].update(this._timeElapsed, deltaTime, camera, this);
            scene.updateWorldMatrix();
            scene.update(this._timeElapsed, deltaTime, camera, this);
            if (this._statPopup)
                this._statPopup.innerHTML = 'FPS: ' + this._FPS.toString();
        };
        /**
        * Cleans up any resources that require buffers to be destroyed
        */
        Renderer.prototype.cleanupResources = function () {
            var gl = this._glContext;
            var toRemove = Renderer.resoucesToRemove;
            for (var i = 0, len = toRemove.length; i < len; i++)
                if (toRemove[i] instanceof Trike.TextureBase)
                    toRemove[i].destroyBuffers(gl);
                else if (toRemove[i] instanceof Trike.Geometry)
                    toRemove[i].destroyBuffers(gl);
            toRemove.splice(0, toRemove.length);
        };
        /**
        * Sorts the transparent meshes so that they are drawn from back to front
        * @param {Array<Mesh>} meshes The meshes to sort
        * @param {Camera} camera The camera to base the sorting on
        */
        Renderer.prototype.sortTransparents = function (meshes, camera) {
            var v = Renderer._v;
            var sortArray = Renderer._sortArray;
            var mesh;
            sortArray.splice(0, sortArray.length);
            for (var i = 0, l = meshes.length; i < l; i++) {
                v.getPositionFromMatrix(meshes[i].worldMatrix);
                v.project(camera, false);
                sortArray[i] = [v.z, i];
            }
            // Uses a fast sorting algorithm to sort the particles based on their distance to the camera
            sortArray = Trike.AdaptiveSort.sort(sortArray, 0);
            // We need to reverse the sort as its from closest to farthest
            sortArray = sortArray.reverse();
            for (var i = 0, l = sortArray.length; i < l; i++)
                meshes.push(meshes[sortArray[i][1]]);
            meshes.splice(0, sortArray.length);
        };
        /**
        * Call this to draw the scene. Returns false if a problem occurred with drawing the scene. Check
        * the errors string for causes.
        * @param {Scene} scene The scene to draw
        * @param {Camera} camera The camera to draw the scene with
        * @param {RenderTarget} renderTarget The optional texture to draw on
        * @returns {boolean}
        */
        Renderer.prototype.render = function (scene, camera, renderTarget) {
            var gl = this._glContext, transparentObjects = this._transparentObjects, shadowMeshes = this._shadowMeshes, allVisuals = scene.allVisuals, shaderTextures = this._shaderTextures, solidObjects = this._solidObjects, mirrors = scene.mirrors, cubeRenderers = scene.cubeRenderers, convolvers = scene.convolvers;
            var shaderTextureIndex = 0, visuals = this._visuals, mesh, geom, mat, matShaderTextures;
            this._renderCount = 0;
            // Clear perf arrays
            transparentObjects.splice(0, transparentObjects.length);
            solidObjects.splice(0, solidObjects.length);
            visuals.splice(0, visuals.length);
            shadowMeshes.splice(0, shadowMeshes.length);
            shaderTextures.splice(0, shaderTextures.length);
            visuals = visuals.concat(scene.meshes);
            visuals = visuals.concat(scene.pointClouds);
            // Enable stencil test
            gl.enable(gl.STENCIL_TEST);
            gl.enable(gl.DEPTH_TEST);
            this._prevDepthRead = true;
            this._drawingMirrorPasses = false;
            this._currentPassCollection = this._defaultPassCollection;
            // Clean up any objects that have been disposed.
            this.cleanupResources();
            // Build any geometry that needs to be built before we call update
            for (var i = 0, l = allVisuals.length; i < l; i++) {
                mesh = allVisuals[i];
                geom = mesh._geometry;
                if (mesh.visible && mesh.castShadows())
                    shadowMeshes.push(mesh);
                if (geom) {
                    // Check if the geometry has been updated
                    if (mesh.buildNumber !== geom.buildCount)
                        mesh.geometryUpdated(geom);
                    // Check if geometry needs to be rebuilt. If it fails then catch the error and return
                    if (geom.requiresBuild && geom.buildGeometry(gl) === false) {
                        this._errors = geom.compileStatus;
                        return false;
                    }
                    else if (geom.dirtyBuffers.length)
                        geom.updateDirtyBuffers(gl);
                }
                // Look for any shader materials that might need to be updated
                if (mesh.material) {
                    mat = mesh.material;
                    matShaderTextures = mat._shaderTextures;
                    for (var s = 0, sl = matShaderTextures.length; s < sl; s++) {
                        shaderTextureIndex = shaderTextures.indexOf(matShaderTextures[s]);
                        if (shaderTextureIndex === -1)
                            shaderTextures.push(matShaderTextures[s]);
                    }
                }
            }
            // Add the perspective lights
            for (var i = 0, l = scene.lightsPerspective.length; i < l; i++)
                visuals.push(scene.lightsPerspective[i]);
            // Update the scene
            this.update(scene, camera);
            // Sort the draw arrays and potential geometry, and call any prep renders
            for (var i = 0, l = visuals.length; i < l; i++) {
                mesh = visuals[i];
                // perform any geometry sorting
                mesh.sortGeometry(camera);
                if (!visuals[i].prepRender(scene, camera, renderTarget, this))
                    return false;
                if (visuals[i].material && visuals[i].material.transparent)
                    transparentObjects.push(visuals[i]);
                else
                    solidObjects.push(visuals[i]);
            }
            // First draw any animated textures
            for (var i = 0, l = shaderTextures.length; i < l; i++) {
                if (shaderTextures[i].requiresDraw && !this.drawShaderTexture(shaderTextures[i]))
                    return false;
                if (shaderTextures[i].animated === false)
                    shaderTextures[i].requiresDraw = false;
            }
            // Call prep render on any skyboxes
            for (var i = 0, l = scene.skyboxes.length; i < l; i++)
                if (!scene.skyboxes[i].prepRender(scene, camera, renderTarget, this))
                    return false;
            // Call prep render on any convolvers
            for (var i = 0, l = convolvers.length; i < l; i++)
                if (!convolvers[i].prepRender(scene, camera, renderTarget, this))
                    return false;
            // Call prep render on any lights
            for (var i = 0, l = scene.lights.length; i < l; i++)
                if (!scene.lights[i].prepRender(scene, camera, renderTarget, this))
                    return false;
            // Draw the shadow maps
            if (!this.drawShadowMaps(gl, shadowMeshes, scene.lightsFullScreen, camera))
                return false;
            var c;
            // Draw any mirrors or scene cameras
            var mirror;
            for (var i = 0, l = mirrors.length; i < l; i++) {
                mirror = mirrors[i];
                this._currentPassCollection = mirror.passCollection;
                if (!mirror.material || !mirror.material.mirrorReflection())
                    continue;
                this._drawingMirrorPasses = true;
                this._curMirror = mirror;
                if (camera instanceof Trike.CameraCombined && camera.activeCamera instanceof Trike.CameraPerspective)
                    mirror.updateTextureMatrix(camera.activeCamera);
                else if (camera instanceof Trike.CameraPerspective)
                    mirror.updateTextureMatrix(camera);
                else
                    throw new Error('Mirror only supports perspective camera at this time');
                c = mirror.mirrorCamera;
                // Prep the camera for the reflection
                this.prepCamera(c, visuals);
                if (!this.renderPasses(scene, c, solidObjects, transparentObjects, false, mirror.renderTarget))
                    return false;
                if (mirror.material) {
                    mirror.material.reflectionMap(mirror.renderTarget);
                    mirror.material.textureMatrix(mirror.textureMatrix);
                }
            }
            // Draw any cube renderers
            var cubeRenderer;
            for (var i = 0, l = cubeRenderers.length; i < l; i++) {
                cubeRenderer = cubeRenderers[i];
                cubeRenderer.updateCameras();
                this._currentPassCollection = cubeRenderer.passCollection;
                // Turn off mipmaps for most of the targets
                var mipmaps = cubeRenderer.cubeTarget.generateMipmaps;
                cubeRenderer.cubeTarget.generateMipmaps = false;
                // We use this to make sure we dont draw any materials using actuve the cube.
                // You cant draw a material when the render target is still being drawn
                this._curCube = cubeRenderer.cubeTarget;
                // Draw each of the cube sides
                c = cubeRenderer.activateCamera(0);
                this.prepCamera(c, visuals);
                if (!this.renderPasses(scene, c, solidObjects, transparentObjects, false, cubeRenderer.cubeTarget))
                    return false;
                c = cubeRenderer.activateCamera(1);
                this.prepCamera(c, visuals);
                if (!this.renderPasses(scene, c, solidObjects, transparentObjects, false, cubeRenderer.cubeTarget))
                    return false;
                c = cubeRenderer.activateCamera(2);
                this.prepCamera(c, visuals);
                if (!this.renderPasses(scene, c, solidObjects, transparentObjects, false, cubeRenderer.cubeTarget))
                    return false;
                c = cubeRenderer.activateCamera(3);
                this.prepCamera(c, visuals);
                if (!this.renderPasses(scene, c, solidObjects, transparentObjects, false, cubeRenderer.cubeTarget))
                    return false;
                c = cubeRenderer.activateCamera(4);
                this.prepCamera(c, visuals);
                if (!this.renderPasses(scene, c, solidObjects, transparentObjects, false, cubeRenderer.cubeTarget))
                    return false;
                cubeRenderer.cubeTarget.generateMipmaps = mipmaps;
                c = cubeRenderer.activateCamera(5);
                this.prepCamera(c, visuals);
                if (!this.renderPasses(scene, c, solidObjects, transparentObjects, false, cubeRenderer.cubeTarget))
                    return false;
            }
            // Make sure these are null again
            this._curCube = null;
            this._curMirror = null;
            this._drawingMirrorPasses = false;
            this._currentPassCollection = this._defaultPassCollection;
            // Prep the camera for the scene
            this.prepCamera(camera, visuals);
            // Draw each of the passes
            if (!this.renderPasses(scene, camera, solidObjects, transparentObjects, true, renderTarget))
                return false;
            // Disable stencil test
            gl.disable(gl.STENCIL_TEST);
            return true;
        };
        /**
        * Preps the camera variables before a render as well as
        * checks if each visual is within the furstum of the camera
        * @param {Camera} The camera to prepare
        * @param {Array<Mesh>} visuals The mesh objects to frust check
        */
        Renderer.prototype.prepCamera = function (camera, visuals) {
            var mesh, frustum = this._frustum;
            // Get the camera position for uniforms later
            this._camPositionPos.getPositionFromMatrix(camera.worldMatrix);
            // Get the 4 frustum corners of the camera. This is used in the post process effect
            // to get the depth and position of each fragment
            this._corners.setFrustumCorners(camera);
            // Build the frustum from the camera
            frustum.setFromMatrix(camera._projScreenMatrix);
            // Do all culling after the update call
            for (var i = 0, l = visuals.length; i < l; i++) {
                mesh = visuals[i];
                if (!mesh.visible)
                    mesh.culled = true;
                else if (mesh.sceneCull === false)
                    mesh.culled = false;
                else if (mesh.customCulling === false && frustum.intersectsObject(mesh))
                    mesh.culled = false;
                else if (mesh.customCulling)
                    mesh.culled = mesh.isCulled(camera, frustum);
                else
                    mesh.culled = true;
            }
        };
        /**
        * Draws the passes of a scene. This must be called after the scene is updated and culled. Returns false if a problem occurred with drawing the scene. Check
        * the errors string for causes.
        * @param {Scene} scene The scene to draw
        * @param {Camera} camera The camera to draw the scene with
        * @param {Array<Mesh>} solidObjects The solid objects to draw
        * @param {Array<Mesh>} transparentObjects The transparent objects to draw
        * @param {boolean} drawCompositions If true, the camera compositions will be enabled
        * is only useful or neccessary when multiple scenes are being rendered on top of eachother
        * @returns {boolean}
        */
        Renderer.prototype.renderPasses = function (scene, camera, solidObjects, transparentObjects, drawCompositions, renderTarget) {
            var clearCol = this._clearColor, clearAlpha = this._clearAlpha, gl = this._glContext, autoClearColor = this.autoClearColor, autoClearStencil = this.autoClearStencil, autoClearDepth = this.autoClearDepth, passCollection = this._currentPassCollection;
            // The first pass involves the skybox. The skybox should draw 1's to the stencil buffer.
            // Solids will later draw 2's and transparents 3's, 4's & 5's x [n transparents]
            gl.stencilFunc(gl.ALWAYS, 1, 0xffffffff);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
            // Set the clear color
            this._glContext.clearColor(clearCol.r, clearCol.g, clearCol.b, clearAlpha);
            // Set the solid material
            passCollection.compositionPass.material = passCollection.compositionPass.solidMaterial;
            // For a new render call, we need to clear the stencil.
            this.autoClearStencil = true;
            // Render the skyboxes
            passCollection.skyPass.renderTarget = passCollection.compositionPass.renderTarget;
            if (!this.renderObjects(scene.skyboxes, camera, passCollection.skyPass))
                return false;
            // If there was a sky render we do not need to clear again
            if (scene.skyboxes.length > 0)
                this.autoClearStencil = false;
            // Draw the solid objects into the respective passes.
            if (!this.drawSolidObjects(this._glContext, solidObjects, scene.lightsPerspective, scene.lightsFullScreen, camera))
                return false;
            // Draw any lighting based post processes
            this.drawCompositionPasses(camera.passes[Trike.Phase.LightingSolid], passCollection.compositionPass.renderTarget, camera, scene, solidObjects, transparentObjects);
            // Turn off the stencil check for the composition
            gl.stencilFunc(gl.LESS, 0, 0xffffffff);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
            // Draw the camera effects on the solid pass
            this.drawCompositionPasses(camera.passes[Trike.Phase.Composition], passCollection.compositionPass.renderTarget, camera, scene, solidObjects, transparentObjects);
            // Draw the transparent objects
            if (transparentObjects.length > 0) {
                // second prep call for post solid rendering
                for (var i = 0, l = transparentObjects.length; i < l; i++)
                    transparentObjects[i].prepRenderSolids(scene, camera, renderTarget, this);
                this.sortTransparents(transparentObjects, camera);
                // Draw the transparent objects into the respective passes.
                this.drawTransparentObjects(this._glContext, transparentObjects, scene.lightsPerspective, scene.lightsFullScreen, camera);
            }
            // We turn the stencil back to always as we're gonna be doing post process effects
            gl.stencilFunc(gl.ALWAYS, 0, 0xffffffff);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
            if (drawCompositions && camera.passes[Trike.Phase.PostCompostion].length > 0)
                this.drawCompositionPasses(camera.passes[Trike.Phase.PostCompostion], passCollection.compositionPass.renderTarget, camera, scene, solidObjects, transparentObjects);
            // Finally send the composition to the frame or render buffer provided
            passCollection.framePass.prepPass(renderTarget, scene, camera, this);
            if (!this.renderObjects(this._SSQ.meshes, this._SSQ.camera, passCollection.framePass))
                return false;
            this.autoClearColor = autoClearColor;
            this.autoClearStencil = autoClearStencil;
            this.autoClearDepth = autoClearDepth;
            return true;
        };
        Renderer.prototype.drawCompositionPasses = function (compPasses, renderTarget, camera, scene, solidObjects, transparentObjects) {
            // Now that the main passes are drawn, we do the composition passes attached the camera
            var compositionPass, compositionMeshes, compositionCam;
            for (var i = 0, l = compPasses.length; i < l; i++) {
                compositionPass = compPasses[i];
                if (!compositionPass.enabled)
                    continue;
                switch (compositionPass.filterType) {
                    case Trike.FilterType.Solids:
                        compositionMeshes = solidObjects;
                        compositionCam = camera;
                        break;
                    case Trike.FilterType.Transparents:
                        compositionMeshes = transparentObjects;
                        compositionCam = camera;
                        break;
                    case Trike.FilterType.ScreenQuad:
                        compositionMeshes = this._SSQ.meshes;
                        compositionCam = this._SSQ.camera;
                        break;
                }
                // Check if the pass needs to be resized
                if (compositionPass.resizeId !== this._resizeId) {
                    compositionPass.resize(this._width, this._height);
                    compositionPass.resizeId = this._resizeId;
                }
                for (var p = 0, pl = compositionPass.numSubPasses; p < pl; p++) {
                    compositionPass.currentSubPass = p;
                    compositionPass.prepPass(renderTarget, scene, camera, this);
                    this.autoClearColor = compositionPass.autoClearColor;
                    this.autoClearStencil = compositionPass.autoClearStencil;
                    this.autoClearDepth = compositionPass.autoClearDepth;
                    if (!this.renderObjects(compositionMeshes, compositionCam, compositionPass))
                        return false;
                }
            }
        };
        /*
        * Draws the non transparent objects to their respective passes. Returns false if a problem occurred with drawing the scene. Check
        * the errors string for causes.
        * @return {boolean}
        */
        Renderer.prototype.drawSolidObjects = function (gl, meshes, lightsP, lightsS, camera) {
            var passCollection = this._currentPassCollection;
            this.autoClearColor = true;
            this._glContext.clearColor(0, 0, 0, 0);
            // You need to start these before calling clear as it seems the clear is ignored when its false
            gl.depthMask(true);
            this._prevDepthWrite = true;
            // write 1 to the stencil buffer of each pixel we draw
            gl.stencilFunc(gl.ALWAYS, 2, 0xffffffff); // Always pass the stencil
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE); // Replace the stencil value with ref=1
            // Draw the material passes
            var passes = Trike.MaterialMulti.materialPasses;
            var prevDepth = this.autoClearDepth;
            var resizeId = this._resizeId;
            this.autoClearDepth = true;
            for (var i = 0, l = passes.length; i < l; i++) {
                if (passes[i].enabled === false)
                    continue;
                // Check if the pass needs to be resized
                if (passes[i].resizeId !== resizeId) {
                    passes[i].resize(this._width, this._height);
                    passes[i].resizeId = resizeId;
                }
                // Render the color and material information
                if (!this.renderObjects(meshes, camera, passes[i]))
                    return false;
            }
            this.autoClearDepth = prevDepth;
            // Render the gbuffer
            if (!this.renderObjects(meshes, camera, passCollection.gBufferPass))
                return false;
            // Make sure the stencil clear is false. The data in the stencil is used for subsequent calls
            this.autoClearStencil = false;
            // Do not clear the depth buffer, we can use it to disregard pixels as the buffers
            // below share the depth buffer of the _gBuffer2Pass
            this.autoClearDepth = false;
            gl.stencilFunc(gl.EQUAL, 2, 0xffffffff); // Only draw the stencil values with 1 for both color + light passes
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP); // Do not modify the stencil values (keep them as they are)
            // Render the gbuffer 2
            if (!this.renderObjects(meshes, camera, passCollection.gBuffer2Pass))
                return false;
            // Render the shadow maps onto the scene
            // TODO: OPTIMIZE
            // if (!this.renderObjects(meshes, camera, this._shadowMapPass))
            //    return false;
            // Now we do not clear the depth buffer in this pass.
            // Depth from geometry pass is used for light culling
            gl.depthFunc(gl.GEQUAL); // Greater equal as lights will be front culled
            // Render the lights that use perspective geometry (can be culled)
            if (!this.renderObjects(lightsP, camera, passCollection.lightPass))
                return false;
            // return back to less equal for screen quad lighting
            gl.depthMask(true);
            this._prevDepthWrite = true;
            gl.depthFunc(gl.LEQUAL);
            // Do not clear the scene - we are now going to render the other lights
            this.autoClearColor = false;
            // Render the lights that use screen quad geometry (cannot be culled)
            if (!this.renderObjects(lightsS, camera, passCollection.lightPass))
                return false;
            // Now that the solids are drawn, we draw the light pass onto the composition target
            // For solid objects there must be no blending
            passCollection.compositionPass.map = passCollection.lightPass.renderTarget;
            if (!this.renderObjects(this._SSQ.meshes, this._SSQ.camera, passCollection.compositionPass))
                return false;
            return true;
        };
        /*
        * Draws the transparent objects to their respective passes. Returns false if a problem occurred with drawing the scene. Check
        * the errors string for causes.
        * @return {boolean}
        */
        Renderer.prototype.drawTransparentObjects = function (gl, meshes, lightsP, lightsS, camera) {
            var passCollection = this._currentPassCollection;
            // Draw the material passes
            this.autoClearDepth = true;
            this.autoClearStencil = true;
            this.autoClearColor = true;
            var resizeId = this._resizeId;
            var passes = Trike.MaterialMulti.materialPasses;
            // Always pass the stencil for the material passes
            gl.stencilFunc(gl.ALWAYS, 1, 0xffffffff);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
            for (var i = 0, l_1 = passes.length; i < l_1; i++) {
                if (passes[i].enabled === false)
                    continue;
                // Check if the pass needs to be resized
                if (passes[i].resizeId !== resizeId) {
                    passes[i].resize(this._width, this._height);
                    passes[i].resizeId = resizeId;
                }
                // Render the color and material information
                if (!this.renderObjects(meshes, camera, passes[i]))
                    return false;
            }
            // Set the clear color to black for the deferred rendering
            this.autoClearDepth = false;
            this.autoClearStencil = false;
            this.autoClearColor = false;
            this._glContext.clearColor(0, 0, 0, 0);
            var transparencyQuality = this.transparencyQuality;
            var toDraw = [];
            var l = 1;
            if (transparencyQuality === TransparencyQuality.Multipass)
                l = meshes.length;
            // When drawing transparent objects we flip between 3 and 4 for the drawing mask
            // This is so that we make sure we only draw the relevant pixels for each one.
            var curStencilMask = 3;
            for (var i = 0; i < l; i++) {
                if (transparencyQuality === TransparencyQuality.Multipass) {
                    toDraw[0] = meshes[i];
                    if (toDraw[0].culled || !toDraw[0].visible)
                        continue;
                    // Render the lights that use perspective geometry (can be culled)
                    passCollection.tLightPass.drawSpecificMesh = toDraw[0];
                }
                else {
                    toDraw = meshes;
                    // Render the lights that use perspective geometry (can be culled)
                    passCollection.tLightPass.drawSpecificMesh = null;
                }
                // write the cur transparent mask number to the stencil buffer of each pixel we draw
                gl.stencilFunc(gl.ALWAYS, curStencilMask, 0xffffffff); // Always pass the stencil
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE); // Replace the stencil value with  mask number, but not if the z/stencil fails
                // Render the gbuffer
                if (!this.renderObjects(toDraw, camera, passCollection.gBufferPass))
                    return false;
                if (transparencyQuality === TransparencyQuality.Multipass)
                    this.autoClearStencil = false;
                gl.stencilFunc(gl.EQUAL, curStencilMask, 0xffffffff); // Only draw the stencil values with 2 for both color + light passes
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP); // Do not modify the stencil values (keep them as they are)
                // Render gbuffer 2
                if (!this.renderObjects(toDraw, camera, passCollection.gBuffer2Pass))
                    return false;
                // Clear the transparent light texture to black
                this.autoClearColor = true;
                // If not depth reading, then always pass.
                // Greater equal as lights will be front culled
                if (transparencyQuality === TransparencyQuality.Multipass) {
                    if (meshes[i].material.depthRead)
                        gl.depthFunc(gl.GEQUAL);
                    else
                        gl.depthFunc(gl.ALWAYS);
                }
                else
                    gl.depthFunc(gl.GEQUAL);
                // Draw the lights that use perspective transforms
                if (!this.renderObjects(lightsP, camera, passCollection.tLightPass))
                    return false;
                // Additive blending, turn off clear color
                this.autoClearColor = false;
                gl.depthMask(true);
                this._prevDepthWrite = true;
                // Return back to less equal for screen quad lighting
                gl.depthFunc(gl.LEQUAL);
                // Render the lights that use screen quad geometry (cannot be culled)
                if (!this.renderObjects(lightsS, camera, passCollection.tLightPass))
                    return false;
                // Draw the composition on the light render target
                this.drawCompositionPasses(camera.passes[Trike.Phase.Composition], passCollection.tLightPass.renderTarget, camera, null, null, null);
                // Once again we draw the light contributions onto the composition target. This time however we
                // do allow for blending
                passCollection.compositionPass.material = passCollection.compositionPass.transparentMaterial;
                passCollection.compositionPass.map = passCollection.tLightPass.renderTarget;
                if (!this.renderObjects(this._SSQ.meshes, this._SSQ.camera, passCollection.compositionPass))
                    return false;
                // Swap the stencil
                if (curStencilMask === 3)
                    curStencilMask = 4;
                else
                    curStencilMask = 3;
            }
        };
        /*
        * Draws the shadow maps for each of the lights
        * @return {boolean}
        */
        Renderer.prototype.drawShadowMaps = function (gl, shadowCasters, lights, camera) {
            var clearCol = this._clearColor, clearAlpha = this._clearAlpha, autoClearColor = this.autoClearColor, autoClearStencil = this.autoClearStencil, autoClearDepth = this.autoClearDepth, shadowLights = this._shadowLights;
            var light;
            var shadowMatrix;
            var shadowMatrix2;
            var shadowCamera;
            var shadowMap;
            var passCollection = this._currentPassCollection;
            this.autoClearColor = true;
            this.autoClearStencil = true;
            this.autoClearDepth = true;
            gl.clearColor(1, 1, 1, 1);
            gl.depthMask(true);
            shadowLights.splice(0, shadowLights.length);
            for (var i = 0, l = lights.length; i < l; i++) {
                light = lights[i];
                if (light instanceof Trike.LightDirectional === false || !light.shadowMap())
                    continue;
                shadowLights.push(light);
                shadowCamera = light.shadowCamera();
                shadowMap = light.shadowMap();
                shadowCamera.position.getPositionFromMatrix(light.worldMatrix);
                shadowCamera.lookAt(light.target);
                shadowCamera.updateWorldMatrix(true);
                shadowMatrix = light.shadowMatrix();
                shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
                shadowMatrix.multiply(shadowCamera.projectionMatrix);
                shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
                passCollection.shadowLightPass.renderTarget = shadowMap;
                this.prepCamera(shadowCamera, shadowCasters);
                if (!this.renderObjects(shadowCasters, shadowCamera, passCollection.shadowLightPass))
                    return false;
                // Stops the map from being resized
                passCollection.shadowLightPass.renderTarget = null;
            }
            gl.clearColor(clearCol.r, clearCol.g, clearCol.b, clearAlpha);
            this.autoClearColor = autoClearColor;
            this.autoClearStencil = autoClearStencil;
            this.autoClearDepth = autoClearDepth;
            return true;
        };
        Renderer.prototype.setShadowUniforms = function (mat) {
            var shadowLights = this._shadowLights;
            var light;
            var count = 0;
            var maxShadows = mat._uniforms['shadowMap'].value.length;
            for (var i = 0, l = shadowLights.length; i < l; i++) {
                if (count > maxShadows)
                    return;
                light = shadowLights[i];
                if (!light.castShadows())
                    continue;
                mat._uniforms['shadowMap'].value[count] = light.shadowMap();
                mat._uniforms['shadowMapSize'].value[count] = light.shadowMapSize();
                mat._uniforms['shadowMatrix'].value.values[count] = light.shadowMatrix();
                mat._uniforms['shadowDarkness'].value[count] = light.shadowDarkness();
                mat._uniforms['shadowBias'].value[count] = light.shadowBias();
                count++;
            }
        };
        /**
        * Draws a render target using predefined geometry and cameras. Returns false if a problem occurred with drawing the scene. Check
        * the errors string for causes.
        * @return {boolean}
        */
        Renderer.prototype.drawRenderTarget = function (texture, target) {
            this._screenPass.map = texture;
            this._screenPass.renderTarget = target;
            if (!this.renderObjects(this._SSQ.meshes, this._SSQ.camera, this._screenPass))
                return false;
            return true;
        };
        /**
        * Draws a shader texture and its material. Returns false if a problem occurred with drawing the scene. Check
        * the errors string for causes.
        * @return {boolean}
        */
        Renderer.prototype.drawShaderTexture = function (texture) {
            var autoClearColor = this.autoClearColor, autoClearStencil = this.autoClearStencil, autoClearDepth = this.autoClearDepth, passCollection = this._currentPassCollection;
            passCollection.texturePass.renderTarget = texture;
            passCollection.texturePass.material = texture.material.materials[Trike.PassType.Texture];
            this.autoClearColor = true;
            this.autoClearStencil = true;
            this.autoClearDepth = true;
            if (!this.renderObjects(this._SSQ.meshes, this._SSQ.camera, passCollection.texturePass))
                return false;
            this.autoClearColor = autoClearColor;
            this.autoClearStencil = autoClearStencil;
            this.autoClearDepth = autoClearDepth;
            return true;
        };
        /**
        * Call this to draw a single pass scene. This does not take into account the
        * multiple passes of a trike render. Returns false if a problem occurred with drawing the scene. Check
        * the errors string for causes.
        * @param {Array<Mesh>} meshes An array of meshes to draw
        * @param {Camera} camera The camera to draw the scene with
        * @param {RenderPass} pass The render pass controlling this render
        * @return {boolean}
        */
        Renderer.prototype.renderObjects = function (meshes, cam, pass) {
            var gl = this._glContext;
            var camera = cam;
            pass.camera = camera;
            pass.reflectionPass = this._drawingMirrorPasses;
            if (this._curMirror)
                pass.reflectionClipPlane.copy(this._curMirror.clipPlane);
            var renderTarget = (pass ? pass.renderTarget : null);
            // Set the frame buffer we are drawing to.
            if (!this.setRenderTarget(renderTarget))
                return false;
            // Clear the buffers
            if (this.autoClearColor || this.autoClearDepth || this.autoClearStencil)
                this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
            // Cache a few params to speed things up if they are the same.
            var prevProgram = this._prevProgram;
            var prevMaterial = this._prevMaterial;
            var prevGeometry = this._prevGeometry;
            var mesh;
            var geom;
            var mat;
            var renderCount = 0;
            var mirrorMaterial = (this._curMirror ? this._curMirror.material : null);
            for (var i = 0, l = meshes.length; i < l; i++) {
                mesh = meshes[i];
                geom = mesh.geometry;
                mat = mesh.material;
                if (!geom || !mat || mat.disposed)
                    continue;
                // Check if we have a render pass.
                if (pass) {
                    if (pass.evaluateMesh(mesh) === false)
                        continue;
                    // You can't draw a material if its the same material a reflection pass
                    // is targeting.
                    if (mirrorMaterial === mat)
                        continue;
                    else if (mat.materials[pass.passType])
                        mat = mat.materials[pass.passType];
                    else if (pass.material)
                        mat = pass.material;
                    else
                        continue;
                }
                // Check if any geometries / materials need to be built.
                // If the geometry needs to be built, we must reset the previous geometry reference
                // as buffers used in the process interfere with the drawing later on...
                if (geom.requiresBuild)
                    prevGeometry = null;
                // Check if the geometry has been updated
                if (mesh.buildNumber !== geom.buildCount)
                    mesh.geometryUpdated(geom);
                // Check if geometry needs to be rebuilt. If it fails then catch the error and return
                if (geom.requiresBuild && geom.buildGeometry(gl) === false) {
                    this._errors = geom.compileStatus;
                    return false;
                }
                else if (geom.dirtyBuffers.length)
                    geom.updateDirtyBuffers(gl);
                // Check if material needs to be rebuilt. If it fails then catch the error and return
                if (mat.requiresBuild && mat.compile(gl) === false) {
                    this._errors = mat.compileStatus;
                    return false;
                }
                // If not visible - then continue
                if (!mesh.visible)
                    continue;
                if (mesh.culled)
                    continue;
                // Call pre-render for any object specific setup
                mesh.preRender(this, pass);
                // Get the matrices ready
                mesh._modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, mesh.worldMatrix);
                if (geom.buffers[Trike.AttributeType.NORMAL] && mat._attributes[Trike.AttributeType.NORMAL])
                    mesh._normalMatrix.getNormalMatrix(mesh._modelViewMatrix);
                // Shaders and geometry is ready. Lets set the material shader and activate the
                if (prevProgram !== mat.program)
                    gl.useProgram(mat.program);
                if (prevGeometry !== geom || prevMaterial !== mat)
                    this.setupAttributes(mat, geom, gl);
                // Setup common GL settings
                this.setupNewMaterial(mat);
                // If the material is the same as the last render
                if (prevMaterial === mat) {
                    if (this.setupUniforms(mat, mesh, gl, false, camera, renderTarget) === false)
                        continue;
                }
                else {
                    // Finally setup the material uniforms
                    if (this.setupUniforms(mat, mesh, gl, true, camera, renderTarget) === false)
                        continue;
                }
                // Increment render count
                renderCount++;
                // Finally draw the verts
                if (geom instanceof Trike.GeometryLine) {
                    var geomLine = geom;
                    if (geomLine.lineMode === Trike.LineMode.HeadToTail)
                        gl.drawArrays(gl.LINE_STRIP, 0, geom.numElements);
                    else if (geomLine.lineMode === Trike.LineMode.HeadToTailClosed)
                        gl.drawArrays(gl.LINE_LOOP, 0, geom.numElements);
                    else if (geomLine.lineMode === Trike.LineMode.Pairs)
                        gl.drawArrays(gl.LINES, 0, geom.numElements);
                }
                else if (geom.indexBuffer) {
                    if (prevGeometry !== geom) {
                        if (mat.wireframe && geom.indexBufferLines)
                            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geom.indexBufferLines.buffer);
                        else
                            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geom.indexBuffer.buffer);
                    }
                    // Check the data type of the index buffer. It may be a big 32 or smaller 16
                    var indexData = geom.indexBufferLines.dataFlat;
                    var indexType = gl.UNSIGNED_SHORT;
                    if (indexData instanceof Uint32Array)
                        indexType = gl.UNSIGNED_INT;
                    if (mat.wireframe)
                        gl.drawElements(gl.LINES, geom.indexBufferLines.dataFlat.length, indexType, 0);
                    else
                        gl.drawElements(gl.TRIANGLES, geom.indexBuffer.dataFlat.length, indexType, 0);
                }
                else {
                    if (mesh instanceof Trike.PointCloud)
                        gl.drawArrays(gl.POINTS, 0, geom.numElements);
                    else if (mat.wireframe)
                        gl.drawArrays(gl.LINES, 0, geom.numElements);
                    else
                        gl.drawArrays(gl.TRIANGLES, 0, geom.numElements);
                }
                // Call post render for any object specific setup
                mesh.postRender(gl, pass);
                prevProgram = mat.program;
                prevMaterial = mat;
                prevGeometry = geom;
            }
            this._prevProgram = prevProgram;
            this._prevGeometry = prevGeometry;
            this._prevMaterial = prevMaterial;
            // Generate mipmap if we're using any kind of mipmap filtering
            if (renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== Trike.TextureFilter.Nearest && renderTarget.minFilter !== Trike.TextureFilter.Linear) {
                if (renderTarget instanceof Trike.RenderTargetCube) {
                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, renderTarget.webglTexture);
                    gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
                }
                else {
                    gl.bindTexture(gl.TEXTURE_2D, renderTarget.webglTexture);
                    gl.generateMipmap(gl.TEXTURE_2D);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                }
            }
            this._renderCount += renderCount;
            return true;
        };
        /**
        * Sets the vertex attributes of a geometry based on the material about to be drawn
        * @param {MaterialMulti} material The material drawing the current geometry
        * @param {Geometry} geometry The geometry to prepare
        * @param {WebGLRenderingContext} gl The context
        */
        Renderer.prototype.setupAttributes = function (material, geometry, gl) {
            // Set each of the attributes
            var attributes = material._attributes;
            var buffers = geometry.buffers;
            var ii = 0;
            var attrHooked = false;
            var type;
            var attr = null;
            var buffer = null;
            var activeAttributes = this._activeAttributes;
            var disableAttribute = false;
            // Disable any vertex attribute that are not relevant to this material
            for (var i in activeAttributes) {
                disableAttribute = true;
                for (var a in attributes)
                    if (attributes[a].location === parseInt(i)) {
                        disableAttribute = false;
                        break;
                    }
                if (disableAttribute) {
                    activeAttributes[i] = false;
                    gl.disableVertexAttribArray(parseInt(i));
                }
            }
            for (var i in attributes) {
                attrHooked = false;
                ii = buffers.length;
                buffer = buffers[attributes[i].type];
                attr = attributes[i];
                if (buffer) {
                    attrHooked = true;
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer.buffer);
                    gl.vertexAttribPointer(attr.location, buffer.elementSize, gl.FLOAT, false, 0, 0);
                    if (!activeAttributes[attr.location] || activeAttributes[attr.location] === false)
                        gl.enableVertexAttribArray(attr.location);
                    activeAttributes[attr.location] = true;
                }
                else {
                    if (!activeAttributes[attr.location] || activeAttributes[attr.location] === true)
                        gl.disableVertexAttribArray(attr.location);
                    activeAttributes[attr.location] = false;
                }
            }
        };
        /**
        * Sets the rendering viewport size as well as optionally setting the canvas's size
        * @param {number} width The new width
        * @param {number} height The new height
        * @param {boolean} updateStyle If true, the canvas object will be resized to the new dimensions as well.
        */
        Renderer.prototype.setSize = function (width, height, updateStyle) {
            if (updateStyle === void 0) { updateStyle = true; }
            this._resizeId++;
            var pixelRatio = 1;
            var canvas = this._canvas;
            canvas.width = width * pixelRatio;
            canvas.height = height * pixelRatio;
            this._width = width;
            this._height = height;
            if (updateStyle !== false) {
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
            }
            this._defaultPassCollection.setSize(width, height);
            //  for ( let i= 0, l = this._allPasses.length; i < l; i++ )
            //      this._allPasses[i].resize( width, height  );
            this.setViewport(0, 0, canvas.width, canvas.height);
        };
        /**
        * Called when we have a new material that needs to be sent to the GPU.
        * Essentially prepares the renderer with the material properties.
        * @param {MaterialMulti} mat The material drawing the current geometry
        */
        Renderer.prototype.setupNewMaterial = function (mat) {
            var gl = this._glContext;
            var prevCullMode = this._prevCullMode;
            var prevDepthWrite = this._prevDepthWrite;
            var prevDepthRead = this._prevDepthRead;
            var preBlendMode = this._preBlendMode;
            var preBlendEquation = this._preBlendEquation;
            var preBlendSourceFactor = this._preBlendSourceFactor;
            var preBlendDestFactor = this._preBlendDestFactor;
            var prevLineWidth = this._preLineWidth;
            if (mat instanceof Trike.MaterialLine && prevLineWidth !== mat.lineWidth) {
                gl.lineWidth(mat.lineWidth);
            }
            // Blending functions
            if (preBlendMode !== mat.blendMode || preBlendSourceFactor !== mat.sourceFactor || preBlendDestFactor !== mat.destinationFactor) {
                if (preBlendMode !== mat.blendMode) {
                    if (mat.blendMode !== Trike.BlendMode.None) {
                        gl.enable(gl.BLEND);
                        if (preBlendSourceFactor !== mat.sourceFactor || preBlendDestFactor !== mat.destinationFactor) {
                            gl.blendFunc(Trike.getGLParam(mat.sourceFactor, gl), Trike.getGLParam(mat.destinationFactor, gl));
                            this._preBlendSourceFactor = mat.sourceFactor;
                            this._preBlendDestFactor = mat.destinationFactor;
                        }
                        if (preBlendEquation !== mat.blendEquation) {
                            gl.blendEquation(Trike.getGLParam(mat.blendEquation, gl));
                            this._preBlendEquation = mat.blendEquation;
                        }
                    }
                    else
                        gl.disable(gl.BLEND);
                }
                this._preBlendMode = mat.blendMode;
            }
            // Culling
            if (prevCullMode !== mat.cullMode) {
                if (mat.cullMode === Trike.CullFormat.None) {
                    if (prevCullMode !== Trike.CullFormat.None)
                        gl.disable(gl.CULL_FACE);
                }
                else {
                    if (prevCullMode === Trike.CullFormat.None)
                        gl.enable(gl.CULL_FACE);
                    gl.cullFace(Trike.getGLParam(mat.cullMode, gl));
                }
                prevCullMode = mat.cullMode;
            }
            // Depth write
            if (prevDepthWrite !== mat.depthWrite) {
                gl.depthMask(mat.depthWrite);
                prevDepthWrite = mat.depthWrite;
            }
            // Depth read
            if (prevDepthRead !== mat.depthRead) {
                if (mat.depthRead)
                    gl.enable(gl.DEPTH_TEST);
                else
                    gl.disable(gl.DEPTH_TEST);
                prevDepthRead = mat.depthRead;
            }
            this._prevCullMode = prevCullMode;
            this._prevDepthWrite = prevDepthWrite;
            this._prevDepthRead = prevDepthRead;
        };
        /**
        * Sets the shader uniforms on a given mesh and its material
        * @param {MaterialMulti} mat The material drawing the current geometry
        * @param {Mesh} mesh The mesh being drawn
        * @param {WebGLRenderingContext} gl The context
        * @param {boolean} isNewMaterial The true if this material is different from the last
        * @param {Camera} camera The camera used to draw the scene
        * @param {RenderTarget} renderTarget The optional target we are drawing to
        * @returns {boolean} If the function returns false, then the mesh should not be drawn
        */
        Renderer.prototype.setupUniforms = function (mat, mesh, gl, isNewMaterial, camera, renderTarget) {
            // Set each of the uniforms
            this._curTextureUnit = 0;
            var geometry = mesh.geometry, hasNormals = (geometry.buffers[Trike.AttributeType.NORMAL] && mat._attributes[Trike.AttributeType.NORMAL] ? true : false), textureSlot = this._texSlotMap, projectionMatrix = camera.projectionMatrix, invProjectionMatrix = camera.projectionInverseMatrix, viewMatrix = camera.matrixWorldInverse, tex0 = gl.TEXTURE0, texSlotArray = this._texSlotArray, uniforms = mat._uniforms, passCollection = this._currentPassCollection, curCube = this._curCube;
            var texture, textures, uniform, texSlot = 0, slot = 0;
            if (mat.receivesShadows && !this._drawingMirrorPasses)
                this.setShadowUniforms(mat);
            for (var ii in uniforms) {
                uniform = uniforms[ii];
                // Increment the texture counter
                if (uniform.type === Trike.UniformType.TEXTURE || uniform.type === Trike.UniformType.TEXTURE_CUBE)
                    this._curTextureUnit++;
                // These can only be updated if its a new material
                if (isNewMaterial) {
                    uniform.requiresUpdate = true;
                    switch (uniform.name) {
                        case 'viewWidth':
                            uniform.value = (renderTarget ? renderTarget.width : this._width);
                            break;
                        case 'viewHeight':
                            uniform.value = (renderTarget ? renderTarget.height : this._height);
                            break;
                        case 'time':
                            uniform.value += 0.01;
                            break;
                        case 'time':
                            uniform.value = this._timeElapsed;
                            break;
                        case 'timeDelta':
                            uniform.value = this._timeDelta;
                            break;
                        case 'viewWidthHalf':
                            uniform.value = this._width / 2;
                            break;
                        case 'viewHeightHalf':
                            uniform.value = this._height / 2;
                            break;
                        case 'gBuffer2':
                            uniform.value = passCollection.gBuffer2Pass.renderTarget;
                            break;
                        case 'lightPass':
                            uniform.value = passCollection.lightPass.renderTarget;
                            break;
                        case 'compositionPass':
                            uniform.value = passCollection.compositionPass.renderTarget;
                            break;
                        case 'gBuffer':
                            uniform.value = passCollection.gBufferPass.renderTarget;
                            break;
                        case 'cameraPosition':
                            uniform.value = this._camPositionPos;
                            break;
                        case 'frustumCorners':
                            uniform.value = this._corners.cornerUniform;
                            break;
                        case 'cameraFar':
                            uniform.value = camera.far;
                            break;
                        case 'cameraNear':
                            uniform.value = camera.near;
                            break;
                    }
                }
                // If the uniform is a texture and it requires a build, then the uniform must be updated.
                if (uniform.value instanceof Trike.TextureBase && uniform.value.requiresBuild)
                    uniform.requiresUpdate = true;
                // Fill the standard uniforms if present
                if (uniform.name === 'projectionMatrix') {
                    if (isNewMaterial || !uniform.value.equals(projectionMatrix)) {
                        gl.uniformMatrix4fv(uniform.location, false, projectionMatrix.elements);
                        uniform.value.copy(projectionMatrix);
                    }
                }
                else if (uniform.name === 'invProjectionMatrix') {
                    if (isNewMaterial || !uniform.value.equals(invProjectionMatrix)) {
                        gl.uniformMatrix4fv(uniform.location, false, invProjectionMatrix.elements);
                        uniform.value.copy(invProjectionMatrix);
                    }
                }
                else if (uniform.name === 'modelViewMatrix') {
                    if (isNewMaterial || !uniform.value.equals(mesh._modelViewMatrix)) {
                        gl.uniformMatrix4fv(uniform.location, false, mesh._modelViewMatrix.elements);
                        uniform.value.copy(mesh._modelViewMatrix);
                    }
                }
                else if (uniform.name === 'viewMatrix') {
                    if (isNewMaterial || !uniform.value.equals(viewMatrix)) {
                        gl.uniformMatrix4fv(uniform.location, false, viewMatrix.elements);
                        uniform.value.copy(viewMatrix);
                    }
                }
                else if (uniform.name === 'modelMatrix') {
                    if (isNewMaterial || !uniform.value.equals(mesh.worldMatrix)) {
                        gl.uniformMatrix4fv(uniform.location, false, mesh.worldMatrix.elements);
                        uniform.value.copy(mesh.worldMatrix);
                    }
                }
                else if (hasNormals && uniform.name === 'normalMatrix') {
                    if (isNewMaterial || !uniform.value.equals(mesh._normalMatrix)) {
                        gl.uniformMatrix3fv(uniform.location, false, mesh._normalMatrix.elements);
                        uniform.value.copy(mesh._normalMatrix);
                    }
                }
                else if (uniform.requiresUpdate) {
                    switch (uniform.type) {
                        case Trike.UniformType.MAT4:
                            gl.uniformMatrix4fv(uniform.location, false, uniform.value.elements);
                            break;
                        case Trike.UniformType.MAT3:
                            gl.uniformMatrix3fv(uniform.location, false, uniform.value.elements);
                            break;
                        case Trike.UniformType.MAT4_ARRAY:
                            gl.uniformMatrix4fv(uniform.location, false, uniform.value.getElements);
                            break;
                        case Trike.UniformType.MAT3_ARRAY:
                            gl.uniformMatrix3fv(uniform.location, false, uniform.value.getElements);
                            break;
                        case Trike.UniformType.INT:
                            gl.uniform1i(uniform.location, uniform.value);
                            break;
                        case Trike.UniformType.INT_ARRAY:
                            gl.uniform1iv(uniform.location, uniform.value);
                            break;
                        case Trike.UniformType.FLOAT:
                            gl.uniform1f(uniform.location, uniform.value);
                            break;
                        case Trike.UniformType.FLOAT_ARRAY:
                            gl.uniform1fv(uniform.location, uniform.value);
                            break;
                        case Trike.UniformType.FLOAT2:
                        case Trike.UniformType.FLOAT2_ARRAY:
                            gl.uniform2fv(uniform.location, uniform.value.getElements);
                            break;
                        case Trike.UniformType.FLOAT3:
                        case Trike.UniformType.FLOAT3_ARRAY:
                            gl.uniform3fv(uniform.location, uniform.value.getElements);
                            break;
                        case Trike.UniformType.FLOAT4:
                        case Trike.UniformType.FLOAT4_ARRAY:
                            gl.uniform4fv(uniform.location, uniform.value.getElements);
                            break;
                        case Trike.UniformType.COLOR3:
                            gl.uniform3fv(uniform.location, uniform.value.getElements);
                            break;
                        case Trike.UniformType.QUAT:
                            gl.uniform4fv(uniform.location, uniform.value.getElements);
                            break;
                        case Trike.UniformType.TEXTURE:
                        case Trike.UniformType.TEXTURE_CUBE:
                            texSlot = this._curTextureUnit - 1;
                            slot = tex0 + texSlot;
                            texture = uniform.value;
                            if (!texture)
                                break;
                            // If the mesh uses a render target cube and its currently active - then it cant be drawn
                            if (uniform.type === Trike.UniformType.TEXTURE_CUBE && uniform.value === curCube)
                                return false;
                            // If the current slot already has this texture assigned - we can ignore it.
                            if (isNewMaterial || (textureSlot[texSlot] !== texture.webglTexture || texture.requiresBuild)) {
                                if (texture.requiresBuild)
                                    texture.compile(gl, slot);
                                // Update the texture map
                                textureSlot[texSlot] = texture.webglTexture;
                                gl.activeTexture(slot);
                                if (uniform.type === Trike.UniformType.TEXTURE)
                                    gl.bindTexture(gl.TEXTURE_2D, texture.webglTexture);
                                else
                                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture.webglTexture);
                                gl.uniform1i(uniform.location, texSlot);
                            }
                            break;
                        case Trike.UniformType.TEXTURE_ARRAY:
                            textures = uniform.value;
                            texSlotArray.splice(0, texSlotArray.length);
                            for (var i = 0, l = textures.length; i < l; i++) {
                                // Increment the texture counter
                                this._curTextureUnit++;
                                texSlot = this._curTextureUnit - 1;
                                slot = tex0 + texSlot;
                                texture = textures[i];
                                if (!texture)
                                    break;
                                texSlotArray.push(texSlot);
                                // If the current slot already has this texture assigned - we can ignore it.
                                if (isNewMaterial || (textureSlot[texSlot] !== texture.webglTexture || texture.requiresBuild)) {
                                    if (texture.requiresBuild)
                                        texture.compile(gl, slot);
                                    // Update the texture map
                                    textureSlot[texSlot] = texture.webglTexture;
                                    gl.activeTexture(slot);
                                    gl.bindTexture(gl.TEXTURE_2D, texture.webglTexture);
                                }
                            }
                            if (texSlotArray.length > 0)
                                gl.uniform1iv(uniform.location, texSlotArray);
                            break;
                    }
                }
                uniform.requiresUpdate = false;
            }
            return true;
        };
        /**
        * Tells the renderer to create & show a statistic popup with details of the scene
        */
        Renderer.prototype.showStatsPopup = function () {
            if (!this._statPopup) {
                this._statPopup = document.createElement('div');
                this._statPopup.style.width = '100px';
                this._statPopup.style.height = '100px';
                this._statPopup.style.backgroundColor = 'rgba(0,0,0,0.5)';
                this._statPopup.style.color = '#fff';
                this._statPopup.innerHTML = 'FPS: ';
                this._statPopup.style.position = 'absolute';
                this._statPopup.style.left = '0';
                this._statPopup.style.right = '0';
            }
            // Add stats to the parent of the canvas
            this._canvas.parentElement.style.position = 'relative';
            this._canvas.parentElement.insertBefore(this._statPopup, this._canvas);
        };
        /**
        * Sets the viewable area on the screen to which we will render
        * @param {number} x The x position
        * @param {number} y The y position
        * @param {number} width The viewport width
        * @param {number} height The viewport height
        */
        Renderer.prototype.setViewport = function (x, y, width, height) {
            var canvas = this._canvas;
            x = x !== undefined ? x : 0;
            y = y !== undefined ? y : 0;
            width = width !== undefined ? width : canvas.width;
            height = height !== undefined ? height : canvas.height;
            this._width = width;
            this._height = height;
            this._x = x;
            this._y = y;
            var curViewport = this._viewport;
            if (x !== curViewport.x || y !== curViewport.y || width !== curViewport.width || height !== curViewport.height) {
                this._glContext.viewport(x, y, width, height);
                curViewport.x = x;
                curViewport.y = y;
                curViewport.height = height;
                curViewport.width = width;
            }
        };
        /**
        * Sets up GL to draw to a render target
        * @param {RenderTarget} renderTarget The renderTarget we are drawing to
        */
        Renderer.prototype.setRenderTarget = function (renderTarget) {
            var gl = this._glContext;
            // First see if we need to setup the buffers of the render target
            if (renderTarget && renderTarget.requiresBuild) {
                if (!renderTarget.compile(gl)) {
                    this._errors = 'Could not create a render target with the texture type: ' + Trike.TextureType[renderTarget.type];
                    return false;
                }
            }
            if (renderTarget instanceof Trike.RenderTargetCube && !renderTarget.frameBuffer)
                renderTarget.activeCubeFace = renderTarget.activeCubeFace;
            var framebuffer, width, height, vx, vy;
            // Store the viewport co-ordinates for cases of where we have or have not got a buffer.
            if (renderTarget) {
                framebuffer = renderTarget.frameBuffer;
                width = renderTarget.width;
                height = renderTarget.height;
                vx = 0;
                vy = 0;
            }
            else {
                framebuffer = null;
                width = this._width;
                height = this._height;
                vx = this._x;
                vy = this._y;
            }
            // If the current buffer is not the same as the previous then call GL (optimisation)
            if (framebuffer !== this._currentFramebuffer) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                var curViewport = this._viewport;
                if (vx !== curViewport.x || vy !== curViewport.y || width !== curViewport.width || height !== curViewport.height) {
                    gl.viewport(vx, vy, width, height);
                    curViewport.x = vx;
                    curViewport.y = vy;
                    curViewport.height = height;
                    curViewport.width = width;
                }
                this._currentFramebuffer = framebuffer;
            }
            return true;
        };
        /**
        * Cleans up the renderer
        */
        Renderer.prototype.dispose = function () {
            this._canvas = null;
            this._statPopup = null;
            this._glContext = null;
            this._clearColor = null;
            this._frustum = null;
            this._SSQ.dispose();
            this._defaultPassCollection.dispose();
            this._defaultPassCollection = null;
            this._currentPassCollection = null;
            this._prevProgram = null;
            this._prevMaterial = null;
            this._prevGeometry = null;
            this._texSlotMap = null;
            this._prevCullMode = null;
            this._texSlotMap = null;
            this._currentFramebuffer = null;
            this._viewport = null;
            this._activeAttributes = null;
            this._preBlendMode = null;
            this._preBlendEquation = null;
            this._preBlendSourceFactor = null;
            this._preBlendDestFactor = null;
            this._corners = null;
            this._screenPass.dispose();
            this._screenPass = null;
        };
        Object.defineProperty(Renderer.prototype, "clearColor", {
            /**
            * Gets the clear color of the renderer
            * @returns {Color}
            */
            get: function () { return this._clearColor; },
            /**
            * Sets the clear color of the renderer
            * @param {Color} c
            */
            set: function (c) {
                this._clearColor.copy(c);
                this._glContext.clearColor(c.r, c.g, c.b, this._clearAlpha);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Renderer.prototype, "clearAlpha", {
            /**
            * Gets the alpha of the renderer
            * @returns {number} a
            */
            get: function () { return this._clearAlpha; },
            /**
            * Sets the alpha of the renderer
            * @param {number} a
            */
            set: function (a) {
                var c = this._clearColor;
                this._clearAlpha = a;
                this._glContext.clearColor(c.r, c.g, c.b, a);
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Clears a render target
        * @param {boolean} color If true the color buffer will be cleared
        * @param {boolean} depth If true the depth buffer will be cleared
        * @param {boolean} stencil If true the stencil buffer will be cleared
        */
        Renderer.prototype.clear = function (color, depth, stencil) {
            var bits = 0;
            var gl = this._glContext;
            if (color === undefined || color)
                bits |= gl.COLOR_BUFFER_BIT;
            if (depth === undefined || depth)
                bits |= gl.DEPTH_BUFFER_BIT;
            if (stencil === undefined || stencil)
                bits |= gl.STENCIL_BUFFER_BIT;
            gl.clear(bits);
        };
        Object.defineProperty(Renderer.prototype, "depthTest", {
            /**
            * Gets if the renderer must draw to the depth buffer
            * @returns {boolean}
            */
            get: function () { return this._depthTest; },
            /**
            * Sets if the renderer must draw to the depth buffer
            * @param {boolean} val
            */
            set: function (val) {
                if (val)
                    this._glContext.enable(this._glContext.DEPTH_TEST);
                else
                    this._glContext.disable(this._glContext.DEPTH_TEST);
                this._depthTest = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Renderer.prototype, "errors", {
            /**
            * Gets the error log string. Useful for initialization errors.
            * @returns {string}
            */
            get: function () { return this._errors; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Renderer.prototype, "glContext", {
            /**
            * Gets the rendering context
            * @returns {WebGLRenderingContext}
            */
            get: function () { return this._glContext; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Renderer.prototype, "canvas", {
            /**
            * Gets the canvas element this renderer is drawing to.
            * @returns {HTMLCanvasElement}
            */
            get: function () { return this._canvas; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Renderer.prototype, "ssq", {
            /**
            * Gets the quad scene. This is useful for drawing screen quad scenes
            * @returns {SceneScreenQuad}
            */
            get: function () { return this._SSQ; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Renderer.prototype, "fps", {
            /*
            * Gets the current frames per second
            * @returns {number}
            */
            get: function () { return this._FPS; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Renderer.prototype, "renderCount", {
            /*
            * Gets the number of items rendered in the last frame
            * @returns {number}
            */
            get: function () { return this._renderCount; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Renderer.prototype, "defaultCollection", {
            /*
            * Gets the default pass collection of this renderer
            * @returns {PassCollection}
            */
            get: function () { return this._defaultPassCollection; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Renderer.prototype, "currentCollection", {
            /*
            * Gets the current pass collection of this renderer
            * @returns {PassCollection}
            */
            get: function () { return this._currentPassCollection; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Renderer.prototype, "width", {
            /**
            * Gets the width of the renderer
            * @returns {number}
            */
            get: function () { return this._width; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Renderer.prototype, "height", {
            /**
            * Gets the height of the renderer
            * @returns {number}
            */
            get: function () { return this._height; },
            enumerable: true,
            configurable: true
        });
        Renderer.resoucesToRemove = [];
        Renderer._sortArray = [];
        return Renderer;
    }());
    Trike.Renderer = Renderer;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Base class for all cameras
    */
    var Camera = (function (_super) {
        __extends(Camera, _super);
        function Camera(passes) {
            _super.call(this);
            this.matrixWorldInverse = new Trike.Matrix4();
            this.projectionMatrix = new Trike.Matrix4();
            this.projectionInverseMatrix = new Trike.Matrix4();
            this._projScreenMatrix = new Trike.Matrix4();
            this._lookAt = new Trike.Matrix4();
            this.passes = {};
            this.passes[Trike.Phase.Composition] = (passes ? passes[Trike.Phase.Composition] : [new Trike.CameraPass()]);
            this.passes[Trike.Phase.LightingSolid] = (passes ? passes[Trike.Phase.LightingSolid] : []);
            this.passes[Trike.Phase.PostCompostion] = (passes ? passes[Trike.Phase.PostCompostion] : []);
        }
        /**
        * Copies the values of the given camera
        * @param {Camera} cam the camera to copy from
        * @returns {Object3D}
        */
        Camera.prototype.copy = function (cam) {
            _super.prototype.copy.call(this, cam);
            this.matrixWorldInverse.copy(cam.matrixWorldInverse);
            this.projectionMatrix.copy(cam.projectionMatrix);
            this.projectionInverseMatrix.copy(cam.projectionInverseMatrix);
            this._projScreenMatrix.copy(cam._projScreenMatrix);
            this._lookAt.copy(cam._lookAt);
            this.passes[Trike.Phase.Composition] = cam.passes[Trike.Phase.Composition].slice(0, cam.passes[Trike.Phase.Composition].length);
            this.passes[Trike.Phase.LightingSolid] = cam.passes[Trike.Phase.LightingSolid].slice(0, cam.passes[Trike.Phase.LightingSolid].length);
            this.passes[Trike.Phase.PostCompostion] = cam.passes[Trike.Phase.PostCompostion].slice(0, cam.passes[Trike.Phase.PostCompostion].length);
            return this;
        };
        Object.defineProperty(Camera.prototype, "compositionMaterial", {
            get: function () {
                return this.getPassByName('Camera Pass').camEffects;
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Updates the camera matrices related to its world matrix
        */
        Camera.prototype.updateWorldMatrix = function (force) {
            _super.prototype.updateWorldMatrix.call(this, force);
            this.matrixWorldInverse.getInverse(this.worldMatrix);
            this._projScreenMatrix.multiplyMatrices(this.projectionMatrix, this.matrixWorldInverse);
        };
        /**
        * Override the look at function - for camera's we essentially swap the position and vector around.
        */
        Camera.prototype.lookAt = function (vector) {
            var m1 = this._lookAt.identity();
            m1.lookAt(this.position, vector, this.up);
            this.quaternion.setFromRotationMatrix(m1);
            this.updateMatrix = true;
        };
        /**
        * Cleans up the object.
        */
        Camera.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            for (var i = 0, l = this.passes[Trike.Phase.Composition].length; i < l; i++)
                this.passes[Trike.Phase.Composition][i].dispose();
            for (var i = 0, l = this.passes[Trike.Phase.LightingSolid].length; i < l; i++)
                this.passes[Trike.Phase.LightingSolid][i].dispose();
            for (var i = 0, l = this.passes[Trike.Phase.PostCompostion].length; i < l; i++)
                this.passes[Trike.Phase.PostCompostion][i].dispose();
            this.passes = null;
            this.matrixWorldInverse = null;
            this.projectionMatrix = null;
            this._projScreenMatrix = null;
            this._lookAt = null;
        };
        /**
        * Gets a composition pass by its name or null if it cant be found
        * @returns {CompositionPass}
        */
        Camera.prototype.getPassByName = function (name) {
            for (var i = 0, passes = this.passes[Trike.Phase.Composition], l = passes.length; i < l; i++)
                if (passes[i].name === name)
                    return passes[i];
            for (var i = 0, passes = this.passes[Trike.Phase.LightingSolid], l = passes.length; i < l; i++)
                if (passes[i].name === name)
                    return passes[i];
            for (var i = 0, passes = this.passes[Trike.Phase.PostCompostion], l = passes.length; i < l; i++)
                if (passes[i].name === name)
                    return passes[i];
            return null;
        };
        return Camera;
    }(Trike.Object3D));
    Trike.Camera = Camera;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A camera that contains both perspective as well as orthographic child cameras, that allows you to switch between the camera modes.
    */
    var CameraCombined = (function (_super) {
        __extends(CameraCombined, _super);
        function CameraCombined(width, height, fov, near, far, orthoNear, orthoFar) {
            if (width === void 0) { width = 800; }
            if (height === void 0) { height = 600; }
            if (fov === void 0) { fov = 60; }
            if (near === void 0) { near = 0.1; }
            if (far === void 0) { far = 2000.0; }
            if (orthoNear === void 0) { orthoNear = 0.1; }
            if (orthoFar === void 0) { orthoFar = 2000.0; }
            _super.call(this);
            this._fov = fov;
            this._left = -width / 2;
            this._top = height / 2;
            this._right = width / 2;
            this._bottom = -height / 2;
            this._zoom = 1;
            this.inOrthographicMode = false;
            this.inPerspectiveMode = true;
            this._activeCam = null;
            this._camP = new Trike.CameraPerspective(fov, width / height, near, far, this.passes);
            this._camO = new Trike.CameraOrthographic(width / -2, width / 2, height / 2, height / -2, orthoNear, orthoFar, this.passes);
            this.toPerspective();
        }
        //     propagateFogProperties()
        //     {
        //         var camP = this._camP;
        //         var camO = this._camO;
        //         camO.fogColor.copy( camP.fogColor.copy(this.fogColor) );
        //         camO.fogDensity = camP.fogDensity = this.fogDensity;
        //         camO.fogHeightDensity = camP.fogHeightDensity = this.fogHeightDensity;
        //         camO.fogHeightMax = camP.fogHeightMax = this.fogHeightMax;
        //         camO.fogHeightMin = camP.fogHeightMin = this.fogHeightMin;
        //         camO.fogType = camP.fogType = this.fogType;
        // camO.skybox(camP.skybox(this.skybox()));
        //     }
        /**
        * Copies the values of the given camera
        * @param {CameraOrthographic} cam the camera to copy from
        * @returns {Object3D}
        */
        CameraCombined.prototype.copy = function (cam) {
            _super.prototype.copy.call(this, cam);
            this.inOrthographicMode = cam.inOrthographicMode;
            this.inPerspectiveMode = cam.inPerspectiveMode;
            this._fov = cam._fov;
            this._left = cam._left;
            this._right = cam._right;
            this._top = cam._top;
            this._bottom = cam._bottom;
            this._zoom = cam._zoom;
            this._projScreenMatrix.copy(cam._projScreenMatrix);
            this.matrixWorldInverse.copy(cam.matrixWorldInverse);
            this._camP.copy(cam._camP);
            this._camO.copy(cam._camO);
            this._activeCam = (cam._activeCam === cam._camP ? this._camP : this._camO);
            return this;
        };
        /**
        * Rebuilds the camera projection matrices
        */
        CameraCombined.prototype.updateProjectionMatrix = function () {
            if (this.inPerspectiveMode)
                this.toPerspective();
            else {
                this.toPerspective();
                this.toOrthographic();
            }
        };
        /**
        * Sets the camera to be perspective
        */
        CameraCombined.prototype.toPerspective = function () {
            this._camP.fov = this._fov / this._zoom;
            this._camP.updateProjectionMatrix();
            this.inPerspectiveMode = true;
            this.inOrthographicMode = false;
            if (this._activeCam)
                this.remove(this._activeCam);
            this._activeCam = this._camP;
            this.add(this._activeCam);
        };
        /**
        * Sets the camera to be orthographic
        */
        CameraCombined.prototype.toOrthographic = function () {
            if (this._activeCam)
                this.remove(this._activeCam);
            // Switches to the Orthographic camera estimating viewport from Perspective
            var fov = this._fov;
            var aspect = this._camP.aspect;
            var near = this._camP.near;
            var far = this._camP.far;
            // The size that we set is the mid plane of the viewing frustum
            var hyperfocus = (near + far) / 2;
            var halfHeight = Math.tan(fov / 2) * hyperfocus;
            var planeHeight = 2 * halfHeight;
            var planeWidth = planeHeight * aspect;
            var halfWidth = planeWidth / 2;
            halfHeight /= this._zoom;
            halfWidth /= this._zoom;
            this._camO.left = -halfWidth;
            this._camO.right = halfWidth;
            this._camO.top = halfHeight;
            this._camO.bottom = -halfHeight;
            this._camO.updateProjectionMatrix();
            this.near = this._camO.near;
            this.far = this._camO.far;
            this.inPerspectiveMode = false;
            this.inOrthographicMode = true;
            this._activeCam = this._camO;
            this.add(this._activeCam);
        };
        /**
        * Updates the camera matrices related to its world matrix
        */
        CameraCombined.prototype.updateWorldMatrix = function (force) {
            _super.prototype.updateWorldMatrix.call(this, force);
            this.matrixWorldInverse.getInverse(this.worldMatrix);
            this._projScreenMatrix.multiplyMatrices(this._activeCam.projectionMatrix, this.matrixWorldInverse);
            this.projectionMatrix.copy(this._activeCam.projectionMatrix);
            this.projectionInverseMatrix.getInverse(this.projectionMatrix);
        };
        /**
        * Sets the aspect ratio for a perspective mode and the viewing area in orthographic
        */
        CameraCombined.prototype.setSize = function (width, height) {
            this._camP.aspect = width / height;
            this._left = -width / 2;
            this._right = width / 2;
            this._top = height / 2;
            this._bottom = -height / 2;
        };
        /**
        * Sets the field of view
        */
        CameraCombined.prototype.setFov = function (fov) {
            this._fov = fov;
            if (this.inPerspectiveMode)
                this.toPerspective();
            else
                this.toOrthographic();
        };
        /**
        * Cleans up the object.
        */
        CameraCombined.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        /**
        * Sets the zoom of the camera
        */
        CameraCombined.prototype.setZoom = function (zoom) {
            this._zoom = zoom;
            if (this.inPerspectiveMode)
                this.toPerspective();
            else
                this.toOrthographic();
        };
        /**
        * Re-aligns the camera to face the front
        */
        CameraCombined.prototype.toFrontView = function () {
            this.setRotation(0, 0, 0);
        };
        /**
        * Re-aligns the camera to face the back
        */
        CameraCombined.prototype.toBackView = function () {
            this.setRotation(0, Math.PI, 0);
        };
        /**
        * Re-aligns the camera to face the left
        */
        CameraCombined.prototype.toLeftView = function () {
            this.setRotation(0, -Math.PI / 2, 0);
        };
        /**
        * Re-aligns the camera to face the right
        */
        CameraCombined.prototype.toRightView = function () {
            this.setRotation(0, Math.PI / 2, 0);
        };
        /**
        * Re-aligns the camera to face the top
        */
        CameraCombined.prototype.toTopView = function () {
            this.setRotation(-Math.PI / 2, 0, 0);
        };
        /**
        * Re-aligns the camera to face the bottom
        */
        CameraCombined.prototype.toBottomView = function () {
            this.setRotation(Math.PI / 2, 0, 0);
        };
        Object.defineProperty(CameraCombined.prototype, "activeCamera", {
            get: function () { return this._activeCam; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CameraCombined.prototype, "fov", {
            get: function () { return this._fov; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CameraCombined.prototype, "aspect", {
            get: function () { return this._camP._aspect; },
            set: function (val) {
                if (val === this._camP.aspect)
                    return;
                this._camP.aspect = val;
                this.updateWorldMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CameraCombined.prototype, "far", {
            get: function () { return (this._activeCam).far; },
            set: function (val) {
                if (val === this._activeCam.far)
                    return;
                this._activeCam.far = val;
                this.updateWorldMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CameraCombined.prototype, "near", {
            get: function () { return (this._activeCam).near; },
            set: function (val) {
                if (val === this._activeCam.near)
                    return;
                this._activeCam.near = val;
                this.updateWorldMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CameraCombined.prototype, "zoom", {
            get: function () { return this._zoom; },
            enumerable: true,
            configurable: true
        });
        return CameraCombined;
    }(Trike.Camera));
    Trike.CameraCombined = CameraCombined;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A simple orthographic camera
    */
    var CameraOrthographic = (function (_super) {
        __extends(CameraOrthographic, _super);
        function CameraOrthographic(left, right, top, bottom, near, far, passes) {
            if (near === void 0) { near = 0.1; }
            if (far === void 0) { far = 1000.0; }
            _super.call(this, passes);
            this._left = left;
            this._right = right;
            this._top = top;
            this._bottom = bottom;
            this._near = near;
            this._far = far;
            this.updateProjectionMatrix();
        }
        /**
        * Copies the values of the given camera
        * @param {CameraOrthographic} cam the camera to copy from
        * @returns {Object3D}
        */
        CameraOrthographic.prototype.copy = function (cam) {
            _super.prototype.copy.call(this, cam);
            this._left = cam._left;
            this._right = cam._right;
            this._top = cam._top;
            this._bottom = cam._bottom;
            this._near = cam._near;
            this._far = cam._far;
            return this;
        };
        /**
        * Rebuilds the camera projection matrices
        */
        CameraOrthographic.prototype.updateProjectionMatrix = function () {
            this.projectionMatrix.makeOrthographic(this._left, this._right, this._top, this._bottom, this._near, this._far);
            this.projectionInverseMatrix.getInverse(this.projectionMatrix);
        };
        /**
        * Cleans up the object.
        */
        CameraOrthographic.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        CameraOrthographic.prototype.updateDimensions = function (left, right, top, bottom, near, far) {
            this._left = left;
            this._right = right;
            this._top = top;
            this._bottom = bottom;
            this._near = near;
            this._far = far;
            this.updateProjectionMatrix();
        };
        Object.defineProperty(CameraOrthographic.prototype, "left", {
            get: function () { return this._left; },
            set: function (val) {
                if (this._left === val)
                    return;
                this._left = val;
                this.updateProjectionMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CameraOrthographic.prototype, "right", {
            get: function () { return this._right; },
            set: function (val) {
                if (this._right === val)
                    return;
                this._right = val;
                this.updateProjectionMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CameraOrthographic.prototype, "top", {
            get: function () { return this._top; },
            set: function (val) {
                if (this._top === val)
                    return;
                this._top = val;
                this.updateProjectionMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CameraOrthographic.prototype, "bottom", {
            get: function () { return this._bottom; },
            set: function (val) {
                if (this._bottom === val)
                    return;
                this._bottom = val;
                this.updateProjectionMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CameraOrthographic.prototype, "near", {
            get: function () { return this._near; },
            set: function (val) {
                if (this._near === val)
                    return;
                this._near = val;
                this.updateProjectionMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CameraOrthographic.prototype, "far", {
            get: function () { return this._far; },
            set: function (val) {
                if (this._far === val)
                    return;
                this._far = val;
                this.updateProjectionMatrix();
            },
            enumerable: true,
            configurable: true
        });
        return CameraOrthographic;
    }(Trike.Camera));
    Trike.CameraOrthographic = CameraOrthographic;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A simple perspective camera
    */
    var CameraPerspective = (function (_super) {
        __extends(CameraPerspective, _super);
        function CameraPerspective(fov, aspect, near, far, passes) {
            if (fov === void 0) { fov = 60; }
            if (aspect === void 0) { aspect = 8 / 6; }
            if (near === void 0) { near = 0.1; }
            if (far === void 0) { far = 1000.0; }
            _super.call(this, passes);
            this._fov = fov;
            this._aspect = aspect;
            this._near = near;
            this._far = far;
            this.updateProjectionMatrix();
        }
        /**
        * Copies the values of the given camera
        * @param {CameraPerspective} cam the camera to copy from
        * @returns {Object3D}
        */
        CameraPerspective.prototype.copy = function (cam) {
            _super.prototype.copy.call(this, cam);
            this._fov = cam._fov;
            this._aspect = cam._aspect;
            this._near = cam._near;
            this._far = cam._far;
            return this;
        };
        /**
        * Rebuilds the camera projection matrices
        */
        CameraPerspective.prototype.updateProjectionMatrix = function () {
            this.projectionMatrix.makePerspective(this._fov, this._aspect, this._near, this._far);
            this.projectionInverseMatrix.getInverse(this.projectionMatrix);
        };
        /**
        * Cleans up the object.
        */
        CameraPerspective.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(CameraPerspective.prototype, "fov", {
            get: function () { return this._fov; },
            set: function (val) {
                if (val === this._fov)
                    return;
                this._fov = val;
                this.updateProjectionMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CameraPerspective.prototype, "aspect", {
            get: function () { return this._aspect; },
            set: function (val) {
                if (val === this._aspect)
                    return;
                this._aspect = val;
                this.updateProjectionMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CameraPerspective.prototype, "far", {
            get: function () { return this._far; },
            set: function (val) {
                if (val === this._far)
                    return;
                this._far = val;
                this.updateProjectionMatrix();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CameraPerspective.prototype, "near", {
            get: function () { return this._near; },
            set: function (val) {
                if (val === this._near)
                    return;
                this._near = val;
                this.updateProjectionMatrix();
            },
            enumerable: true,
            configurable: true
        });
        return CameraPerspective;
    }(Trike.Camera));
    Trike.CameraPerspective = CameraPerspective;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Base class for all lights
    */
    var Light = (function (_super) {
        __extends(Light, _super);
        function Light(material, geometry, color) {
            if (color === void 0) { color = 0xFFFFFF; }
            _super.call(this, material, geometry);
            this.color = new Trike.Color(color);
            // Create the static geometry
            if (!Light.geomPlane) {
                Light.geomPlane = new Trike.GeometryScreenPlane();
                Light.geomSphere = new Trike.GeometrySphere(1, 16, 8);
                Light.lightCount = 0;
            }
            Light.lightCount++;
            this.pickable = false;
        }
        /*
        * Called just before we render the mesh. The mesh would have passed culling and already be updated.
        * A good place to update custom uniforms.
        * @param {Renderer} renderer The renderer used to draw the scene
        * @param {RenderPass} renderPass The render pass associated with this call
        */
        Light.prototype.preRender = function (renderer, renderPass) {
            var material = this._material.materials[Trike.PassType.Lights];
            var pass = renderPass;
            material.setUniform('lightColor', this.color);
        };
        /**
        * Cleans up the object.
        */
        Light.prototype.dispose = function () {
            Light.lightCount--;
            if (Light.lightCount === 0) {
                Light.geomPlane.dispose();
                Light.geomSphere.dispose();
            }
            this.color = null;
            _super.prototype.dispose.call(this);
        };
        return Light;
    }(Trike.Mesh));
    Trike.Light = Light;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A light that points in a target direction.
    */
    var LightPoint = (function (_super) {
        __extends(LightPoint, _super);
        function LightPoint(color) {
            if (color === void 0) { color = 0xFFFFFF; }
            _super.call(this, null, null, color);
            // Set the materials and geometries
            if (!LightPoint._mat) {
                LightPoint._mat = new Trike.MaterialLightPoint();
                LightPoint._tempVS = new Trike.Vec3();
            }
            this.setMaterial(LightPoint._mat);
            if (LightPoint._mat.renderType === Trike.POINT_LIGHT_RENDER_TYPE.Perspective)
                this.setGeometry(Trike.Light.geomSphere);
            else {
                this.setGeometry(Trike.Light.geomPlane);
                this.sceneCull = false;
            }
            this.intensity = 1;
            this._radius = 1;
            this.translucencyIntensity = 1;
            this.translucencyColor = new Trike.Color();
        }
        /**
        * Updates the objects vertices
        * @param {boolean} If true, the world matrices will be forced to update
        * @param {boolean} If true, the local matrices will be forced to update
        */
        LightPoint.prototype.updateWorldMatrix = function (forceWorldUpdate, forceLocalUpdate) {
            if (forceWorldUpdate === void 0) { forceWorldUpdate = false; }
            if (forceLocalUpdate === void 0) { forceLocalUpdate = false; }
            // For point lights we set the scale to be equal to that of the radius.
            if (LightPoint._mat.renderType === Trike.POINT_LIGHT_RENDER_TYPE.Perspective) {
                var radius = this._radius;
                if (forceWorldUpdate || this.updateMatrixWorld || this.updateMatrix)
                    this.setScale(radius, radius, radius);
            }
            _super.prototype.updateWorldMatrix.call(this, forceWorldUpdate, forceLocalUpdate);
        };
        /*
        * Called just before we render the mesh. The mesh would have passed culling and already be updated.
        * A good place to update custom uniforms.
        * @param {Renderer} renderer The renderer used to draw the scene
        * @param {RenderPass} renderPass The render pass associated with this call
        */
        LightPoint.prototype.preRender = function (renderer, renderPass) {
            _super.prototype.preRender.call(this, renderer, renderPass);
            var material = this._material.materials[Trike.PassType.Lights];
            var lightPass = renderPass;
            material.setUniform('lightIntensity', this.intensity, false);
            material.setUniform('lightRadius', this.radius, false);
            material.setUniform('translucencyIntensity', this.translucencyIntensity, false);
            material.setUniform('translucencyColor', this.translucencyColor, false);
            // Get the light position in viewspace
            var tempVS = LightPoint._tempVS;
            tempVS.getPositionFromMatrix(this.worldMatrix);
            tempVS.applyMatrix4(lightPass.camera.matrixWorldInverse);
            material.setUniform('lightPositionVS', tempVS, false);
        };
        /**
        * Cleans up the object.
        */
        LightPoint.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(LightPoint.prototype, "radius", {
            /**
            * Gets the radius of the light
            */
            get: function () { return this._radius; },
            /**
            * Sets the radius of the light
            */
            set: function (val) {
                this._radius = val;
                this.updateMatrix = true;
            },
            enumerable: true,
            configurable: true
        });
        return LightPoint;
    }(Trike.Light));
    Trike.LightPoint = LightPoint;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A light that points in a target direction.
    */
    var LightDirectional = (function (_super) {
        __extends(LightDirectional, _super);
        function LightDirectional(target, color) {
            if (target === void 0) { target = new Trike.Vec3(0, 0, 0); }
            if (color === void 0) { color = 0xFFFFFF; }
            _super.call(this, null, null, color);
            // Set the materials and geometries
            if (!LightDirectional._mat) {
                LightDirectional._mat = new Trike.MaterialLightDirectional();
                LightDirectional._dir = new Trike.Vec3();
                LightDirectional._tempVS = new Trike.Vec3();
            }
            this.setMaterial(LightDirectional._mat);
            this.setGeometry(Trike.Light.geomPlane);
            this.target = target;
            this.intensity = 1;
            this.sceneCull = false;
            this.translucencyColor = new Trike.Color();
            this._shadowMapping = false;
            this.castShadows(false);
            this.onlyShadow = false;
            this._shadowFilter = Trike.ShadowQuality.Low;
            this._shadowMapSize = 512;
            this._shadowBoxSize = 10;
            this._shadowBoxNear = 0.1;
            this._shadowBoxFar = 500;
            this._shadowBias = 0;
            this._shadowDarkness = 0.5;
        }
        /*
        * Called just before we render the mesh. The mesh would have passed culling and already be updated.
        * A good place to update custom uniforms.
        * @param {Renderer} renderer The renderer used to draw the scene
        * @param {RenderPass} renderPass The render pass associated with this call
        */
        LightDirectional.prototype.preRender = function (renderer, renderPass) {
            _super.prototype.preRender.call(this, renderer, renderPass);
            var material = this.material.materials[Trike.PassType.Lights];
            var lightPass = renderPass;
            material.setUniform('lightIntensity', this.intensity);
            material.setUniform('translucencyIntensity', this.translucencyIntensity);
            material.setUniform('translucencyColor', this.translucencyColor);
            // Get the light direction in viewspace
            var dir = LightDirectional._dir;
            var tempVS = LightDirectional._tempVS;
            dir.getPositionFromMatrix(this.worldMatrix);
            tempVS.copy(this.target);
            dir.sub(tempVS);
            dir.normalize();
            dir.transformDirection(lightPass.camera.matrixWorldInverse);
            material.setUniform('lightDirectionVS', dir);
        };
        /**
        * Gets or sets the quality of the shadow mapping filtering
        * @param val {boolean} [Optional]
        * @returns {boolean}
        */
        LightDirectional.prototype.shadowQuality = function (val) {
            if (val === undefined)
                return this._shadowFilter;
            if (this._shadowMap)
                this._shadowMap.dispose();
            if (this._shadowFilter === Trike.ShadowQuality.High) {
                var textureFilter = Trike.TextureFilter.Linear;
                this._shadowMap = new Trike.RenderTarget(this._shadowMapSize, this._shadowMapSize, Trike.TextureType.FloatType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Linear, Trike.TextureFilter.Linear, Trike.TextureFormat.RGBFormat, 1, false, false);
            }
            else {
                var textureFilter = Trike.TextureFilter.Nearest;
                this._shadowMap = new Trike.RenderTarget(this._shadowMapSize, this._shadowMapSize, Trike.TextureType.UnsignedByteType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, textureFilter, textureFilter, Trike.TextureFormat.RGBAFormat, 1, true, false);
            }
            return val;
        };
        /**
        * Gets or sets if this light does shadow mapping
        * @param val {boolean} [Optional]
        * @returns {boolean}
        */
        LightDirectional.prototype.shadowMapping = function (val) {
            if (val === undefined)
                return (this._shadowMapping ? true : false);
            if (this._shadowMapping === val)
                return val;
            this._shadowMapping = val;
            if (val) {
                this.shadowQuality(this._shadowFilter);
                this._shadowMatrix = new Trike.Matrix4();
                this._shadowCamera = new Trike.CameraOrthographic(-this._shadowBoxSize, this._shadowBoxSize, this._shadowBoxSize, -this._shadowBoxSize, this._shadowBoxNear, this._shadowBoxFar);
                this.castShadows(true);
            }
            else if (this._shadowCamera) {
                this._shadowMap.dispose();
                this._shadowCamera.dispose();
                this._shadowMap = null;
                this._shadowMatrix = null;
                this._shadowCamera = null;
                this.castShadows(false);
            }
        };
        /**
        * Cleans up the object.
        */
        LightDirectional.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        /**
        * Gets the render target that this light draws its shadows onto
        * @returns {RenderTarget}
        */
        LightDirectional.prototype.shadowMap = function () { return this._shadowMap; };
        /**
        * Gets the shadow matrix of this light
        * @returns {Matrix4}
        */
        LightDirectional.prototype.shadowMatrix = function () { return this._shadowMatrix; };
        /**
        * Gets the camera used to draw the shadows of this light
        * @returns {Camera}
        */
        LightDirectional.prototype.shadowCamera = function () { return this._shadowCamera; };
        /**
        * Gets the shadow map size
        * @param {number} val [Optional]
        * @returns {number}
        */
        LightDirectional.prototype.shadowMapSize = function (val) {
            if (val === undefined)
                return this._shadowMapSize;
            if (this._shadowMap)
                this._shadowMap.resize(val, val);
            this._shadowMapSize = val;
        };
        /**
        * Gets the shadow darkness
        * @param {number} val [Optional]
        * @returns {number}
        */
        LightDirectional.prototype.shadowBoxSize = function (val) {
            if (val === undefined)
                return this._shadowBoxSize;
            this._shadowBoxSize = val;
            if (this._shadowCamera)
                this._shadowCamera.updateDimensions(-this._shadowBoxSize, this._shadowBoxSize, this._shadowBoxSize, -this._shadowBoxSize, this._shadowBoxNear, this._shadowBoxFar);
            return val;
        };
        /**
        * Gets the shadow near value
        * @param {number} val [Optional]
        * @returns {number}
        */
        LightDirectional.prototype.shadowBoxNear = function (val) {
            if (val === undefined)
                return this._shadowBoxNear;
            this._shadowBoxNear = val;
            if (this._shadowCamera)
                this._shadowCamera.updateDimensions(-this._shadowBoxSize, this._shadowBoxSize, this._shadowBoxSize, -this._shadowBoxSize, this._shadowBoxNear, this._shadowBoxFar);
            return val;
        };
        /**
        * Gets the shadow near value
        * @param {number} val [Optional]
        * @returns {number}
        */
        LightDirectional.prototype.shadowBoxFar = function (val) {
            if (val === undefined)
                return this._shadowBoxFar;
            this._shadowBoxFar = val;
            if (this._shadowCamera)
                this._shadowCamera.updateDimensions(-this._shadowBoxSize, this._shadowBoxSize, this._shadowBoxSize, -this._shadowBoxSize, this._shadowBoxNear, this._shadowBoxFar);
            return val;
        };
        /**
        * Gets the shadow darkness
        * @param {number} val [Optional]
        * @returns {number}
        */
        LightDirectional.prototype.shadowDarkness = function (val) {
            if (val === undefined)
                return this._shadowDarkness;
            this._shadowDarkness = val;
            return val;
        };
        /**
        * Gets the shadow bias
        * @param {number} val [Optional]
        * @returns {number}
        */
        LightDirectional.prototype.shadowBias = function (val) {
            if (val === undefined)
                return this._shadowBias;
            this._shadowBias = val;
            return val;
        };
        return LightDirectional;
    }(Trike.Light));
    Trike.LightDirectional = LightDirectional;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A simple emmisive light
    */
    var LightAmbient = (function (_super) {
        __extends(LightAmbient, _super);
        function LightAmbient(color, intensity) {
            if (color === void 0) { color = 0xffffff; }
            if (intensity === void 0) { intensity = 1; }
            _super.call(this, null, null, color);
            // Set the materials and geometries
            this._mat = new Trike.MaterialLightAmbient();
            this.setMaterial(this._mat);
            this.setGeometry(Trike.Light.geomPlane);
            this.sceneCull = false;
            this.intensity = intensity;
        }
        /*
        * Cleans up the class
        */
        LightAmbient.prototype.dispose = function () {
            this._mat.dispose();
            this._mat = null;
        };
        /*
        * Called just before we render the mesh. The mesh would have passed culling and already be updated.
        * A good place to update custom uniforms.
        * @param {Renderer} renderer The renderer used to draw the scene
        * @param {RenderPass} renderPass The render pass associated with this call
        */
        LightAmbient.prototype.preRender = function (renderer, renderPass) {
            _super.prototype.preRender.call(this, renderer, renderPass);
            var material = this._material.materials[Trike.PassType.Lights];
            var lightPass = renderPass;
            material.setUniform('lightIntensity', this.intensity, false);
        };
        return LightAmbient;
    }(Trike.Light));
    Trike.LightAmbient = LightAmbient;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * An emissive light that gets its ambient terms from the cube texture of a sky box using variance environment maps
    */
    var LightAtmospheric = (function (_super) {
        __extends(LightAtmospheric, _super);
        /**
        * Creates an instance of the light
        */
        function LightAtmospheric(color) {
            if (color === void 0) { color = 0xffffff; }
            _super.call(this, null, null, color);
            // Set the materials and geometries
            this._mat = new Trike.MaterialLightAtmospheric();
            this.setMaterial(this._mat);
            this.setGeometry(Trike.Light.geomPlane);
            this.sceneCull = false;
            this._intensity = 1;
        }
        /*
        * Cleans up the class
        */
        LightAtmospheric.prototype.dispose = function () {
            this._mat.dispose();
            this._mat = null;
            this.convolver = null;
        };
        /*
        * Set the sky box from where this light gets its values
        * @param {CubeConvolver} [Optional]
        * @returns {CubeConvolver}
        */
        LightAtmospheric.prototype.convolver = function (val) {
            if (val === undefined)
                return this._convolver;
            this._convolver = val;
            this._mat.setSky(val ? true : false);
            return val;
        };
        /*
        * Get or set the intensity of the light
        * @param {number} [Optional]
        * @returns {number}
        */
        LightAtmospheric.prototype.intensity = function (val) {
            if (val === undefined)
                return this._intensity;
            this._intensity = val;
            this._mat.setUniform('lightIntensity', this._intensity, true);
            return val;
        };
        /*
        * Called just before we render the mesh. The mesh would have passed culling and already be updated.
        * A good place to update custom uniforms.
        * @param {Renderer} renderer The renderer used to draw the scene
        * @param {RenderPass} renderPass The render pass associated with this call
        */
        LightAtmospheric.prototype.preRender = function (renderer, renderPass) {
            _super.prototype.preRender.call(this, renderer, renderPass);
            var material = this._material.materials[Trike.PassType.Lights];
            var lightPass = renderPass;
            if (this._convolver) {
                var target = this._convolver.cubeTexture();
                material.setUniform('viewMat', renderPass.camera.matrixWorldInverse, false);
                material.setUniform('sampler', target, false);
            }
        };
        return LightAtmospheric;
    }(Trike.Light));
    Trike.LightAtmospheric = LightAtmospheric;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A light that points in a target direction.
    */
    var LightSpot = (function (_super) {
        __extends(LightSpot, _super);
        function LightSpot(target, color) {
            if (target === void 0) { target = new Trike.Vec3(0, 0, 0); }
            if (color === void 0) { color = 0xFFFFFF; }
            _super.call(this, null, null, color);
            // Set the materials and geometries
            if (!LightSpot._mat) {
                LightSpot._mat = new Trike.MaterialLightSpot();
                LightSpot._tempVS = new Trike.Vec3();
                LightSpot._dir = new Trike.Vec3();
            }
            this.setMaterial(LightSpot._mat);
            this.setGeometry(Trike.Light.geomPlane);
            this.intensity = 1;
            this.translucencyIntensity = 1;
            this.translucencyColor = new Trike.Color();
            this.angle = 1;
            this.target = target;
            this.sceneCull = false;
        }
        /*
        * Called just before we render the mesh. The mesh would have passed culling and already be updated.
        * A good place to update custom uniforms.
        * @param {Renderer} renderer The renderer used to draw the scene
        * @param {RenderPass} renderPass The render pass associated with this call
        */
        LightSpot.prototype.preRender = function (renderer, renderPass) {
            _super.prototype.preRender.call(this, renderer, renderPass);
            var material = this._material.materials[Trike.PassType.Lights];
            var lightPass = renderPass;
            var target = this.target;
            material.setUniform('lightIntensity', this.intensity, false);
            material.setUniform('lightAngle', this.angle, false);
            material.setUniform('translucencyIntensity', this.translucencyIntensity, false);
            material.setUniform('translucencyColor', this.translucencyColor, false);
            // Get the light position in viewspace
            var tempVS = LightSpot._tempVS;
            tempVS.getPositionFromMatrix(this.worldMatrix);
            tempVS.applyMatrix4(lightPass.camera.matrixWorldInverse);
            material.setUniform('lightPositionVS', tempVS, false);
            // Get the light direction in viewspace
            var dir = LightSpot._dir;
            dir.getPositionFromMatrix(this.worldMatrix);
            tempVS.copy(this.target);
            dir.sub(tempVS);
            dir.normalize();
            dir.transformDirection(lightPass.camera.matrixWorldInverse);
            material.setUniform('lightDirectionVS', dir, false);
        };
        /**
        * Cleans up the object.
        */
        LightSpot.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        return LightSpot;
    }(Trike.Light));
    Trike.LightSpot = LightSpot;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * The base node for a 3D scene
    */
    var Scene = (function (_super) {
        __extends(Scene, _super);
        function Scene() {
            _super.call(this);
            this.allVisuals = [];
            this.meshes = [];
            this.pointClouds = [];
            this.lights = [];
            this.skyboxes = [];
            this.mirrors = [];
            this.lightsFullScreen = [];
            this.lightsPerspective = [];
            this._tempChildList = [];
            this.cubeRenderers = [];
            this.convolvers = [];
        }
        /**
        * Adds a child to this object
        * @param {Object3D} child The child object to add
        */
        Scene.prototype.add = function (child) {
            _super.prototype.add.call(this, child);
            // For each object, we need to flatten it out and get the various
            // raw renderables & components of a scene render list.
            var temp = this._tempChildList;
            temp.splice(0, temp.length);
            child.getAllChildren(temp);
            for (var i = 0, ilen = temp.length; i < ilen; i++)
                this._addObject(temp[i], false);
            this.allVisuals.sort(this.sortObjects);
            // Cleanup
            temp.splice(0, temp.length);
        };
        /**
        * Called from Object3D - friend class - adds the object to the scene's array lists
        * @param {Object3D} o3D The child object to add
        * @param {boolean} sort If true, the mesh arrays will be sorted
        */
        Scene.prototype._addObject = function (o3D, sort) {
            if (sort === void 0) { sort = true; }
            var allVisuals = this.allVisuals, lights = this.lights, meshes = this.meshes, skyboxes = this.skyboxes, pointClouds = this.pointClouds, mirrors = this.mirrors, cubeRenderers = this.cubeRenderers, convolvers = this.convolvers;
            // Light
            if (o3D instanceof Trike.Light) {
                if (lights.indexOf(o3D) === -1) {
                    lights.push(o3D);
                    if (o3D instanceof Trike.LightPoint)
                        this.lightsPerspective.push(o3D);
                    else
                        this.lightsFullScreen.push(o3D);
                }
            }
            else if (o3D instanceof Trike.PointCloud) {
                if (pointClouds.indexOf(o3D) === -1)
                    pointClouds.push(o3D);
            }
            else if (o3D instanceof Trike.CubeRenderer) {
                if (cubeRenderers.indexOf(o3D) === -1)
                    cubeRenderers.push(o3D);
            }
            else if (o3D instanceof Trike.CubeConvolver) {
                if (convolvers.indexOf(o3D) === -1)
                    convolvers.push(o3D);
            }
            else if (o3D instanceof Trike.Skybox) {
                if (skyboxes.indexOf(o3D) === -1)
                    skyboxes.push(o3D);
            }
            else if (o3D instanceof Trike.Mesh) {
                if (meshes.indexOf(o3D) === -1)
                    meshes.push(o3D);
            }
            if (o3D instanceof Trike.Mesh) {
                if (allVisuals.indexOf(o3D) === -1)
                    allVisuals.push(o3D);
            }
            // Mirrors
            if (o3D.mirror) {
                if (o3D.mirror && mirrors.indexOf(o3D.mirror) === -1)
                    mirrors.push(o3D.mirror);
            }
            if (sort)
                allVisuals.sort(this.sortObjects);
        };
        /**
        * Called from Object3D - friend class - removes the object from the scene's array lists
        * @param {Object3D} o3D The child object to add
        * @param {boolean} sort If true, the mesh arrays will be sorted
        */
        Scene.prototype._removeObject = function (o3D, sort) {
            if (sort === void 0) { sort = true; }
            var allVisuals = this.allVisuals, lights = this.lights, meshes = this.meshes, skyboxes = this.skyboxes, pointClouds = this.pointClouds, mirrors = this.mirrors, cubeRenderers = this.cubeRenderers, convolvers = this.convolvers;
            // Lights
            if (o3D instanceof Trike.Light && lights.indexOf(o3D) !== -1) {
                lights.splice(lights.indexOf(o3D), 1);
                if (o3D instanceof Trike.LightPoint)
                    this.lightsPerspective.splice(this.lightsPerspective.indexOf(o3D), 1);
                else
                    this.lightsFullScreen.splice(this.lightsFullScreen.indexOf(o3D), 1);
            }
            else if (o3D instanceof Trike.PointCloud && pointClouds.indexOf(o3D) !== -1)
                pointClouds.splice(pointClouds.indexOf(o3D), 1);
            else if (o3D instanceof Trike.CubeRenderer && cubeRenderers.indexOf(o3D) !== -1)
                cubeRenderers.splice(cubeRenderers.indexOf(o3D), 1);
            else if (o3D instanceof Trike.CubeConvolver && convolvers.indexOf(o3D) !== -1)
                convolvers.splice(convolvers.indexOf(o3D), 1);
            else if (o3D instanceof Trike.Skybox && skyboxes.indexOf(o3D) !== -1)
                skyboxes.splice(skyboxes.indexOf(o3D), 1);
            else if (o3D instanceof Trike.Mesh && meshes.indexOf(o3D) !== -1)
                meshes.splice(meshes.indexOf(o3D), 1);
            if (o3D instanceof Trike.Mesh && allVisuals.indexOf(o3D) !== -1)
                allVisuals.splice(allVisuals.indexOf(o3D), 1);
            // Mirrors
            if (o3D.mirror)
                mirrors.splice(mirrors.indexOf(o3D.mirror), 1);
            if (sort)
                allVisuals.sort(this.sortObjects);
        };
        /**
        * removes a child from this object
        * @param {Object3D} child The child object to remove
        */
        Scene.prototype.remove = function (child) {
            _super.prototype.remove.call(this, child);
            // Fpr each object, we need to remove any
            // raw renderables or components of a scene render list.
            var temp = this._tempChildList;
            child.getAllChildren(temp);
            var lights = this.lights, meshes = this.meshes;
            for (var i = 0, ilen = temp.length; i < ilen; i++)
                this._removeObject(temp[i], false);
            this.allVisuals.sort(this.sortObjects);
            // Cleanup
            temp.splice(0, temp.length);
        };
        /**
        * Optimizes the scene by sorting the objects accordingly.
        */
        Scene.prototype.sortObjects = function (a, b) {
            if (a.geometry === b.geometry && a.material === b.material)
                return -1;
            else if (a.geometry === b.geometry)
                return 0;
            else if (a.material === b.material)
                return 0;
            else
                return 1;
        };
        return Scene;
    }(Trike.Object3D));
    Trike.Scene = Scene;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /*
    * A specialized scene class, designed for drawing screen quads
    */
    var SceneScreenQuad = (function (_super) {
        __extends(SceneScreenQuad, _super);
        function SceneScreenQuad() {
            _super.call(this);
            this.quad = new Trike.Mesh(new Trike.MaterialScreenQuad(), new Trike.GeometryScreenPlane());
            this.camera = new Trike.CameraOrthographic(-1, 1, 1, -1, 0, 1);
            this.add(this.quad);
        }
        Object.defineProperty(SceneScreenQuad.prototype, "material", {
            /** Returns the material applied to the quad mesh */
            get: function () { return this.quad.material; },
            enumerable: true,
            configurable: true
        });
        return SceneScreenQuad;
    }(Trike.Scene));
    Trike.SceneScreenQuad = SceneScreenQuad;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A small helper class used when collecing data about intersections
    */
    var Intersection = (function () {
        function Intersection(distance, point, face, object) {
            this.distance = distance;
            this.point = point;
            this.face = face;
            this.object = object;
        }
        return Intersection;
    }());
    Trike.Intersection = Intersection;
    /** Internal only - used in the array loops below */
    var Triangle = (function () {
        function Triangle(a, b, c, face) {
            if (face === void 0) { face = null; }
            this.a = a;
            this.b = b;
            this.c = c;
            this.face = face;
        }
        return Triangle;
    }());
    /**
    * A helper class which creates a Ray and uses it to test for intersections with objects.
    */
    var RayCaster = (function () {
        function RayCaster(origin, direction, near, far) {
            if (near === void 0) { near = 0; }
            if (far === void 0) { far = Infinity; }
            this._sphere = new Trike.Sphere();
            this._localRay = new Trike.Ray();
            this._matrixPosition = new Trike.Matrix4();
            this._inverseMatrix = new Trike.Matrix4();
            this._tempPos = new Trike.Vec3();
            this._tempScale = new Trike.Vec3();
            this._alignedPosition = new Trike.Vec2();
            this._rotatedPosition = new Trike.Vec2();
            this._finalPosition = new Trike.Vec3();
            this._transformedVerts = Array();
            this._projector = new Trike.Projector();
            // direction is assumed to be normalized (for accurate distance calculations)
            this.ray = new Trike.Ray(origin, direction);
            this.near = near || 0;
            this.far = far || Infinity;
            if (RayCaster._numCasters === 0) {
                RayCaster._trianglePool = new Array();
                RayCaster._numCasters++;
            }
        }
        /** Sort the intersections based on distance */
        RayCaster.prototype.descSort = function (a, b) {
            return a.distance - b.distance;
        };
        RayCaster.prototype.unprojectSpriteVector = function (vector, camera, sprite) {
            var mvInv = new Trike.Matrix4().getInverse(sprite.worldMatrix).multiply(camera.worldMatrix);
            var projectionMatrixInverse = new Trike.Matrix4().getInverse(camera.projectionMatrix);
            var viewProjInv = new Trike.Matrix4().multiplyMatrices(mvInv, projectionMatrixInverse);
            return vector.applyProjection(viewProjInv);
        };
        /**
        * Returns an array of Intersections made between this and the object3d provided.
        */
        RayCaster.prototype.intersectObject = function (object, intersects, camera) {
            var sphere = this._sphere;
            var localRay = this._localRay;
            var matrixPosition = this._matrixPosition;
            var inverseMatrix = this._inverseMatrix;
            var ray = this.ray;
            var precision = RayCaster._precision;
            var linePrecision = RayCaster._linePrecision;
            var intersectionPoint;
            var numIntersects = intersects.length;
            // Check for picking with sprites
            if (object instanceof Trike.Sprite) {
                var sprite = object;
                if (!sprite.pickable)
                    return;
                var spriteMat = sprite.material;
                // If no material then the sprite is not visible.
                if (!spriteMat)
                    return;
                // First check if we're intersecting the sprite sphere BB (much cheaper calc)
                var geometry = sprite._geometry;
                sphere.copy(geometry.boundingSphere);
                sphere.applyMatrix4(sprite.worldMatrix);
                if (ray.isIntersectionSphere(sphere) === false)
                    return intersects;
                // First get some temp vars to speed up the process
                var temoPos = this._tempPos;
                var tempScale = this._tempScale;
                var alignedPosition = this._alignedPosition;
                var rotatedPosition = this._rotatedPosition;
                var finalPosition = this._finalPosition;
                var rotation = spriteMat.rotation();
                var verts = geometry.buffers[Trike.AttributeType.POSITION].data;
                var transformedVerts = this._transformedVerts;
                var projector = this._projector;
                // Get the world position and scale of the sprite
                tempScale.getScaleFromMatrix(object.worldMatrix);
                // Now for each vertex, we apply the same formula thats applied to the vert in the vertex shader.
                for (var i = 0, len = verts.length; i < len; i++) {
                    alignedPosition = alignedPosition.set(verts[i].x, verts[i].y).multiply2(tempScale.x, tempScale.y);
                    rotatedPosition.x = Math.cos(rotation) * alignedPosition.x - Math.sin(rotation) * alignedPosition.y;
                    rotatedPosition.y = Math.sin(rotation) * alignedPosition.x + Math.cos(rotation) * alignedPosition.y;
                    finalPosition = finalPosition.set(0.0, 0.0, 0.0).applyMatrix4(sprite._modelViewMatrix);
                    finalPosition.x += rotatedPosition.x;
                    finalPosition.y += rotatedPosition.y;
                    if (!transformedVerts[i])
                        transformedVerts[i] = new Trike.Vec3();
                    transformedVerts[i].set(finalPosition.x, finalPosition.y, finalPosition.z).applyProjection(camera.projectionMatrix);
                    // At the moment the vert position is in normalized screen space coordinates - facing the camera
                    // Now lets unproject those normalized coords back into the world so we can pick against the rotated new values
                    transformedVerts[i] = projector.unprojectVector(transformedVerts[i], camera);
                }
                // Two faces in a quad
                for (var i = 0; i < 2; i++) {
                    var face = geometry.faces[i];
                    var intersectionPoint_1 = ray.intersectTriangle(transformedVerts[face.a], transformedVerts[face.b], transformedVerts[face.c], true);
                    if (!intersectionPoint_1)
                        continue;
                    var distance = ray.origin.distanceTo(intersectionPoint_1);
                    if (distance < precision || distance < this.near || distance > this.far)
                        continue;
                    intersects.push(new Intersection(distance, intersectionPoint_1, face, sprite));
                }
            }
            else if (object instanceof Trike.Terrain) {
                var terrain = object;
                var intersection = terrain.picker().intersectRay(ray);
                if (intersection)
                    intersects.push(intersection);
            }
            else if (object instanceof Trike.Mesh) {
                var mesh = object;
                if (!mesh.pickable)
                    return;
                if (!mesh.geometry || !mesh.material)
                    return;
                var geometry = mesh.geometry;
                var mat = mesh.material;
                if (!geometry && !mat)
                    return intersects;
                sphere.copy(geometry.boundingSphere);
                sphere.applyMatrix4(object.worldMatrix);
                if (ray.isIntersectionSphere(sphere) === false)
                    return intersects;
                // The reason we get the inverse is ray is because the alternative would be
                // the multiply every single vertex by the world matrix. Instead of doing that
                // we take the ray and multiply it by the inverse world matrix so that its in the object's
                // coordinate system and we dont have to multiply each vert.
                inverseMatrix.getInverse(object.worldMatrix);
                localRay.copy(ray).applyMatrix4(inverseMatrix);
                // Test line geometry using segment tests
                if (geometry instanceof Trike.GeometryLine) {
                    var geomLines = geometry;
                    var verts = geometry.buffers[Trike.AttributeType.POSITION].data;
                    var interSegment = new Trike.Vec3();
                    var interRay = new Trike.Vec3();
                    var step = (geomLines.lineMode === Trike.LineMode.HeadToTail || geomLines.lineMode === Trike.LineMode.HeadToTailClosed ? 1 : 2);
                    for (var i = 0, len = verts.length - 1; i < len; i = i + step) {
                        var distSq = localRay.distanceSqToSegment(verts[i], verts[i + 1], interRay, interSegment);
                        if (distSq > linePrecision)
                            continue;
                        var distance = localRay.origin.distanceTo(interRay);
                        if (distance < this.near || distance > this.far)
                            continue;
                        intersects.push(new Intersection(distance, 
                        // What do we want? intersection point on the ray or on the segment??
                        // point: raycaster.ray.at( distance ),
                        interSegment.clone().applyMatrix4(object.worldMatrix), null, object));
                    }
                }
                else if (object instanceof Trike.PointCloud) {
                    // Test the bounding box
                    if (localRay.isIntersectionBox(geometry.boundingBox) === false)
                        return intersects;
                    var cloud = mesh;
                    var verts = geometry.buffers[Trike.AttributeType.POSITION].data;
                    var sizes = (object.particleSizesEnabled ? geometry.buffers[Trike.AttributeType.SCALE].data : null);
                    var scale = cloud.particleScale * 0.4; // The 0.4 is a rough estimate
                    for (var i = 0, l = verts.length; i < l; i++) {
                        var distanceToPoint = localRay.distanceToPoint(verts[i]);
                        if (distanceToPoint < scale * (sizes ? sizes[i] : 1)) {
                            intersectionPoint = localRay.closestPointToPoint(verts[i]);
                            intersectionPoint.applyMatrix4(mesh.worldMatrix);
                            var distance = ray.origin.distanceTo(intersectionPoint);
                            intersects.push(new Intersection(distance, intersectionPoint, null, object));
                        }
                    }
                }
                else {
                    // Test the bounding box
                    if (localRay.isIntersectionBox(geometry.boundingBox) === false)
                        return intersects;
                    // Get all the vertices of the mesh
                    var triangles = RayCaster._trianglePool;
                    var verts = geometry.buffers[Trike.AttributeType.POSITION].data;
                    // If we are using faces then we store the verts by index as well as the face.
                    // If not, we simply use the verts stored in the buffer.
                    var numTriangles = 0;
                    if (geometry.faces && geometry.faces.length > 0) {
                        numTriangles = geometry.faces.length;
                        for (var i = 0, len = geometry.faces.length; i < len; i++) {
                            if (triangles.length < len)
                                triangles.push(new Triangle(verts[geometry.faces[i].a], verts[geometry.faces[i].b], verts[geometry.faces[i].c], geometry.faces[i]));
                            else {
                                triangles[i].a = verts[geometry.faces[i].a];
                                triangles[i].b = verts[geometry.faces[i].b];
                                triangles[i].c = verts[geometry.faces[i].c];
                                triangles[i].face = geometry.faces[i];
                            }
                        }
                    }
                    else {
                        numTriangles = verts.length / 3;
                        var tCount = 0;
                        for (var i = 0, len = verts.length; i < len; i += 3) {
                            if (i + 2 >= len)
                                continue;
                            if (triangles.length < len)
                                triangles.push(new Triangle(verts[i], verts[i + 1], verts[i + 2], null));
                            else {
                                triangles[tCount].a = verts[i];
                                triangles[tCount].b = verts[i + 1];
                                triangles[tCount].c = verts[i + 2];
                                triangles[tCount].face = null;
                            }
                            tCount++;
                        }
                    }
                    // Check if its back facing or not
                    var backFacing = true;
                    if (mat && mat.cullMode !== Trike.CullFormat.Back)
                        backFacing = false;
                    // Go through each triangle stored in the array and check
                    // if it intersects with the ray.
                    for (var i = 0; i < numTriangles; i++) {
                        var t = triangles[i];
                        intersectionPoint = localRay.intersectTriangle(t.a, t.b, t.c, backFacing);
                        if (!intersectionPoint)
                            continue;
                        intersectionPoint.applyMatrix4(mesh.worldMatrix);
                        var distance = ray.origin.distanceTo(intersectionPoint);
                        if (distance < precision || distance < this.near || distance > this.far)
                            continue;
                        intersects.push(new Intersection(distance, intersectionPoint, t.face, object));
                    }
                }
            }
            if (numIntersects !== intersects.length)
                intersects.sort(this.descSort);
        };
        /**
        * Gets an array of possible intersections of this ray caster and the object and its children
        */
        RayCaster.prototype.intersectDescendants = function (object, intersects, camera) {
            var descendants = object.getAllChildren();
            for (var i = 0, l = descendants.length; i < l; i++)
                this.intersectObject(descendants[i], intersects, camera);
        };
        /**
        * Sets the origin and direction of this caster. Direction is assumed to be normalized (for accurate distance calculations)
        */
        RayCaster.prototype.set = function (origin, direction) {
            this.ray.set(origin, direction);
            return this;
        };
        /**
        * Gets an array of possible intersections of this ray caster and the objects provided in objects
        */
        RayCaster.prototype.intersectObjects = function (objects, camera, recursive) {
            if (recursive === void 0) { recursive = true; }
            var intersects = new Array();
            for (var i = 0, l = objects.length; i < l; i++) {
                this.intersectObject(objects[i], intersects, camera);
                if (recursive === true)
                    this.intersectDescendants(objects[i], intersects, camera);
            }
            intersects.sort(this.descSort);
            return intersects;
        };
        /**
        * Cleans up the ray caster
        */
        RayCaster.prototype.dispose = function () {
            this.ray = null;
            this._sphere = null;
            this._localRay = null;
            this._matrixPosition = null;
            this._inverseMatrix = null;
            this._tempPos = null;
            this._tempScale = null;
            this._alignedPosition = null;
            this._rotatedPosition = null;
            this._finalPosition = null;
            this._transformedVerts = null;
            this._projector = null;
            RayCaster._numCasters--;
            if (RayCaster._numCasters === 0) {
                var pool = RayCaster._trianglePool;
                for (var i = 0, len = pool.length; i < len; i++) {
                    pool[i].a = null;
                    pool[i].b = null;
                    pool[i].c = null;
                    pool[i].face = null;
                }
                RayCaster._trianglePool = null;
            }
        };
        RayCaster._precision = 0.0001;
        RayCaster._linePrecision = 0.1;
        RayCaster._numCasters = 0;
        return RayCaster;
    }());
    Trike.RayCaster = RayCaster;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A helper class used to project 3D points to screen 2D coordinates and viceversa
    */
    var Projector = (function () {
        function Projector() {
            this._viewProjectionMatrix = new Trike.Matrix4();
            this._projectionMatrixInverse = new Trike.Matrix4();
        }
        /**
        * Projects a 3D world coordinate to screen coordinates
        */
        Projector.prototype.projectVector = function (vector, camera) {
            camera.matrixWorldInverse.getInverse(camera.worldMatrix);
            this._viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
            return vector.applyProjection(this._viewProjectionMatrix);
        };
        /**
        * Projects a normalized 2D screen coordinate to 3D. The x and y correspond to the screen coordinates, and the z (i think) is the depth in the scene.
        * Use a z value of 1 to project to the back of the camera frustum.
        */
        Projector.prototype.unprojectVector = function (vector, camera) {
            this._projectionMatrixInverse.getInverse(camera.projectionMatrix);
            this._viewProjectionMatrix.multiplyMatrices(camera.worldMatrix, this._projectionMatrixInverse);
            return vector.applyProjection(this._viewProjectionMatrix);
        };
        /**
        * Projects a normalized 2D screen coordinate to 3D. This creates a RayCaster, or can optionally be provided with one,
        * which can be used to pick 3d objects.
        */
        Projector.prototype.pickingRay = function (vector, camera, optionalRayCastor) {
            // set two vectors with opposing z values
            vector.z = -1.0;
            var end = new Trike.Vec3(vector.x, vector.y, 1.0);
            this.unprojectVector(vector, camera);
            this.unprojectVector(end, camera);
            // find direction from vector to end
            end.sub(vector).normalize();
            if (optionalRayCastor)
                return optionalRayCastor.set(vector, end);
            else
                return new Trike.RayCaster(vector, end);
        };
        return Projector;
    }());
    Trike.Projector = Projector;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /*
    * This class is used to convolve a cube texture. This is commonly irradience mapping. We
    * are essentially drawing a cube texture into a separate cubeTexture that contains the luminous
    * values of each fragment thats been convolved.
    * See for more:
    * http://codeflow.org/entries/2011/apr/18/advanced-webgl-part-3-irradiance-environment-map/
    */
    var CubeConvolver = (function (_super) {
        __extends(CubeConvolver, _super);
        function CubeConvolver(textureType, textureFormat) {
            if (textureType === void 0) { textureType = Trike.TextureType.UnsignedByteType; }
            if (textureFormat === void 0) { textureFormat = Trike.TextureFormat.RGBAFormat; }
            _super.call(this);
            this.redrawRequired = true;
            this.continuousRedraw = false;
            this._downsampler = new Trike.CubeRenderer(16, 16, textureType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Linear, Trike.TextureFilter.Linear, textureFormat);
            this._convolution = new Trike.CubeRenderer(16, 16, textureType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Linear, Trike.TextureFilter.Linear, textureFormat);
            this._downsampler.cubeTarget.generateMipmaps = false;
            this._convolution.cubeTarget.generateMipmaps = false;
            this._invRotMat = new Trike.Matrix4();
            this._downsamplerMat = new Trike.MaterialCubeDownsample();
            this._convolutionMat = new Trike.MaterialConvolver();
            this._gaussainMat = new Trike.MaterialGaussian();
            this._pass = new Trike.RenderPass(null, null, Trike.PassType.ScreenQuad);
            this._specularity = 1;
            this._contrast = 1;
        }
        /*
        * Gets or sets the source cube texture we want to convolve
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        CubeConvolver.prototype.source = function (val) {
            if (val === undefined)
                return this._source;
            this._source = val;
            this.redrawRequired = true;
            return val;
        };
        /*
        * Gets the convolved cube texture
        * @param {RenderTargetCube}
        */
        CubeConvolver.prototype.cubeTexture = function () {
            return this._convolution.cubeTarget;
        };
        /*
        * Use this function to perform any pre-renders. Useful if an object needs to do its own render pass before a
        * the render call begins.
        * @param {Scene} scene The scene  being rendered
        * @param {Camera} camera The camera beinf used to render the scene
        * @param {RenderTarget} renderTarget The render target the scene is being drawn to
        * @param {Renderer} renderer The renderer being used to draw the scene
        * @param {boolean} Returns false if an error occurred
        */
        CubeConvolver.prototype.prepRender = function (scene, camera, renderTarget, renderer) {
            var source = this._source;
            // If no sky then do nothing
            if (!source)
                return true;
            if (!this.redrawRequired && this.continuousRedraw === false)
                return true;
            this.redrawRequired = false;
            // Setup the depth / stencil clears
            var clearDepth = renderer.autoClearDepth, clearStencil = renderer.autoClearStencil, pass = this._pass, invRotMat = this._invRotMat, downSampleMat = this._downsamplerMat, convolveMat = this._convolutionMat, downsampler = this._downsampler, convolver = this._convolution, contrast = this._contrast, specularity = this._specularity;
            var c;
            renderer.autoClearDepth = true;
            renderer.autoClearStencil = true;
            // We first have to down sample the skybox texture. We do this because  the convolution process
            // is very expensive and this needs to be very small
            pass.material = downSampleMat;
            pass.renderTarget = downsampler.cubeTarget;
            for (var i = 0; i < 6; i++) {
                c = downsampler.activateCamera(i);
                invRotMat.extractRotation(c.worldMatrix);
                downSampleMat.setUniform('invViewRot', invRotMat, true);
                downSampleMat.setUniform('invProjMatrix', c.projectionInverseMatrix, true);
                downSampleMat.setUniform('sampler', source, true);
                if (!renderer.renderObjects(renderer.ssq.meshes, renderer.ssq.camera, pass))
                    return false;
            }
            // Now we convolve the down sampled textures. Convolution in this sense means we get the sum
            // of each of the env map pixels with respect to eachother.
            pass.material = convolveMat;
            pass.renderTarget = convolver.cubeTarget;
            for (var i = 0; i < 6; i++) {
                c = convolver.activateCamera(i);
                invRotMat.extractRotation(c.worldMatrix);
                convolveMat.setUniform('invViewRot', invRotMat, true);
                convolveMat.setUniform('invProjMatrix', c.projectionInverseMatrix, true);
                convolveMat.setUniform('specularity', specularity, true);
                convolveMat.setUniform('sampler', downsampler.cubeTarget, true);
                if (!renderer.renderObjects(renderer.ssq.meshes, renderer.ssq.camera, pass))
                    return false;
            }
            // Revert the clear values
            renderer.autoClearDepth = clearDepth;
            renderer.autoClearStencil = clearStencil;
            return true;
        };
        /*
        * Get or set the contrast of the convolution
        * @param {number} [Optional]
        * @returns {number}
        */
        CubeConvolver.prototype.contrast = function (val) {
            if (val === undefined)
                return this._contrast;
            this._contrast = val;
            this.redrawRequired = true;
            return val;
        };
        /*
        * Get or set the specularity of the convolution
        * @param {number} [Optional]
        * @returns {number}
        */
        CubeConvolver.prototype.specularity = function (val) {
            if (val === undefined)
                return this._specularity;
            this._specularity = val;
            this.redrawRequired = true;
            return val;
        };
        /*
        * Cleans up the class
        */
        CubeConvolver.prototype.dispose = function () {
            this._downsampler.dispose();
            this._convolution.dispose();
            this._downsamplerMat.dispose();
            this._convolutionMat.dispose();
            this._pass.dispose();
            this._invRotMat = null;
            this._downsampler = null;
            this._convolution = null;
            this._downsamplerMat = null;
            this._convolutionMat = null;
            this._pass = null;
        };
        return CubeConvolver;
    }(Trike.Object3D));
    Trike.CubeConvolver = CubeConvolver;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /*
    * A specialized convolver that uses the sky cube texture as its source
    */
    var SkyboxConvolver = (function (_super) {
        __extends(SkyboxConvolver, _super);
        function SkyboxConvolver() {
            _super.call(this);
            this._renderCount = 0;
        }
        /*
        * Gets or sets the skybox we are convolving
        * @param {SkyboxSimple|SkyboxAtmospheric} val [Optional]
        * @returns {SkyboxSimple|SkyboxAtmospheric}
        */
        SkyboxConvolver.prototype.skybox = function (val) {
            if (val === undefined)
                return this._sky;
            this._sky = val;
            if (val instanceof Trike.RenderTargetCube)
                this.continuousRedraw = true;
            else
                this.continuousRedraw = false;
            if (val)
                this.source(val.skyTexture());
            else
                this.source(null);
            this.redrawRequired = true;
            return val;
        };
        /*
        * Use this function to perform any pre-renders. Useful if an object needs to do its own render pass before a
        * the render call begins.
        * @param {Scene} scene The scene  being rendered
        * @param {Camera} camera The camera beinf used to render the scene
        * @param {RenderTarget} renderTarget The render target the scene is being drawn to
        * @param {Renderer} renderer The renderer being used to draw the scene
        * @param {boolean} Returns false if an error occurred
        */
        SkyboxConvolver.prototype.prepRender = function (scene, camera, renderTarget, renderer) {
            if (!this._sky)
                return true;
            // If the skybox render count does not match ours, then its been updated
            // and we have to update our variance shading maps
            if (this._sky.renderCount !== this._renderCount)
                this.redrawRequired = true;
            this._renderCount = this._sky.renderCount;
            _super.prototype.prepRender.call(this, scene, camera, renderTarget, renderer);
            return true;
        };
        /*
        * Get or set the specularity of the convolution
        * @param {number} [Optional]
        * @returns {number}
        */
        SkyboxConvolver.prototype.specularity = function (val) {
            if (val === undefined)
                return _super.prototype.specularity.call(this);
            this._renderCount = -1; // Causes a redraw
            return _super.prototype.specularity.call(this, val);
        };
        /*
        * Cleans up the class
        */
        SkyboxConvolver.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._sky = null;
        };
        return SkyboxConvolver;
    }(Trike.CubeConvolver));
    Trike.SkyboxConvolver = SkyboxConvolver;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * The base class for all render passes.
    */
    var RenderPass = (function () {
        /**
        * Creates an instance of the RenderPass
        * @param {MaterialMulti} material The overriding material to use when using this pass. This is optional and the default is null.
        * @param {RenderTarget} renderTarget The render target we are drawing to. Null will draw to the screen.
        * @param {number} passType The numerical ID of this pass. The default is PassType.Colors
        */
        function RenderPass(material, renderTarget, passType) {
            this.renderTarget = renderTarget;
            this.material = material;
            this.camera = null;
            this.passType = passType;
            this.reflectionPass = false;
            this.disposed = false;
            this.reflectionClipPlane = new Trike.Vec4();
        }
        /**
        * Resizes the render target, if present, in this pass
        * @param {number} width The width of the render target
        * @param {height} width The height of the render target
        */
        RenderPass.prototype.resize = function (width, height) {
            if (this.renderTarget)
                this.renderTarget.resize(width, height);
        };
        /**
        * Called just before a mesh is drawn
        * @param {Camera} mesh The Mesh we are about to draw
        * @return {boolean}
        */
        RenderPass.prototype.evaluateMesh = function (mesh) {
            var material = this.material;
            var meshMat = mesh.material;
            if (material && meshMat)
                this.material.wireframe = meshMat.wireframe;
            if (meshMat) {
                if (this.reflectionPass) {
                    if (meshMat._uniforms['flipUV'])
                        meshMat.setUniform('flipUV', 1, true);
                    if (meshMat._uniforms['customClipping']) {
                        meshMat.setUniform('customClipping', 1.0, true);
                        meshMat.setUniform('customClipPlane', this.reflectionClipPlane, true);
                    }
                }
                else {
                    if (meshMat._uniforms['flipUV'])
                        meshMat.setUniform('flipUV', 0, true);
                    if (meshMat._uniforms['customClipping'])
                        meshMat.setUniform('customClipping', 0.0, true);
                }
            }
            return true;
        };
        /**
        * Cleans up the variables
        */
        RenderPass.prototype.dispose = function () {
            if (this.renderTarget)
                this.renderTarget.dispose();
            if (this.material)
                this.material.dispose();
            this.renderTarget = null;
            this.material = null;
            this.camera = null;
            this.disposed = true;
        };
        return RenderPass;
    }());
    Trike.RenderPass = RenderPass;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * This pass is responsible for drawing material properties
    * x: diffuse, diffuse, diffuse
    * y: specular, specular, specular
    * z: translucency color, translucency color, translucency color
    * w: emissive, emissive, emissive
    */
    var GBufferPass = (function (_super) {
        __extends(GBufferPass, _super);
        /**
        * Creates an instance of the pass
        * @param {number} width The width of the render target
        * @param {height} width The height of the render target
        */
        function GBufferPass(width, height) {
            _super.call(this, null, new Trike.RenderTarget(width, height, Trike.TextureType.FloatType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Nearest, Trike.TextureFilter.Nearest, Trike.TextureFormat.RGBAFormat, 1, true, true), Trike.PassType.GBuffer);
        }
        return GBufferPass;
    }(Trike.RenderPass));
    Trike.GBufferPass = GBufferPass;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * This pass is responsible for drawing each of the lights in the scene
    */
    var LightPass = (function (_super) {
        __extends(LightPass, _super);
        /**
        * Creates an instance of the pass
        * @param {number} width The width of the render target
        * @param {height} width The height of the render target
        * @param {boolean} transparencyPass True if this pass deals with transparent objects
        */
        function LightPass(width, height, transparencyPass) {
            if (!transparencyPass)
                _super.call(this, null, new Trike.RenderTarget(width, height, Trike.TextureType.HalfFloatType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Nearest, Trike.TextureFilter.Nearest, Trike.TextureFormat.RGBFormat, 1, true, true), Trike.PassType.Lights);
            else
                _super.call(this, null, new Trike.RenderTarget(width, height, Trike.TextureType.HalfFloatType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Nearest, Trike.TextureFilter.Nearest, Trike.TextureFormat.RGBAFormat, 1, true, true), Trike.PassType.Lights);
            this._v1 = new Trike.Vec3();
            this._mat = new Trike.Matrix4();
            this._combined = new Trike.Vec4();
            this.transparencyPass = transparencyPass;
        }
        LightPass.prototype.resize = function (width, height) {
            _super.prototype.resize.call(this, width, height);
        };
        /**
        * Called just before a mesh is drawn
        * @param {Camera} mesh The Mesh we are about to draw
        */
        LightPass.prototype.evaluateMesh = function (mesh) {
            var lightMat = mesh.material.materials[Trike.PassType.Lights];
            if (!this.transparencyPass) {
                if (mesh instanceof Trike.LightPoint === false)
                    lightMat.setUniform('limitScreenQuad', 0);
                return true;
            }
            var drawSpecificMesh = this.drawSpecificMesh;
            // Optimize the mesh - p light drawing by checking if they even intersect
            if (mesh instanceof Trike.LightPoint)
                return;
            // We have a specific mesh to draw (not a whole scene). To optimize the drawing
            // of this object, we need to limit screen quad so that it only draws the region
            // where the targeted mesh is in screen space. We do this by getting the min and max
            // points of the target mesh's boundaries and tranforming them to screen space positions
            // x:(-1 (left) to 1 (right) ), y: (-1 (top) to 1 (bottom))
            if (lightMat) {
                if (drawSpecificMesh) {
                    var combined = this._combined, mat = this._mat, radius = drawSpecificMesh._worldSphere.radius, sphereCenter = this._v1, camWorldPos = this._v1;
                    var cam = this.camera;
                    camWorldPos.getPositionFromMatrix(cam.worldMatrix);
                    var d = camWorldPos.distanceTo(drawSpecificMesh._worldSphere.center);
                    var fov = cam.fov / 2 * Math.PI / 180.0;
                    var screenSpaceRadius = 1.0 / Math.tan(fov) * radius / Math.sqrt(Math.abs(d * d - radius * radius));
                    screenSpaceRadius += screenSpaceRadius * 0.25;
                    if (screenSpaceRadius < 1) {
                        // Get the projection matrix of the object
                        mat.multiplyMatrices(cam.projectionMatrix, mat.getInverse(cam.worldMatrix));
                        // Get center in screen space
                        sphereCenter.copy(drawSpecificMesh._worldSphere.center);
                        sphereCenter.project(cam, false);
                        combined.set(sphereCenter.x - screenSpaceRadius, sphereCenter.y - screenSpaceRadius, sphereCenter.x + screenSpaceRadius, sphereCenter.y + screenSpaceRadius);
                        lightMat.setUniform('limitScreenQuad', 1);
                        lightMat.setUniform('minMax', combined);
                    }
                    else
                        lightMat.setUniform('limitScreenQuad', 0);
                }
            }
            return true;
        };
        return LightPass;
    }(Trike.RenderPass));
    Trike.LightPass = LightPass;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * This pass is responsible for drawing more material properties
    * x: normal, normal, normal
    * y: albedo, albedo, albedo
    * z: Depth, Opacity, shininess
    * w: translucency distortion, translucency scale, translucency power
    */
    var GBuffer2Pass = (function (_super) {
        __extends(GBuffer2Pass, _super);
        /**
        * Creates an instance of the pass
        * @param {number} width The width of the render target
        * @param {height} width The height of the render target
        */
        function GBuffer2Pass(width, height) {
            _super.call(this, null, new Trike.RenderTarget(width, height, Trike.TextureType.FloatType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Nearest, Trike.TextureFilter.Nearest, Trike.TextureFormat.RGBAFormat, 1, true, true), Trike.PassType.GBuffer2);
        }
        return GBuffer2Pass;
    }(Trike.RenderPass));
    Trike.GBuffer2Pass = GBuffer2Pass;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * This pass is responsible for drawing the skyboxes of a scene
    */
    var SkyPass = (function (_super) {
        __extends(SkyPass, _super);
        /**
        * Creates an instance of the SkyPass
        * @param {RenderTarget} renderTarget The render target we are drawing to. Null will draw to the screen.
        */
        function SkyPass(renderTarget) {
            _super.call(this, null, renderTarget, Trike.PassType.Skybox);
        }
        return SkyPass;
    }(Trike.RenderPass));
    Trike.SkyPass = SkyPass;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * This pass is responsible for simply drawing a render target to the screen
    */
    var ScreenPass = (function (_super) {
        __extends(ScreenPass, _super);
        /**
        * Creates an instance of the FinalPass
        * @param {RenderTarget} renderTarget The render target we are drawing to. Null will draw to the screen.
        */
        function ScreenPass(renderTarget) {
            var solidMaterial = new Trike.MaterialScreenTexture();
            var transparentMaterial = new Trike.MaterialScreenTexture(true);
            transparentMaterial.blendMode = Trike.BlendMode.PremultipliedAlpha;
            _super.call(this, solidMaterial, renderTarget, Trike.PassType.ScreenQuad);
            this.solidMaterial = solidMaterial;
            this.transparentMaterial = transparentMaterial;
        }
        Object.defineProperty(ScreenPass.prototype, "map", {
            set: function (val) {
                var defMat = this.material;
                defMat.setUniform('map', val, false);
            },
            enumerable: true,
            configurable: true
        });
        return ScreenPass;
    }(Trike.RenderPass));
    Trike.ScreenPass = ScreenPass;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * This pass is responsible for drawing any color information that needs to be applied to the final
    * pass. Its only created if in editor mode.
    */
    var EditorPass = (function (_super) {
        __extends(EditorPass, _super);
        /**
        * Creates an instance of the pass
        * @param {number} width The width of the render target
        * @param {height} width The height of the render target
        */
        function EditorPass(width, height) {
            _super.call(this, null, new Trike.RenderTarget(width, height, Trike.TextureType.UnsignedByteType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Nearest, Trike.TextureFilter.Nearest, Trike.TextureFormat.RGBAFormat, 1, true, true), Trike.PassType.EditorPass);
        }
        return EditorPass;
    }(Trike.RenderPass));
    Trike.EditorPass = EditorPass;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    (function (Phase) {
        Phase[Phase["Composition"] = 0] = "Composition";
        Phase[Phase["PostCompostion"] = 1] = "PostCompostion";
        Phase[Phase["LightingSolid"] = 2] = "LightingSolid";
    })(Trike.Phase || (Trike.Phase = {}));
    var Phase = Trike.Phase;
    (function (FilterType) {
        FilterType[FilterType["Solids"] = 0] = "Solids";
        FilterType[FilterType["Transparents"] = 1] = "Transparents";
        FilterType[FilterType["Lights"] = 2] = "Lights";
        FilterType[FilterType["Skyboxes"] = 3] = "Skyboxes";
        FilterType[FilterType["ScreenQuad"] = 4] = "ScreenQuad";
    })(Trike.FilterType || (Trike.FilterType = {}));
    var FilterType = Trike.FilterType;
    /**
    * Each render call is optionall made up of several composition passes. These can be thought of as
    * post process effects, but can also be broader than that. They occur after the essential rendering
    * has taken place and are part of the camera. The composition passes should essentially put a scene together.
    */
    var CompositionPass = (function (_super) {
        __extends(CompositionPass, _super);
        /**
        * Creates an instance of the FinalPass
        * @param {string} name The unique name of the pass.
        * @param {RenderTarget} renderTarget The render target we are drawing to. Null will draw to the screen.
        * @param {MaterialMulti} material Each composition pass must be given a material with which to draw / compose a scene
        * @param {FilterType} filterType Describes which objects to draw
        * @param {Phase} phase Defines at what point the pass is drawn
        */
        function CompositionPass(name, renderTarget, material, filterType, phase) {
            _super.call(this, material, renderTarget, Trike.PassType.ScreenQuad);
            this.numSubPasses = 1;
            this.phase = phase;
            this.currentSubPass = 0;
            this.name = name;
            this.autoClearColor = true;
            this.autoClearDepth = true;
            this.autoClearStencil = true;
            this.enabled = true;
            this.filterType = FilterType.ScreenQuad;
            this.resizeId = 0;
        }
        /**
        * This is called just before the render function. Use it, to setup the composition pass before rendering
        * @param {RenderTarget} renderTarget The render target defined by the user
        * @param {Scene} scene The scene being drawn
        * @param {Camera} camera The camera used to draw the scene
        * @param {Renderer} renderer The renderer drawing the scene
        */
        CompositionPass.prototype.prepPass = function (renderTarget, scene, camera, renderer) {
        };
        return CompositionPass;
    }(Trike.RenderPass));
    Trike.CompositionPass = CompositionPass;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * The camera pass is the default composition attached to cameras. The material is a
    * MaterialCamEffects shader, which allows you to create fog and other camera effects
    * to the final composite before its sent to the frame buffer.
    */
    var CameraPass = (function (_super) {
        __extends(CameraPass, _super);
        /**
        * Creates an instance of the CameraPass
        */
        function CameraPass() {
            _super.call(this, 'Camera Pass', null, null, Trike.FilterType.ScreenQuad, Trike.Phase.Composition);
            this.camEffects = new Trike.MaterialCamEffects();
            this._copyMat = new Trike.MaterialScreenTexture(false);
            this._rotMatrix = new Trike.Matrix4();
            this.numSubPasses = 2;
            this._targets = {};
            this._curCamTarget = null;
        }
        CameraPass.prototype.getPassTarget = function (target) {
            if (!this._targets[target.id]) {
                this._targets[target.id] = new Trike.RenderTarget(target.width, target.height, Trike.TextureType.HalfFloatType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Nearest, Trike.TextureFilter.Nearest, Trike.TextureFormat.RGBFormat, 0, true, true);
                // Shares the same depth and stencil data from the Gbuffer
                this._targets[target.id].sharedRenderBuffer = target;
            }
            return this._targets[target.id];
        };
        /**
        * Resizes the render target, if present, in this pass
        * @param {number} width The width of the render target
        * @param {height} width The height of the render target
        */
        CameraPass.prototype.resize = function (width, height) {
            // Handled in the render function for the camera passes
            if (this._curCamTarget)
                this._curCamTarget.requiresBuild = true;
        };
        /**
        * Cleans up the pass for the GC
        */
        CameraPass.prototype.dispose = function () {
            if (this.disposed)
                return;
            for (var i in this._targets)
                this._targets[i].dispose();
            this._rotMatrix = null;
            this.camEffects.dispose();
            this._copyMat.dispose();
            this._targets = null;
            this.camEffects = null;
            this._copyMat = null;
            this._curCamTarget = null;
            _super.prototype.dispose.call(this);
        };
        /**
        * This is called just before the render function. Use it, to setup the composition pass before rendering
        * @param {RenderTarget} renderTarget The render target defined by the user
        * @param {Scene} scene The scene being drawn
        * @param {Camera} camera The camera used to draw the scene
        * @param {Renderer} renderer The renderer drawing the scene
        */
        CameraPass.prototype.prepPass = function (renderTarget, scene, camera, renderer) {
            if (this.currentSubPass === 0) {
                this.autoClearColor = true;
                this.autoClearStencil = false;
                this.autoClearDepth = false;
                var camEffects = this.camEffects;
                this.material = camEffects;
                // Set the composition target
                camEffects.setUniform('composition', renderTarget, true);
                if (camEffects.fogType() === Trike.FogType.HeightBased || camEffects.fogConvolver()) {
                    this._rotMatrix.extractRotation(camera.worldMatrix);
                    camEffects.setUniform('cameraWorldRotMat', this._rotMatrix, false);
                }
                // Get the current gbuffer
                var gBuffer = renderer.currentCollection.gBufferPass.renderTarget;
                // Get our render target for the current GBuffer - or create one if we dont have one already
                var camTarget = this.getPassTarget(gBuffer);
                // Make sure the sizes are the same
                if (gBuffer.width !== camTarget.width || gBuffer.height !== camTarget.height)
                    camTarget.resize(gBuffer.width, gBuffer.height);
                this.renderTarget = camTarget;
                this._curCamTarget = camTarget;
            }
            else {
                this.autoClearColor = false;
                this.autoClearStencil = false;
                this.autoClearDepth = false;
                this.renderTarget = renderTarget;
                this.material = this._copyMat;
                this._copyMat.map(this._curCamTarget);
            }
        };
        return CameraPass;
    }(Trike.CompositionPass));
    Trike.CameraPass = CameraPass;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * This pass is responsible for simply drawing a shader texture
    */
    var TexturePass = (function (_super) {
        __extends(TexturePass, _super);
        /**
        * Creates an instance of the TexturePass
        * @param {ShaderTexture} shaderTexture The texture to draw
        */
        function TexturePass() {
            _super.call(this, null, null, Trike.PassType.Texture);
        }
        TexturePass.prototype.resize = function (width, height) {
            // We do nothing. Not sure if we should do anything here...
        };
        return TexturePass;
    }(Trike.RenderPass));
    Trike.TexturePass = TexturePass;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Some multi materials have an array of material passes. These are drawn just before the render call
    * and are useful for drawing information
    */
    var MaterialPass = (function (_super) {
        __extends(MaterialPass, _super);
        /**
        * Creates an instance of the pass. By default a render target the same size as the viewport is created
        * and maintained. Optionally you can pass your own target.
        * @param {number} width The width of the render target
        * @param {height} width The height of the render target
        * @param {PassType} passType The type of pass
        * @param {RenderTarget} renderTarget Optionally you can pass your own render target
        */
        function MaterialPass(width, height, passType, renderTarget) {
            _super.call(this, null, renderTarget || new Trike.RenderTarget(width, height, Trike.TextureType.FloatType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Nearest, Trike.TextureFilter.Nearest, Trike.TextureFormat.RGBAFormat, 1, true, true), passType);
            this.resizeId = 0;
            this.enabled = true;
        }
        /**
        * Gets a new unique pass ID
        * @returns {number}
        */
        MaterialPass.getNewPassID = function () {
            MaterialPass._curPassID++;
            return MaterialPass._curPassID;
        };
        MaterialPass._curPassID = 100;
        return MaterialPass;
    }(Trike.RenderPass));
    Trike.MaterialPass = MaterialPass;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * This pass is responsible for drawing each of the lights shadow maps
    */
    var ShadowLightPass = (function (_super) {
        __extends(ShadowLightPass, _super);
        /**
        * Creates an instance of the pass
        */
        function ShadowLightPass(softnessPass) {
            if (softnessPass === void 0) { softnessPass = false; }
            _super.call(this, null, null, Trike.PassType.ShadowLightPass);
            this._shadowFilter = Trike.ShadowQuality.High;
            this.copyMaterial = new Trike.MaterialScreenTexture(false);
            this.blurMaterialX = new Trike.MaterialGaussian();
            this.blurMaterialY = new Trike.MaterialGaussian();
            this.blurMaterialY.setDirection(false);
            this.blurX = new Trike.RenderTarget(128, 128, Trike.TextureType.FloatType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Linear, Trike.TextureFilter.Linear, Trike.TextureFormat.RGBFormat, 0, false, false);
            this.blurY = new Trike.RenderTarget(128, 128, Trike.TextureType.FloatType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Linear, Trike.TextureFilter.Linear, Trike.TextureFormat.RGBFormat, 0, false, false);
        }
        /**
        * Called just before a mesh is drawn
        * @param {Camera} mesh The Mesh we are about to draw
        * @return {boolean}
        */
        ShadowLightPass.prototype.evaluateMesh = function (mesh) {
            if (!_super.prototype.evaluateMesh.call(this, mesh))
                return false;
            return true;
        };
        return ShadowLightPass;
    }(Trike.RenderPass));
    Trike.ShadowLightPass = ShadowLightPass;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Extracts the lightness from the scene, then applies a bloom filter on the lighter parts of it
    * See http://kalogirou.net/2006/05/20/how-to-do-good-bloom-for-hdr-rendering/ for more
    */
    var BloomPass = (function (_super) {
        __extends(BloomPass, _super);
        function BloomPass() {
            _super.call(this, 'Gaussian Pass', null, null, Trike.FilterType.ScreenQuad, Trike.Phase.PostCompostion);
            this._tempTarget1 = new Trike.RenderTarget(2, 2, Trike.TextureType.UnsignedByteType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Linear, Trike.TextureFilter.Linear, Trike.TextureFormat.RGBFormat, 0, false, false);
            this._tempTarget2 = new Trike.RenderTarget(2, 2, Trike.TextureType.UnsignedByteType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Linear, Trike.TextureFilter.Linear, Trike.TextureFormat.RGBFormat, 0, false, false);
            this._tempTarget3 = new Trike.RenderTarget(2, 2, Trike.TextureType.UnsignedByteType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Linear, Trike.TextureFilter.Linear, Trike.TextureFormat.RGBFormat, 0, false, false);
            this.hdr = new Trike.MaterialExtractLight();
            this.blurHorizontal = new Trike.MaterialGaussian();
            this.blurVertical = new Trike.MaterialGaussian();
            this.copy = new Trike.MaterialScreenTexture(false);
            // this.blurHorizontal.blendMode = BlendMode.Additive;
            // this.blurVertical.blendMode = BlendMode.Additive;
            this.copy.blendMode = Trike.BlendMode.Additive;
            this.blurHorizontal.setDirection(true);
            this.blurVertical.setDirection(false);
            this.autoClearStencil = false;
            this.autoClearDepth = false;
            this.numSubPasses = 4;
        }
        /**
        * Resizes the render target, if present, in this pass
        * @param {number} width The width of the render target
        * @param {height} width The height of the render target
        */
        BloomPass.prototype.resize = function (width, height) {
            this._tempTarget1.resize(width / 2, height / 2);
            this._tempTarget2.resize(width / 4, height / 4);
            this._tempTarget3.resize(width / 4, height / 4);
        };
        /**
        * This is called just before the render function. Use it, to setup the composition pass before rendering
        * @param {RenderTarget} renderTarget The render target defined by the user
        * @param {Scene} scene The scene being drawn
        * @param {Camera} camera The camera used to draw the scene
        * @param {Renderer} renderer The renderer drawing the scene
        */
        BloomPass.prototype.prepPass = function (renderTarget, scene, camera, renderer) {
            if (this.currentSubPass === 0) {
                this.autoClearColor = true;
                this.material = this.hdr;
                this.hdr.map(renderTarget);
                this.renderTarget = this._tempTarget1;
            }
            else if (this.currentSubPass === 1) {
                this.material = this.blurHorizontal;
                this.blurHorizontal.map(this._tempTarget1);
                this.renderTarget = this._tempTarget2;
            }
            else if (this.currentSubPass === 2) {
                this.material = this.blurVertical;
                this.blurVertical.map(this._tempTarget2);
                this.renderTarget = this._tempTarget3;
            }
            else if (this.currentSubPass === 3) {
                this.autoClearColor = false;
                this.material = this.copy;
                this.copy.map(this._tempTarget3);
                this.renderTarget = renderTarget;
            }
        };
        return BloomPass;
    }(Trike.CompositionPass));
    Trike.BloomPass = BloomPass;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * This pass copies the scene from the composition target to the final destination
    * which is either the frame buffer or another render target.
    */
    var FramePass = (function (_super) {
        __extends(FramePass, _super);
        /**
        * Creates an instance of the FramePass
        */
        function FramePass(compositionTarget) {
            _super.call(this, new Trike.MaterialScreenTexture(false), null, Trike.FilterType.ScreenQuad);
            this.compositionTarget = compositionTarget;
        }
        /**
        * This is called just before the render function. Use it, to setup the composition pass before rendering
        * @param {RenderTarget} renderTarget The render target defined by the user
        * @param {Scene} scene The scene being drawn
        * @param {Camera} camera The camera used to draw the scene
        * @param {Renderer} renderer The renderer drawing the scene
        */
        FramePass.prototype.prepPass = function (renderTarget, scene, camera, renderer) {
            var material = this.material;
            material.map(this.compositionTarget);
            this.renderTarget = renderTarget;
        };
        return FramePass;
    }(Trike.RenderPass));
    Trike.FramePass = FramePass;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    (function (AOType) {
        AOType[AOType["SSAO"] = 0] = "SSAO";
        AOType[AOType["HBSA"] = 1] = "HBSA";
    })(Trike.AOType || (Trike.AOType = {}));
    var AOType = Trike.AOType;
    /**
    * Performs the passes to draw an ambient occulusion shadow on the scene
    */
    var AOPass = (function (_super) {
        __extends(AOPass, _super);
        function AOPass() {
            _super.call(this, 'AO Pass', null, null, Trike.FilterType.ScreenQuad, Trike.Phase.LightingSolid);
            this._noiseTexture = this.generateNoiseTexture(4, 4);
            this._tempTarget1 = new Trike.RenderTarget(2, 2, Trike.TextureType.UnsignedByteType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Linear, Trike.TextureFilter.Linear, Trike.TextureFormat.RGBFormat, 0, false, false);
            this._tempTarget2 = new Trike.RenderTarget(2, 2, Trike.TextureType.UnsignedByteType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Linear, Trike.TextureFilter.Linear, Trike.TextureFormat.RGBFormat, 0, false, false);
            this._tempTarget3 = new Trike.RenderTarget(2, 2, Trike.TextureType.UnsignedByteType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Linear, Trike.TextureFilter.Linear, Trike.TextureFormat.RGBFormat, 0, false, false);
            this.materialSSAO = new Trike.MaterialAO();
            this.materialHBAO = new Trike.MaterialHBAO();
            this.materialSSAO.setUniform('noiseSampler', this._noiseTexture, true);
            this.materialHBAO.setUniform('noiseSampler', this._noiseTexture, true);
            this.blurHorizontal = new Trike.MaterialGaussian();
            this.blurVertical = new Trike.MaterialGaussian();
            this.blurHorizontal.crossBilateralFilter(true);
            this.blurVertical.crossBilateralFilter(true);
            this.blurHorizontal.setDirection(true);
            this.blurVertical.setDirection(false);
            this.copy = new Trike.MaterialScreenTexture(false);
            this.copy.blendMode = Trike.BlendMode.Multiplication;
            this._hbaoScale = 0.5;
            this._aoScale = 0.5;
            this.currentAO = this.materialSSAO;
            this.autoClearStencil = false;
            this.autoClearDepth = false;
            this.numSubPasses = 4;
            this._blurPass = true;
            this.noiseScale(1);
        }
        /**
        * Gets or sets the type of AO material to use
        * @param {AOType} val [Optional]
        * @returns {AOType}
        */
        AOPass.prototype.type = function (val) {
            if (val === undefined)
                return (this.currentAO instanceof Trike.MaterialAO ? AOType.SSAO : AOType.HBSA);
            if (val === AOType.SSAO) {
                this.currentAO = this.materialSSAO;
                this._tempTarget1.resize(this._w * this._aoScale, this._h * this._aoScale);
            }
            else {
                this.currentAO = this.materialHBAO;
                this._tempTarget1.resize(this._w * this._hbaoScale, this._h * this._hbaoScale);
                this.currentAO.setUniform('noiseScale', new Trike.Vec2(this._w * this._hbaoScale / 4, this._h * this._hbaoScale / 4), true);
            }
            return val;
        };
        /**
        * Gets or sets if the AO should blur the result before sending it to the screen
        * @param {boolean} val [Optional]
        * @returns {boolean}
        */
        AOPass.prototype.blurPass = function (val) {
            if (val === undefined)
                return this._blurPass;
            this._blurPass = val;
            return val;
        };
        /**
        * Resizes the render target, if present, in this pass
        * @param {number} width The width of the render target
        * @param {height} width The height of the render target
        */
        AOPass.prototype.resize = function (width, height) {
            this._w = width;
            this._h = height;
            this.materialSSAO.setUniform('texelSize', new Trike.Vec2(1 / width, 1 / height), true);
            if (this.currentAO === this.materialHBAO)
                this._tempTarget1.resize(width * this._hbaoScale, height * this._hbaoScale);
            else
                this._tempTarget1.resize(width * this._aoScale, height * this._aoScale);
            this._tempTarget2.resize(width, height);
            this._tempTarget3.resize(width, height);
            this.noiseScale(this._noiseScale);
        };
        /**
        * Creates a noise texture for the AO materials
        * @param {number} width
        * @param {number} height
        * @param {DataTexture}
        */
        AOPass.prototype.generateNoiseTexture = function (width, height) {
            var noise = new Float32Array(width * height * 4);
            var xy = new Trike.Vec3();
            for (var y = 0; y < height; ++y) {
                for (var x = 0; x < width; ++x) {
                    xy = Trike.Random.pointInsideSphere(1, undefined, xy, true);
                    var z = Math.random();
                    var w = Math.random();
                    var offset = 4 * (y * width + x);
                    noise[offset + 0] = xy.x;
                    noise[offset + 1] = xy.y;
                    noise[offset + 2] = z;
                    noise[offset + 3] = w;
                }
            }
            return new Trike.DataTexture(noise, width, height, Trike.TextureFormat.RGBAFormat, Trike.TextureType.FloatType, 1, Trike.TextureMapping.UVMapping, Trike.TextureWrapping.RepeatWrapping, Trike.TextureWrapping.RepeatWrapping, Trike.TextureFilter.Nearest, Trike.TextureFilter.Nearest);
        };
        /**
        * This is called just before the render function. Use it, to setup the composition pass before rendering
        * @param {RenderTarget} renderTarget The render target defined by the user
        * @param {Scene} scene The scene being drawn
        * @param {Camera} camera The camera used to draw the scene
        * @param {Renderer} renderer The renderer drawing the scene
        */
        AOPass.prototype.prepPass = function (renderTarget, scene, camera, renderer) {
            if (this.currentSubPass === 0) {
                // Shares the same depth and stencil data from the Gbuffer
                if (!this._tempTarget1.sharedRenderBuffer)
                    this._tempTarget1.sharedRenderBuffer = renderer.defaultCollection.gBufferPass.renderTarget;
                this.autoClearColor = true;
                this.material = this.currentAO;
                this.renderTarget = this._tempTarget1;
            }
            else if (this._blurPass && this.currentSubPass === 1) {
                this.material = this.blurHorizontal;
                this.blurHorizontal.map(this._tempTarget1);
                this.renderTarget = this._tempTarget2;
            }
            else if (this._blurPass && this.currentSubPass === 2) {
                this.material = this.blurVertical;
                this.blurVertical.map(this._tempTarget2);
                this.renderTarget = this._tempTarget3;
            }
            else if (this.currentSubPass === 3) {
                this.autoClearColor = false;
                this.material = this.copy;
                if (this._blurPass)
                    this.copy.map(this._tempTarget3);
                else
                    this.copy.map(this._tempTarget1);
                this.renderTarget = renderTarget;
            }
        };
        /**
        * Gets or sets the noise scale of the AO
        * @param {number} val [Optional]
        * @returns {number}
        */
        AOPass.prototype.noiseScale = function (val) {
            if (val === undefined)
                return this._noiseScale;
            this._noiseScale = val;
            this.materialSSAO.setUniform('noiseScale', new Trike.Vec2((this._w * this._aoScale) / val, (this._h * this._aoScale) / val));
            this.materialHBAO.noiseScale(new Trike.Vec2((this._w * this._hbaoScale) / val, (this._h * this._hbaoScale) / val));
            return val;
        };
        /**
        * Gets or sets the radius of the pixels from each sample point.
        * @param {number} val [Optional]
        * @returns {number}
        */
        AOPass.prototype.samplingRadius = function (val) {
            if (val === undefined)
                return this.materialSSAO._uniforms['samplingRadius'].value;
            this.materialSSAO.setUniform('samplingRadius', val, true);
            return val;
        };
        /**
        * Gets or sets the distance of how far the AO sample radius is
        * @param {number} val [Optional]
        * @returns {number}
        */
        AOPass.prototype.distance = function (val) {
            if (val === undefined)
                return this.materialSSAO._uniforms['distance'].value;
            this.materialSSAO.setUniform('distance', val, true);
            return val;
        };
        /**
        * Gets or sets the max intensity of the AO
        * @param {number} val [Optional]
        * @returns {number}
        */
        AOPass.prototype.intensity = function (val) {
            if (val === undefined)
                return this.materialSSAO._uniforms['intensity'].value;
            this.materialSSAO.setUniform('intensity', val, true);
            return val;
        };
        /**
        * Gets or sets the occuler bias. This helps prevent self occlusion.
        * @param {number} val [Optional]
        * @returns {number}
        */
        AOPass.prototype.occluderBias = function (val) {
            if (val === undefined)
                return this.materialSSAO._uniforms['occluderBias'].value;
            this.materialSSAO.setUniform('occluderBias', val, true);
            return val;
        };
        /**
        * Gets or sets the first attenuation scalar
        * @param {number} val [Optional]
        * @returns {number}
        */
        AOPass.prototype.att1 = function (val) {
            if (val === undefined)
                return this.materialSSAO._uniforms['attenuation1'].value;
            this.materialSSAO.setUniform('attenuation1', val, true);
            return val;
        };
        /**
        * Gets or sets the second attenuation scalar
        * @param {number} val [Optional]
        * @returns {number}
        */
        AOPass.prototype.att2 = function (val) {
            if (val === undefined)
                return this.materialSSAO._uniforms['attenuation2'].value;
            this.materialSSAO.setUniform('attenuation2', val, true);
            return val;
        };
        return AOPass;
    }(Trike.CompositionPass));
    Trike.AOPass = AOPass;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Performs the passes to draw a depth of field type of effect
    */
    var BokehPass = (function (_super) {
        __extends(BokehPass, _super);
        function BokehPass() {
            _super.call(this, 'AO Pass', null, null, Trike.FilterType.ScreenQuad, Trike.Phase.PostCompostion);
            this._tempTarget1 = new Trike.RenderTarget(2, 2, Trike.TextureType.UnsignedByteType, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureWrapping.ClampToEdgeWrapping, Trike.TextureFilter.Nearest, Trike.TextureFilter.Nearest, Trike.TextureFormat.RGBFormat, 0, false, false);
            this.materialBokeh = new Trike.MaterialBokeh();
            this.copy = new Trike.MaterialScreenTexture(false);
            this.autoClearStencil = false;
            this.autoClearDepth = false;
            this.numSubPasses = 2;
        }
        /**
        * Resizes the render target, if present, in this pass
        * @param {number} width The width of the render target
        * @param {height} width The height of the render target
        */
        BokehPass.prototype.resize = function (width, height) {
            this.materialBokeh.setUniform('aspect', width / height, true);
            this._tempTarget1.resize(width, height);
        };
        /**
        * This is called just before the render function. Use it, to setup the composition pass before rendering
        * @param {RenderTarget} renderTarget The render target defined by the user
        * @param {Scene} scene The scene being drawn
        * @param {Camera} camera The camera used to draw the scene
        * @param {Renderer} renderer The renderer drawing the scene
        */
        BokehPass.prototype.prepPass = function (renderTarget, scene, camera, renderer) {
            if (this.currentSubPass === 0) {
                this.autoClearColor = true;
                this.material = this.materialBokeh;
                this.renderTarget = this._tempTarget1;
            }
            else {
                this.autoClearColor = true;
                this.material = this.copy;
                this.copy.map(this._tempTarget1);
                this.renderTarget = renderTarget;
            }
        };
        /**
        * Gets or sets the maximum blur radius of the pixels from each sample point.
        * @param {number} val [Optional]
        * @returns {number}
        */
        BokehPass.prototype.maxBlur = function (val) {
            if (val === undefined)
                return this.materialBokeh._uniforms['maxBlur'].value;
            this.materialBokeh.setUniform('maxBlur', val, true);
            return val;
        };
        /**
        * Gets or sets the aperture value
        * @param {number} val [Optional]
        * @returns {number}
        */
        BokehPass.prototype.aperture = function (val) {
            if (val === undefined)
                return this.materialBokeh._uniforms['aperture'].value;
            this.materialBokeh.setUniform('aperture', val, true);
            return val;
        };
        /**
        * Gets or sets the focus value
        * @param {number} val [Optional]
        * @returns {number}
        */
        BokehPass.prototype.focus = function (val) {
            if (val === undefined)
                return this.materialBokeh._uniforms['focus'].value;
            this.materialBokeh.setUniform('focus', val, true);
            return val;
        };
        return BokehPass;
    }(Trike.CompositionPass));
    Trike.BokehPass = BokehPass;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * The {AnimationPlayer} class is used to transform a skinned mesh's bones based on an {AnimationTrack}. {AnimationTrack}'s are created from a skinned
    * object's geometry. The track contains a series of BoneTrack's that subsequently contain keys to define interpolation points over time for each of the bones.
    * The {AnimationPlayer} class manages a given animation track over time and performs the neccessary transforms on the bones of its skinned mesh.
    */
    var AnimationPlayer = (function (_super) {
        __extends(AnimationPlayer, _super);
        /**
        * Creates an instance of the AnimationPlayer
        * @param {MeskSkinned} root The skinned mesh this player is animating
        * @param {AnimationTrack} track The track from where this player gets its transform data from.
        * @param {string} name The name of the animation this player represents
        */
        function AnimationPlayer(root, track, name) {
            _super.call(this);
            if (!AnimationPlayer._c) {
                AnimationPlayer._c = new Array();
                AnimationPlayer._points = [];
                AnimationPlayer._target = new Trike.Vec3();
                AnimationPlayer._tmpVec = new Trike.Vec3();
                AnimationPlayer._tmpQuat = new Trike.Quat();
            }
            this._animTrack = track;
            this._name = name;
            this._currentTime = 0;
            this.speed = 0.0005;
            this._isPlaying = false;
            this._isPaused = true;
            this.loop = true;
            this.weight = 1;
            this._interpolationType = Trike.InterpolationType.LINEAR;
            this._bones = root.bones;
        }
        /**
        * Gets this player to play the animation from its AnimationTrack
        * @param {number} startTime [Optional] You can specify the time at which the animation will play at
        * @returns {AnimationPlayer}
        */
        AnimationPlayer.prototype.play = function (startTime) {
            this._currentTime = startTime;
            if (this._isPlaying === false) {
                this._isPlaying = true;
                this.reset();
                this.update(0);
            }
            this._isPaused = false;
            return this;
        };
        /**
        * Pauses the play back of the animation
        * @returns {AnimationPlayer}
        */
        AnimationPlayer.prototype.pause = function () {
            this._isPlaying = false;
            this._isPaused = true;
            return this;
        };
        /**
        * Un-pauses the play back of the animation
        * @returns {AnimationPlayer}
        */
        AnimationPlayer.prototype.unPause = function () {
            this._isPlaying = true;
            this._isPaused = false;
            return this;
        };
        /**
        * stops the animation play head and sets the time back to the beginning of the track
        * @returns {AnimationPlayer}
        */
        AnimationPlayer.prototype.stop = function () {
            this.reset();
            this._isPlaying = false;
            this._isPaused = false;
            if (this._listeners.length > 0) {
                AnimationPlayer._eventStopped.player = this;
                this.emit('player_on_stopped', AnimationPlayer._eventStopped);
            }
            return this;
        };
        /**
        * Sets the animation play head back to the beginning of the animation
        * @returns {AnimationPlayer}
        */
        AnimationPlayer.prototype.reset = function () {
            this._currentTime = 0;
            return this;
        };
        /**
        * Gets the first available key before a given time
        * @param {Array<AnimationKey>} keys The animation keys we are searching through
        * @param {number} time The time from where we start searching
        * @returns {AnimationKey}
        */
        AnimationPlayer.prototype.getKeyBefore = function (keys, time) {
            var toRet = null;
            for (var i = 0, l = keys.length; i < l; i++)
                if (keys[i].time > time)
                    return toRet;
                else
                    toRet = keys[i];
        };
        /**
        * Gets the first available key after a given time
        * @param {Array<AnimationKey>} keys The animation keys we are searching through
        * @param {number} time The time from where we start searching
        * @returns {AnimationKey}
        */
        AnimationPlayer.prototype.getKeyAfter = function (keys, time) {
            var toRet = null;
            for (var i = keys.length - 1; i > -1; i--)
                if (keys[i].time <= time)
                    return toRet;
                else
                    toRet = keys[i];
        };
        /**
        * Updates the animation transforms based on time
        * @param {number} delta The delta time in miliseconds
        * @returns {AnimationKey}
        */
        AnimationPlayer.prototype.update = function (delta) {
            if (this._isPlaying === false)
                return;
            var duration = this._animTrack.duration;
            var listeners = this._listeners;
            this._currentTime += delta * this.speed;
            // If we looping, then start from the beginning
            if (this.loop === true && this._currentTime > duration) {
                this._currentTime %= duration;
                if (listeners.length > 0) {
                    AnimationPlayer._eventLoop.player = this;
                    AnimationPlayer._eventComplete.player = this;
                    this.emit('player_on_loop', AnimationPlayer._eventLoop);
                    this.emit('player_complete', AnimationPlayer._eventComplete);
                }
            }
            else if (this.loop === false && this._currentTime > duration) {
                this.stop();
                if (listeners.length > 0) {
                    AnimationPlayer._eventComplete.player = this;
                    this.emit('player_complete', AnimationPlayer._eventComplete);
                }
                return;
            }
            else {
                // Set the current time again because the above might have changed it/
                this._currentTime = Math.min(this._currentTime, duration);
            }
            var weight = this.weight;
            var bones = this._bones;
            var boneTracks = this._animTrack.boneTracks;
            var interpolationType = this._interpolationType;
            var curTime = this._currentTime;
            var bone;
            var boneTrack;
            var translateKeys;
            var rotateKeys;
            var scaleKeys;
            var prevKeyT;
            var nextKeyT;
            var prev2KeyT;
            var next2KeyT;
            var prevKeyR;
            var nextKeyR;
            var prevKeyS;
            var nextKeyS;
            var scale = 0;
            var bonePos;
            var boneScale;
            var prevVector;
            var nextVector;
            var target = AnimationPlayer._target;
            var points = AnimationPlayer._points;
            var updateBone = false;
            var tempQuat = AnimationPlayer._tmpQuat;
            var tempVec = AnimationPlayer._tmpVec;
            points.splice(0, points.length);
            // Go through each of the bone tracks
            for (var bt = 0, btl = boneTracks.length; bt < btl; bt++) {
                boneTrack = boneTracks[bt];
                bone = bones[boneTrack.boneIndex];
                // Calculate position offsets
                translateKeys = boneTrack.translateKeys;
                if (translateKeys.length > 0) {
                    prevKeyT = this.getKeyBefore(translateKeys, curTime);
                    nextKeyT = this.getKeyAfter(translateKeys, curTime);
                    if (!prevKeyT || !nextKeyT)
                        continue;
                    bone.updateMatrix = true;
                    // Get the normalised position of the current time from the previous key to the next
                    scale = (curTime - prevKeyT.time) / (nextKeyT.time - prevKeyT.time);
                    if (scale < 0)
                        scale = 0;
                    if (scale > 1)
                        scale = 1;
                    bonePos = bone.position;
                    prevVector = prevKeyT.position;
                    nextVector = nextKeyT.position;
                    if (interpolationType === Trike.InterpolationType.LINEAR) {
                        var newVector = tempVec;
                        newVector.x = prevVector.x + (nextVector.x - prevVector.x) * scale;
                        newVector.y = prevVector.y + (nextVector.y - prevVector.y) * scale;
                        newVector.z = prevVector.z + (nextVector.z - prevVector.z) * scale;
                        bonePos.lerp(newVector, weight);
                    }
                    else if (interpolationType === Trike.InterpolationType.CATMULLROM || this._interpolationType === Trike.InterpolationType.CATMULLROM_FORWARD) {
                        prev2KeyT = this.getKeyBefore(translateKeys, prevKeyT.time - 0.0001);
                        next2KeyT = this.getKeyAfter(translateKeys, nextKeyT.time + 0.0001);
                        if (!prev2KeyT || !next2KeyT)
                            continue;
                        points[0] = prev2KeyT.position;
                        points[1] = prevVector;
                        points[2] = nextVector;
                        points[3] = next2KeyT.position;
                        scale = scale * 0.33 + 0.33;
                        var currentPoint = AnimationPlayer.interpolateCatmullRom(points, scale);
                        bonePos.x = bonePos.x + (currentPoint.x - bonePos.x) * weight;
                        bonePos.y = bonePos.y + (currentPoint.y - bonePos.y) * weight;
                        bonePos.z = bonePos.z + (currentPoint.z - bonePos.z) * weight;
                        if (this._interpolationType === Trike.InterpolationType.CATMULLROM_FORWARD) {
                            var forwardPoint = AnimationPlayer.interpolateCatmullRom(points, scale * 1.01);
                            target.set(forwardPoint.x, forwardPoint.y, forwardPoint.z);
                            target.sub(bonePos);
                            target.y = 0;
                            target.normalize();
                            var angle = Math.atan2(target.x, target.z);
                            bone.setRotation(0, angle, 0);
                        }
                    }
                }
                // Calculate rotation offsets
                rotateKeys = boneTrack.rotateKeys;
                if (rotateKeys.length > 0) {
                    prevKeyR = this.getKeyBefore(rotateKeys, curTime);
                    nextKeyR = this.getKeyAfter(rotateKeys, curTime);
                    if (!prevKeyR || !nextKeyR)
                        continue;
                    bone.updateMatrix = true;
                    // Get the normalised position of the current time from the previous key to the next
                    scale = (curTime - prevKeyR.time) / (nextKeyR.time - prevKeyR.time);
                    if (scale < 0)
                        scale = 0;
                    if (scale > 1)
                        scale = 1;
                    var newRotation = tempQuat;
                    Trike.Quat.slerp(prevKeyR.rotation, nextKeyR.rotation, newRotation, scale);
                    newRotation.normalize();
                    Trike.Quat.slerp(bone.quaternion, newRotation, bone.quaternion, weight);
                }
                // Calculate scale offsets
                scaleKeys = boneTrack.scaleKeys;
                if (scaleKeys.length > 0) {
                    prevKeyS = this.getKeyBefore(scaleKeys, curTime);
                    nextKeyS = this.getKeyAfter(scaleKeys, curTime);
                    if (!prevKeyS || !nextKeyS)
                        continue;
                    bone.updateMatrix = true;
                    // Get the normalised position of the current time from the previous key to the next
                    scale = (curTime - prevKeyS.time) / (nextKeyS.time - prevKeyS.time);
                    if (scale < 0)
                        scale = 0;
                    if (scale > 1)
                        scale = 1;
                    prevVector = prevKeyS.scale;
                    nextVector = nextKeyS.scale;
                    boneScale = bone.scale;
                    var newScale = tempVec;
                    newScale.x = prevVector.x + (nextVector.x - prevVector.x) * scale;
                    newScale.y = prevVector.y + (nextVector.y - prevVector.y) * scale;
                    newScale.z = prevVector.z + (nextVector.z - prevVector.z) * scale;
                    boneScale.lerp(newScale, weight);
                }
            }
            return this;
        };
        /***
        * Creates a Catmull-Rom interpolation based on the given scale
        * see http://www.mvps.org/directx/articles/catmull/
        */
        AnimationPlayer.interpolateCatmullRom = function (points, scale) {
            var c = AnimationPlayer._c, v3 = new Trike.Vec3();
            var point, intPoint, weight, w2, w3, pa, pb, pc, pd;
            point = (points.length - 1) * scale;
            intPoint = Math.floor(point);
            weight = point - intPoint;
            c[0] = intPoint === 0 ? intPoint : intPoint - 1;
            c[1] = intPoint;
            c[2] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
            c[3] = intPoint > points.length - 3 ? intPoint : intPoint + 2;
            pa = points[c[0]];
            pb = points[c[1]];
            pc = points[c[2]];
            pd = points[c[3]];
            w2 = weight * weight;
            w3 = weight * w2;
            v3.x = AnimationPlayer.interpolate(pa.x, pb.x, pc.x, pd.x, weight, w2, w3);
            v3.y = AnimationPlayer.interpolate(pa.y, pb.y, pc.y, pd.y, weight, w2, w3);
            v3.z = AnimationPlayer.interpolate(pa.z, pb.z, pc.z, pd.z, weight, w2, w3);
            return v3;
        };
        /***
        * Quick n dirty interpolation of some numbers
        */
        AnimationPlayer.interpolate = function (p0, p1, p2, p3, t, t2, t3) {
            var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5;
            return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
        };
        /**
        * Cleans up the Animation set for disposal.
        */
        AnimationPlayer.prototype.dispose = function () {
            this._root = null;
            this._name = null;
            this._animTrack = null;
            this._bones = null;
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(AnimationPlayer.prototype, "name", {
            /**
            * Gets the name of this animation
            * @returns {string}
            */
            get: function () { return this._name; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationPlayer.prototype, "isPaused", {
            /**
            * Gets if this player is currently paused
            * @returns {boolean}
            */
            get: function () { return this._isPaused; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationPlayer.prototype, "animationTrack", {
            /**
            * Gets the animation track of this player
            * @returns {AnimationTrack}
            */
            get: function () { return this._animTrack; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AnimationPlayer.prototype, "isPlaying", {
            /**
            * Gets if this player is currently playing
            * @returns {boolean}
            */
            get: function () { return this._isPlaying; },
            enumerable: true,
            configurable: true
        });
        AnimationPlayer._eventComplete = { player: null };
        AnimationPlayer._eventLoop = { player: null };
        AnimationPlayer._eventStopped = { player: null };
        return AnimationPlayer;
    }(Trike.EventDispatcher));
    Trike.AnimationPlayer = AnimationPlayer;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Base class for all animation keys. Represents an animation key frame at a given time.
    */
    var AnimationKey = (function () {
        /**
        * Creates an instance
        */
        function AnimationKey(time) {
            this.time = time || 0;
        }
        return AnimationKey;
    }());
    Trike.AnimationKey = AnimationKey;
    /**
    * A key that represents a translation at a given time
    */
    var TranslateKey = (function (_super) {
        __extends(TranslateKey, _super);
        /**
        * Creates an instance
        */
        function TranslateKey(time, position) {
            _super.call(this, time);
            this.position = position || null;
        }
        return TranslateKey;
    }(AnimationKey));
    Trike.TranslateKey = TranslateKey;
    /**
    * A key that represents a rotation at a given time
    */
    var RotateKey = (function (_super) {
        __extends(RotateKey, _super);
        /**
        * Creates an instance
        */
        function RotateKey(time, rotation) {
            _super.call(this, time);
            this.rotation = rotation || null;
        }
        return RotateKey;
    }(AnimationKey));
    Trike.RotateKey = RotateKey;
    /**
    * A key that represents a scale at a given time
    */
    var ScaleKey = (function (_super) {
        __extends(ScaleKey, _super);
        /**
        * Creates an instance
        */
        function ScaleKey(time, scale) {
            _super.call(this, time);
            this.scale = scale || null;
        }
        return ScaleKey;
    }(AnimationKey));
    Trike.ScaleKey = ScaleKey;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    (function (InterpolationType) {
        InterpolationType[InterpolationType["LINEAR"] = 0] = "LINEAR";
        InterpolationType[InterpolationType["CATMULLROM"] = 1] = "CATMULLROM";
        InterpolationType[InterpolationType["CATMULLROM_FORWARD"] = 2] = "CATMULLROM_FORWARD";
    })(Trike.InterpolationType || (Trike.InterpolationType = {}));
    var InterpolationType = Trike.InterpolationType;
    /**
    * Represents an transform of a bone over time. Each track has an array of {AnimationKey}'s for translation, rotation and scale over time.
    */
    var BoneTrack = (function () {
        /**
        * Creates an instance of a BoneTrack
        * @param {number} boneIndex The index of the bone this track represents
        * @param {string} boneName The name of the bone this track represents
        */
        function BoneTrack(boneIndex, boneName) {
            this.boneIndex = boneIndex;
            this.boneName = boneName;
            this.translateKeys = new Array();
            this.rotateKeys = new Array();
            this.scaleKeys = new Array();
        }
        return BoneTrack;
    }());
    Trike.BoneTrack = BoneTrack;
    /**
    * Represents an animation consisting of a number of bone tracks. Each bone track has keys for translation, rotation and scale over time.
    * An AnimationPlayer can apply these transforms over time to a skinned mesh
    */
    var AnimationTrack = (function () {
        /**
        * Creates an instance of an AnimationTrack
        * @param {string} name The name of the animation this track represents
        * @param {number} duration The amount of time, in seconds, this track spans
        */
        function AnimationTrack(name, duration) {
            this.name = name;
            this.duration = duration;
            this.boneTracks = new Array();
        }
        /**
        * Sets the values of this track from a loaded JSON object
        * @param {any} data The JSON object representing this track
        * @param {Array<BoneInfo>} bones The bones of the mesh that this track will be modifying
        * @returns {AnimationTrack}
        */
        AnimationTrack.prototype.fromJSON = function (data, bones) {
            this.name = data.name;
            this.duration = data.length;
            var keys = new Array();
            // loop through all keys
            for (var h = 0; h < data.hierarchy.length; h++) {
                for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
                    // remove minus times
                    if (data.hierarchy[h].keys[k].time < 0)
                        data.hierarchy[h].keys[k].time = 0;
                }
                // remove all keys that are on the same time
                for (var k = 1; k < data.hierarchy[h].keys.length; k++) {
                    if (data.hierarchy[h].keys[k].time === data.hierarchy[h].keys[k - 1].time) {
                        data.hierarchy[h].keys.splice(k, 1);
                        k--;
                    }
                }
                // We need to find the bone index for each of the tracks
                var boneIndex = -1;
                var boneName = '';
                for (var i = 0, l = bones.length; i < l; i++)
                    if (bones[i].name === data.hierarchy[h].boneName) {
                        boneIndex = i;
                        boneName = bones[i].name;
                        break;
                    }
                // Create the bone track
                var animNode = new BoneTrack(boneIndex, boneName);
                this.boneTracks.push(animNode);
                // Now fill the keys in their respective tracks
                for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
                    if (data.hierarchy[h].keys[k].pos)
                        animNode.translateKeys.push(new Trike.TranslateKey(data.hierarchy[h].keys[k].time, new Trike.Vec3().fromArray(data.hierarchy[h].keys[k].pos)));
                    if (data.hierarchy[h].keys[k].rot)
                        animNode.rotateKeys.push(new Trike.RotateKey(data.hierarchy[h].keys[k].time, new Trike.Quat().fromArray(data.hierarchy[h].keys[k].rot)));
                    if (data.hierarchy[h].keys[k].scl)
                        animNode.scaleKeys.push(new Trike.ScaleKey(data.hierarchy[h].keys[k].time, new Trike.Vec3().fromArray(data.hierarchy[h].keys[k].scl)));
                }
            }
            // done
            data.initialized = true;
            return this;
        };
        return AnimationTrack;
    }());
    Trike.AnimationTrack = AnimationTrack;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Abstract loader class for all other loaders.
    */
    var ModelLoader = (function (_super) {
        __extends(ModelLoader, _super);
        function ModelLoader(useCredentials) {
            if (useCredentials === void 0) { useCredentials = true; }
            _super.call(this);
            this.crossOrigin = null;
            this.useCredentials = useCredentials;
        }
        ModelLoader.prototype.load = function (url, geometry) {
            throw new Error('Must be overriden in child classes');
        };
        /**
        * Once the data has been loaded, subsequent classes must parse the load content
        * @returns {Geometry}
        */
        ModelLoader.prototype.onParse = function (data, xhr) { return null; };
        /**
        * Load an XHR Request.
        */
        ModelLoader.prototype.xhrLoad = function (url) {
            var _this = this;
            var that = this;
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, true);
            // Add events
            xhr.addEventListener('load', function (ev) {
                var geom = that.onParse(xhr.responseText, xhr);
                _this.emit('model_loader_complete', { geometry: geom, message: 'Load Complete [' + that.extractFilename(url) + ']', percent: 100 });
            }, false);
            // Errors
            xhr.addEventListener('error', function (ev) {
                _this.emit('model_loader_error', { geometry: null, message: null, percent: 0 });
            }, false);
            // Progress
            xhr.addEventListener('progress', function (ev) {
                _this.emit('model_loader_progress', { geometry: null, message: null, percent: ev.loaded / ev.total });
            }, false);
            // We must use credentials if using SSL
            xhr.withCredentials = this.useCredentials;
            // Start the download
            xhr.send(null);
        };
        /**
        * Gets the URL directory without the filename
        */
        ModelLoader.prototype.extractUrlBase = function (url) {
            var parts = url.split('/');
            if (parts.length === 1)
                return './';
            parts.pop();
            return parts.join('/') + '/';
        };
        /**
        * Gets the file name of a URL
        */
        ModelLoader.prototype.extractFilename = function (url) {
            var parts = url.split('/');
            return parts[parts.length - 1];
        };
        /**
        * Cleanup
        */
        ModelLoader.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        return ModelLoader;
    }(Trike.EventDispatcher));
    Trike.ModelLoader = ModelLoader;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A loader used to load OBJ files. Currently supports Blender exporter
    */
    var OBJLoader = (function (_super) {
        __extends(OBJLoader, _super);
        function OBJLoader(useCredentials) {
            if (useCredentials === void 0) { useCredentials = true; }
            _super.call(this, useCredentials);
            this.geometry = null;
        }
        /**
        * Attempts to load geometry or material data from a URL. You can optionally pass in a geometry
        * object to be filled. You should use the addEventListener function and hook into the ModelLoadEvents
        * events.
        */
        OBJLoader.prototype.load = function (url, geometry) {
            this.geometry = geometry;
            _super.prototype.xhrLoad.call(this, url);
            return this;
        };
        /**
        * Cleanup
        */
        OBJLoader.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.geometry = null;
        };
        /**
        * Once the data has been loaded, subsequent classes must parse the load content
        * @returns {Geometry}
        */
        OBJLoader.prototype.onParse = function (text, xhr) {
            // fixes
            text = text.replace(/\\\r\n/g, ''); // handles line continuations \
            var geometries = [];
            var curGeometry;
            // If no objects are define, then create the default
            if (/^o /gm.test(text) === false) {
                curGeometry = { faces: [], normals: [], uvs: [], vertices: [] };
                geometries.push(curGeometry);
            }
            // Each line of the OBJ file
            var lines = text.split('\n');
            var dataSplit;
            var faceSplit;
            var code;
            var aSplit;
            var bSplit;
            var cSplit;
            var dSplit;
            var lastVertIndex = 0;
            var lastNormIndex = 0;
            var lastUVIndex = 0;
            var v1, v2, v3, n1, n2, n3, u1, u2;
            // v float float float
            var vertex_pattern = /v( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/;
            // vn float float float
            var normal_pattern = /vn( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/;
            // vt float float
            var uv_pattern = /vt( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/;
            // f vertex vertex vertex ...
            var face_pattern1 = /f( +-?\d+)( +-?\d+)( +-?\d+)( +-?\d+)?/;
            // f vertex/uv vertex/uv vertex/uv ...
            var face_pattern2 = /f( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))?/;
            // f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...
            var face_pattern3 = /f( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))?/;
            // f vertex// normal vertex// normal vertex// normal ...
            var face_pattern4 = /f( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))?/;
            var result;
            // For each line in the OBJ file
            for (var i = 0; i < lines.length; i++) {
                var line = lines[i];
                line = line.trim();
                if (line === '')
                    continue;
                // Makes sure that the line has no long spaces within itself
                line = line.replace(/^(\s*)|(\s*)$/g, '').replace(/\s+/g, ' ');
                dataSplit = line.split(' ');
                code = dataSplit[0].toLowerCase();
                switch (code) {
                    // New Object
                    case 'o':
                        lastVertIndex += (curGeometry ? curGeometry.vertices.length : 0);
                        lastNormIndex += (curGeometry ? curGeometry.normals.length : 0);
                        lastUVIndex += (curGeometry ? curGeometry.uvs.length : 0);
                        curGeometry = { faces: [], normals: [], uvs: [], vertices: [] };
                        geometries.push(curGeometry);
                        break;
                    // Vertex
                    case 'v':
                        curGeometry.vertices.push(new Trike.Vec3(parseFloat(dataSplit[1]), parseFloat(dataSplit[2]), parseFloat(dataSplit[3])));
                        break;
                    // UV
                    case 'vt':
                        curGeometry.uvs.push(new Trike.Vec2(parseFloat(dataSplit[1]), parseFloat(dataSplit[2])));
                        break;
                    // Normal
                    case 'vn':
                        curGeometry.normals.push(new Trike.Vec3(parseFloat(dataSplit[1]), parseFloat(dataSplit[2]), parseFloat(dataSplit[3])));
                        break;
                    // Face
                    case 'f':
                        aSplit = dataSplit[1].split('/');
                        bSplit = dataSplit[2].split('/');
                        cSplit = dataSplit[3].split('/');
                        dSplit = null;
                        if (dataSplit.length > 4)
                            dSplit = dataSplit[4].split('/');
                        // 3 component face
                        if (dataSplit.length === 4) {
                            var faceA = new Trike.Face3(parseFloat(aSplit[0]) - 1 - lastVertIndex, parseFloat(bSplit[0]) - 1 - lastVertIndex, parseFloat(cSplit[0]) - 1 - lastVertIndex);
                            if (aSplit.length > 1)
                                faceA.setAttributeIndices(Trike.AttributeType.UV, parseFloat(aSplit[1]) - 1 - lastUVIndex, parseFloat(bSplit[1]) - 1 - lastUVIndex, parseFloat(cSplit[1]) - 1 - lastUVIndex);
                            if (aSplit.length > 2)
                                faceA.setAttributeIndices(Trike.AttributeType.NORMAL, parseFloat(aSplit[2]) - 1 - lastNormIndex, parseFloat(bSplit[2]) - 1 - lastNormIndex, parseFloat(cSplit[2]) - 1 - lastNormIndex);
                            curGeometry.faces.push(faceA);
                        }
                        else if (dataSplit.length > 4) {
                            var faceA = new Trike.Face3(parseFloat(aSplit[0]) - 1 - lastVertIndex, parseFloat(bSplit[0]) - 1 - lastVertIndex, parseFloat(dSplit[0]) - 1 - lastVertIndex);
                            var faceB = new Trike.Face3(parseFloat(bSplit[0]) - 1 - lastVertIndex, parseFloat(cSplit[0]) - 1 - lastVertIndex, parseFloat(dSplit[0]) - 1 - lastVertIndex);
                            if (aSplit.length > 1) {
                                faceA.setAttributeIndices(Trike.AttributeType.UV, parseFloat(aSplit[1]) - 1 - lastUVIndex, parseFloat(bSplit[1]) - 1 - lastUVIndex, parseFloat(dSplit[1]) - 1 - lastUVIndex);
                                faceB.setAttributeIndices(Trike.AttributeType.UV, parseFloat(bSplit[1]) - 1 - lastUVIndex, parseFloat(cSplit[1]) - 1 - lastUVIndex, parseFloat(dSplit[1]) - 1 - lastUVIndex);
                            }
                            if (aSplit.length > 2) {
                                faceA.setAttributeIndices(Trike.AttributeType.NORMAL, parseFloat(aSplit[2]) - 1 - lastNormIndex, parseFloat(bSplit[2]) - 1 - lastNormIndex, parseFloat(dSplit[2]) - 1 - lastNormIndex);
                                faceB.setAttributeIndices(Trike.AttributeType.NORMAL, parseFloat(bSplit[2]) - 1 - lastNormIndex, parseFloat(cSplit[2]) - 1 - lastNormIndex, parseFloat(dSplit[2]) - 1 - lastNormIndex);
                            }
                            curGeometry.faces.push(faceA);
                            curGeometry.faces.push(faceB);
                        }
                        break;
                }
            }
            var geom = this.geometry;
            geom.resetBuffers();
            for (var i = 0, l = geometries.length; i < l; i++) {
                var newGeom = new Trike.Geometry();
                if (geometries[i].vertices.length > 0)
                    newGeom.addAttributes(new Trike.GeometryBuffer(geometries[i].vertices, 3, Trike.AttributeType.POSITION));
                if (geometries[i].uvs.length > 0)
                    newGeom.addAttributes(new Trike.GeometryBuffer(geometries[i].uvs, 2, Trike.AttributeType.UV));
                if (geometries[i].normals.length > 0)
                    newGeom.addAttributes(new Trike.GeometryBuffer(geometries[i].normals, 3, Trike.AttributeType.NORMAL));
                if (geometries[i].faces.length > 0)
                    newGeom.faces = geometries[i].faces;
                geom.mergGeometry(newGeom);
            }
            geom.computeCentroids();
            geom.computeFaceNormals();
            geom.computeBoundingBox();
            geom.computeBoundingSphere();
            return geom;
        };
        return OBJLoader;
    }(Trike.ModelLoader));
    Trike.OBJLoader = OBJLoader;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Class used to download contents from a server into an ArrayBuffer
    */
    var BinaryLoader = (function (_super) {
        __extends(BinaryLoader, _super);
        /**
        * Creates an instance of the Loader
        */
        function BinaryLoader() {
            _super.call(this);
            this._xhr = null;
            this._url = '';
            this._onBuffers = this.onBuffersLoaded.bind(this);
            this._onError = this.onError.bind(this);
        }
        /**
        * This function will make a GET request and attempt to download a file into binary data
        * @param {string} url The URL we want to load
        * @param {number} numTries The number of attempts allowed to make this load
        */
        BinaryLoader.prototype.load = function (url, numTries) {
            if (numTries === void 0) { numTries = 3; }
            this._numTries = numTries;
            this._url = url;
            this._xhr = new XMLHttpRequest();
            this._xhr.addEventListener('load', this._onBuffers, false);
            this._xhr.addEventListener('error', this._onError, false);
            this._xhr.withCredentials = true;
            var fullURL = url;
            this._xhr.open('GET', fullURL, true);
            this._xhr.responseType = 'arraybuffer';
            if (this._xhr.overrideMimeType)
                this._xhr.overrideMimeType('text/plain; charset=x-user-defined');
            this._xhr.send(null);
        };
        /**
        * If an error occurs
        */
        BinaryLoader.prototype.onError = function (event) {
            if (this._numTries > 0) {
                if (this._numTries > 0)
                    this._numTries--;
                this._xhr.open('GET', this._url, true);
                this._xhr.send(null);
            }
            else {
                this.emit('binary_error', { buffer: null, message: 'Could not download data from \'' + this._url + '\'' });
                this.dispose();
            }
        };
        /**
        * Cleans up and removes references for GC
        */
        BinaryLoader.prototype.dispose = function () {
            this._xhr.removeEventListener('load', this._onBuffers, false);
            this._xhr.removeEventListener('error', this._onError, false);
            this._xhr = null;
            _super.prototype.dispose.call(this);
        };
        /**
        * Called when the buffers have been loaded
        */
        BinaryLoader.prototype.onBuffersLoaded = function () {
            var xhr = this._xhr;
            var buffer = xhr.response;
            // IEWEBGL needs this
            if (buffer === undefined)
                buffer = (new Uint8Array(xhr.response)).buffer;
            // Buffer not loaded, so manually fill it by converting the string data to bytes
            if (buffer.byteLength === 0) {
                // iOS and other XMLHttpRequest level 1
                buffer = new ArrayBuffer(xhr.responseText.length);
                var bufView = new Uint8Array(buffer);
                for (var i = 0, l = xhr.responseText.length; i < l; i++)
                    bufView[i] = xhr.responseText.charCodeAt(i) & 0xff;
            }
            this.emit('binary_success', { buffer: buffer, message: null });
            this.dispose();
        };
        return BinaryLoader;
    }(Trike.EventDispatcher));
    Trike.BinaryLoader = BinaryLoader;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    (function (MultiMaterialOptions) {
        MultiMaterialOptions[MultiMaterialOptions["None"] = 0] = "None";
        MultiMaterialOptions[MultiMaterialOptions["CreateDefaults"] = 1] = "CreateDefaults";
        MultiMaterialOptions[MultiMaterialOptions["CreateGBuffer"] = 2] = "CreateGBuffer";
        MultiMaterialOptions[MultiMaterialOptions["CreateGBuffer2"] = 4] = "CreateGBuffer2";
        MultiMaterialOptions[MultiMaterialOptions["CreateShadowLightPass"] = 8] = "CreateShadowLightPass";
        MultiMaterialOptions[MultiMaterialOptions["CreateShadowPass"] = 16] = "CreateShadowPass";
    })(Trike.MultiMaterialOptions || (Trike.MultiMaterialOptions = {}));
    var MultiMaterialOptions = Trike.MultiMaterialOptions;
    /**
    * Wrapper class for uniform variables that the material has a reference to.
    */
    var UniformVar = (function () {
        /**
        * Creates an instance of the UniformVar
        * @param {string} name The name of the uniform
        * @param {UniformType} type The type of uniform
        * @param {WebGLUniformLocation} [Optional] location The webgl location
        */
        function UniformVar(name, type, value, location) {
            this.requiresUpdate = true;
            this.name = name;
            if (value !== undefined)
                this.value = value;
            else {
                // Create defaults
                switch (type) {
                    case Trike.UniformType.MAT3:
                        this.value = new Trike.Matrix3();
                        break;
                    case Trike.UniformType.MAT4:
                        this.value = new Trike.Matrix4();
                        break;
                    case Trike.UniformType.INT:
                        this.value = 0;
                        break;
                    case Trike.UniformType.FLOAT:
                        this.value = 0.0;
                        break;
                    case Trike.UniformType.FLOAT2:
                        this.value = new Trike.Vec2(0.0, 0.0);
                        break;
                    case Trike.UniformType.FLOAT2_ARRAY:
                        this.value = new Trike.UniformArray([new Trike.Vec2()], 2);
                        break;
                    case Trike.UniformType.FLOAT3:
                        this.value = new Trike.Vec3(0.0, 0.0, 0.0);
                        break;
                    case Trike.UniformType.FLOAT4:
                        this.value = new Trike.Vec4(0.0, 0.0, 0.0, 0.0);
                        break;
                    case Trike.UniformType.FLOAT_ARRAY:
                    case Trike.UniformType.INT_ARRAY:
                        this.value = [0];
                        break;
                    case Trike.UniformType.FLOAT3_ARRAY:
                        this.value = new Trike.UniformArray([new Trike.Vec3()], 3);
                        break;
                    case Trike.UniformType.FLOAT4_ARRAY:
                        this.value = new Trike.UniformArray([new Trike.Vec4()], 4);
                        break;
                    case Trike.UniformType.MAT3_ARRAY:
                        this.value = new Trike.UniformArray([new Trike.Matrix3()], 9);
                        break;
                    case Trike.UniformType.MAT4_ARRAY:
                        this.value = new Trike.UniformArray([new Trike.Matrix4()], 16);
                        break;
                    case Trike.UniformType.TEXTURE_ARRAY:
                        this.value = new Trike.UniformArray([], 1);
                        break;
                    case Trike.UniformType.QUAT:
                        this.value = new Trike.Quat();
                        break;
                    case Trike.UniformType.COLOR3:
                        this.value = new Trike.Color(0xffffff);
                        break;
                    case Trike.UniformType.TEXTURE:
                        this.value = value || null;
                        break;
                }
            }
            this.type = type;
            this.location = location;
        }
        UniformVar.prototype.set = function (val) {
        };
        /**
        * Clones the uniform variable
        * @returns {UniformVar}
        */
        UniformVar.prototype.clone = function () {
            var toRet = new UniformVar(this.name, this.type, this.value);
            return toRet;
        };
        return UniformVar;
    }());
    Trike.UniformVar = UniformVar;
    /**
    * Wrapper class for attribute variables that the material has a reference to.
    */
    var AttributeVar = (function () {
        /**
        * Creates an instance of the AttributeVar
        * @param {string} name The name of the attribute
        * @param {AttributeType} type The type of attribute to add
        * @param {number} [Optional] location The webgl location
        */
        function AttributeVar(name, type, location) {
            this.name = name;
            this.type = type;
            this.location = location;
            var test = '';
        }
        /**
        * Clones the uniform variable
        * @returns {AttributeVar}
        */
        AttributeVar.prototype.clone = function () {
            var toRet = new AttributeVar(this.name, this.type);
            return toRet;
        };
        return AttributeVar;
    }());
    Trike.AttributeVar = AttributeVar;
    /**
    * Base class for all materials. Materials are used to draw 3D polygons in the scene.
    * The MaterialMulti class represents a group of materials that are used at different stages
    * in a render call. In each call, several meshes are drawn - provided they have both geometry and
    * a MaterialMulti. A MaterialMulti class generates the vertex and fragment shaders for all
    * its child materials. Each of the child materials use different define statements and/or
    * uniforms, to accomplish different tasks - but the overall structure of the shaders is the same.
    * The renderer chooses a material based on the RenderPass that's being used. Each render call is
    * made up of different passes that do different things. For example, you can have a color pass,
    * then a normal pass or a depth pass etc... The mesh will often have to be drawn for each of these passes.
    * The currently outlined passes supported in Trike are defined in the PassType enum. Once in the render
    * call, the renderer will check if a sub material is present based on the pass type. I.e...
    * if ( renderPass.passType === GBuffer2 && material.materials[PassType.GBuffer2] )
    *	materialToUse = material.materials[PassType.GBuffer2];
    *
    * If no sub material is found, the render for that mesh on that specific pass is ignored.
    *
    * Some of the more advanced MultiMaterials also create MaterialPasses. These are
    * optional, and are run before the main operations of a render call. They essentially draw
    * the scene using the passes of the material as opposed to the passes of the renderer.
    * This is useful for things like drawing information to a render target that is used later
    * in the more standard passes.
    */
    var MaterialMulti = (function (_super) {
        __extends(MaterialMulti, _super);
        /**
        * Creates an instance of the material
        * @param {boolean} createPassMaterials If true, submaterials will be generated
        */
        function MaterialMulti(defaultSubMaterials) {
            if (defaultSubMaterials === void 0) { defaultSubMaterials = MultiMaterialOptions.CreateDefaults; }
            _super.call(this);
            if (MaterialMulti.numMaterials === 0)
                MaterialMulti.materialPasses = [];
            MaterialMulti.numMaterials++;
            this._transparent = false;
            this._vertexSource = '';
            this._fragmentSource = '';
            this._rawVertexSource = '';
            this._rawFragmentSource = '';
            this._error = false;
            this._compileStatus = '';
            this._vertShader = null;
            this._fragShader = null;
            this._program = null;
            this._skinning = false;
            this.sourceFactor = Trike.PixelFactor.SourceAlpha;
            this.destinationFactor = Trike.PixelFactor.One;
            this._blendMode = Trike.BlendMode.None;
            this._numInfluences = -1;
            // Shadow mapping
            this._maxNumShadows = 0;
            this._shadowFilter = Trike.ShadowQuality.Low;
            this._shadowType = Trike.ShadowSoftener.None;
            this.receivesShadows = false;
            this._uniforms = {};
            this._attributes = {};
            this._materials = {};
            this._defines = [];
            this._shaderTextures = [];
            this.requiresBuild = true;
            this._cullMode = Trike.CullFormat.Back;
            this._depthWrite = true;
            this._depthRead = true;
            this._wireframe = false;
            // Create the standard GBuffer
            if (Trike.Utils.checkFlag(defaultSubMaterials, MultiMaterialOptions.CreateGBuffer) ||
                Trike.Utils.checkFlag(defaultSubMaterials, MultiMaterialOptions.CreateDefaults)) {
                this._materials[Trike.PassType.GBuffer] = new Trike.PassMaterial('GBuffer', this);
                this._materials[Trike.PassType.GBuffer].addDefine(Trike.ShaderDefines.PASS_GBUFFER);
            }
            // Create the standard GBuffer2
            if (Trike.Utils.checkFlag(defaultSubMaterials, MultiMaterialOptions.CreateGBuffer2) ||
                Trike.Utils.checkFlag(defaultSubMaterials, MultiMaterialOptions.CreateDefaults)) {
                this._materials[Trike.PassType.GBuffer2] = new Trike.PassMaterial('GBuffer2', this);
                this._materials[Trike.PassType.GBuffer2].addDefine(Trike.ShaderDefines.ATTR_NORMAL);
                this._materials[Trike.PassType.GBuffer2].addAttribute(new AttributeVar('normal', Trike.AttributeType.NORMAL));
                this._materials[Trike.PassType.GBuffer2].addUniform(new UniformVar('normalMatrix', Trike.UniformType.MAT3, new Trike.Matrix3()));
                this._materials[Trike.PassType.GBuffer2].addDefine(Trike.ShaderDefines.PASS_GBUFFER2);
            }
            // Create the shadow buffer
            if (Trike.Utils.checkFlag(defaultSubMaterials, MultiMaterialOptions.CreateShadowLightPass) ||
                Trike.Utils.checkFlag(defaultSubMaterials, MultiMaterialOptions.CreateDefaults)) {
                this._materials[Trike.PassType.ShadowLightPass] = new Trike.PassMaterial('ShadowLightPass', this);
                this._materials[Trike.PassType.ShadowLightPass].addDefine(Trike.ShaderDefines.PASS_SHADOW);
            }
            this._precision = Trike.ShaderPrecision.HIGH;
        }
        /*
        * Sets the vertex and fragment shaders for this material as well as any pass materials
        * @param {string} vShader the vertex shader
        * @param {string} fShader the fragment shader
        */
        MaterialMulti.prototype.setShaders = function (vShader, fShader) {
            this._vertexSource = vShader;
            this._fragmentSource = fShader;
            var materials = this._materials;
            for (var m in materials)
                materials[m].setShaders(vShader, fShader);
            var builder = Trike.ShaderPassBuilder.getSingleton();
            builder.buildPassShaders(materials);
            this.requiresBuild = true;
        };
        /**
        * Sets the material shader source code for the vertex and fragment shaders. Will trigger the material
        * to be re-built.
        */
        MaterialMulti.prototype.createShaders = function () {
            this.requiresBuild = true;
            var vShader = '';
            var fShader = '';
            var defines = '';
            var precision = this.precision.toString();
            // Add the defines
            for (var i = 0, dlen = this._defines.length; i < dlen; i++)
                defines += this._defines[i] + '\n';
            // Name the shader
            vShader += '// Material - ' + (this instanceof Trike.PassMaterial ? this.parentMaterial.constructor.name + ' (' + this.type + ')' : this.constructor.name) + '  -  (vertex shader)\n\n';
            // Prepende capabilities to the fragment shader
            vShader += 'precision ' + precision + ' float;\n';
            vShader += 'precision ' + precision + ' int;\n\n';
            vShader += defines;
            vShader += this._vertexSource;
            fShader += '// Material - ' + (this instanceof Trike.PassMaterial ? this.parentMaterial.constructor.name + ' (' + this.type + ')' : this.constructor.name) + '  -  (fragment shader)\n\n';
            // Prepende capabilities to the fragment shader
            fShader += 'precision ' + precision + ' float;\n';
            fShader += 'precision ' + precision + ' int;\n\n';
            // Add the frag shader structures
            fShader += defines;
            fShader += this._fragmentSource;
            this._rawVertexSource = vShader;
            this._rawFragmentSource = fShader;
        };
        /**
        * Adds a uniform to this material. Will trigger the material to be re-built.
        * @param {UniformVar} val The Uniformconst to add
        * @param {boolean} shared If true, this uniform is added to all sub materials as well
        */
        MaterialMulti.prototype.addUniform = function (val, shared) {
            if (shared === void 0) { shared = true; }
            var uniforms = this._uniforms;
            uniforms[val.name] = val;
            this.requiresBuild = true;
            var shaderTs = this._shaderTextures;
            // Check for shader textures
            if (val.type === Trike.UniformType.TEXTURE && val.value instanceof Trike.ShaderTexture && shaderTs.indexOf(val.value) === -1)
                shaderTs.push(val.value);
            if (shared) {
                var materials = this._materials;
                for (var m in materials)
                    materials[m].addUniform(val.clone());
            }
        };
        /**
        * Removes a uniform from this material. Will trigger the material to be re-built.
        * @param {string} name The name of the uniform
        * @param {boolean} shared If true, this uniform is added to all sub materials as well
        */
        MaterialMulti.prototype.removeUniform = function (name, shared) {
            if (shared === void 0) { shared = true; }
            var uniforms = this._uniforms;
            var uniform = uniforms[name];
            if (!uniforms[name])
                return;
            delete uniforms[name];
            this.requiresBuild = true;
            var shaderTs = this._shaderTextures;
            // Check for shader textures
            if (uniform && uniform.type === Trike.UniformType.TEXTURE && uniform.value instanceof Trike.ShaderTexture && shaderTs.indexOf(uniform.value) !== -1)
                shaderTs.splice(shaderTs.indexOf(uniform.value), 1);
            if (shared) {
                var materials = this._materials;
                for (var m in materials)
                    materials[m].removeUniform(name);
            }
        };
        /**
        * Adds an attribute to this material. Will trigger the material to be re-built.
        * @param {AttributeVar} val The attribute to add to this material and its children
        * @param {boolean} shared If true, the attribute will be added to all sub materials
        */
        MaterialMulti.prototype.addAttribute = function (val, shared) {
            if (shared === void 0) { shared = true; }
            var attributes = this._attributes;
            attributes[val.type] = val;
            this.requiresBuild = true;
            if (shared) {
                var materials = this._materials;
                for (var m in materials)
                    materials[m].addAttribute(val.clone());
            }
        };
        /**
        * Removes an attribute from this material. Will trigger the material to be re-built.
        * @param {AttributeType} val The attribute type to remove from this material and its children
        * @param {boolean} shared If true, the attribute will be removed from all sub materials
        */
        MaterialMulti.prototype.removeAttribute = function (type, shared) {
            if (shared === void 0) { shared = true; }
            var attributes = this._attributes;
            delete attributes[type];
            this.requiresBuild = true;
            if (shared) {
                var materials = this._materials;
                for (var m in materials)
                    materials[m].removeAttribute(type);
            }
        };
        MaterialMulti.prototype.hasDefine = function (val) {
            var defines = this._defines;
            var index = defines.indexOf(val.toString());
            if (index === -1)
                return false;
            return true;
        };
        MaterialMulti.prototype.setDefines = function (val) {
            this._defines = [];
            for (var i = 0, len = val.length; i < len; i++)
                if (val[i] instanceof Trike.ShaderDefines)
                    this._defines.push(val[i].toString());
                else
                    this._defines.push(val[i]);
            this.requiresBuild = true;
            var materials = this._materials;
            for (var m in materials)
                materials[m].setDefines(val);
            var builder = Trike.ShaderPassBuilder.getSingleton();
            builder.buildPassShaders(materials);
        };
        MaterialMulti.prototype.addDefine = function (val) {
            var defines = this._defines;
            var index = defines.indexOf(val.toString());
            if (index !== -1)
                return;
            defines.push(val.toString());
            this.requiresBuild = true;
            var materials = this._materials;
            for (var m in materials)
                materials[m].addDefine(val);
        };
        MaterialMulti.prototype.removeDefine = function (val) {
            var defines = this._defines;
            var index = defines.indexOf(val.toString());
            if (index === -1)
                return;
            defines.splice(index, 1);
            this.requiresBuild = true;
            var materials = this._materials;
            for (var m in materials)
                materials[m].removeDefine(val);
        };
        /**
        * Use this function to set a uniform value on the material.
        * @param {string} name The name of the uniform
        * @param {any} val The new value of the uniform
        * @param {boolean} shared If true, then this value should be applied to all child materials
        */
        MaterialMulti.prototype.setUniform = function (name, val, shared) {
            //  if (this instanceof PassMaterial === false && shared === false)
            //      throw 'NOT ALLOWED';
            if (shared === void 0) { shared = true; }
            var uniforms = this._uniforms;
            var uniform = uniforms[name];
            var shaderTs = this._shaderTextures;
            // If the value is exactly the same, then dont update anything
            if (uniform.value === val)
                return uniform;
            uniform.requiresUpdate = true;
            // Remove old value from shader texture array
            if (uniform.type === Trike.UniformType.TEXTURE && uniform.value instanceof Trike.ShaderTexture && shaderTs.indexOf(uniform.value) !== -1)
                shaderTs.splice(shaderTs.indexOf(uniform.value), 1);
            // Create defaults
            switch (uniform.type) {
                case Trike.UniformType.MAT4:
                    if (uniform.value.equals(val)) {
                        uniform.requiresUpdate = false;
                        return uniform;
                    }
                    uniform.value.copy(val);
                    break;
                case Trike.UniformType.MAT3:
                    if (uniform.value.equals(val)) {
                        uniform.requiresUpdate = false;
                        return uniform;
                    }
                    uniform.value.copy(val);
                    break;
                case Trike.UniformType.FLOAT3:
                    if (uniform.value.equals(val)) {
                        uniform.requiresUpdate = false;
                        return uniform;
                    }
                    uniform.value.copy(val);
                    break;
                case Trike.UniformType.FLOAT4:
                    if (uniform.value.equals(val)) {
                        uniform.requiresUpdate = false;
                        return uniform;
                    }
                    uniform.value.copy(val);
                    break;
                case Trike.UniformType.QUAT:
                    uniform.value.copy(val);
                    break;
                case Trike.UniformType.COLOR3:
                    uniform.value.copy(val);
                    break;
                case Trike.UniformType.FLOAT2:
                    uniform.value.copy(val);
                    break;
                default:
                    uniform.value = val;
                    break;
            }
            // Check for shader textures
            if (uniform.type === Trike.UniformType.TEXTURE && uniform.value instanceof Trike.ShaderTexture && shaderTs.indexOf(uniform.value) === -1)
                shaderTs.push(uniform.value);
            if (shared) {
                var materials = this._materials;
                for (var i in materials)
                    materials[i].setUniform(name, val, false);
            }
            return uniform;
        };
        /**
        * Compiles the vertex and fragment sources into runnable GPU programs. This is an expensive task
        * and should try to be avoided as much as possible.
        * @param {WebGLRenderingContext} gl The context to compile this material with
        */
        MaterialMulti.prototype.compile = function (gl) {
            this._error = false;
            this._compileStatus = '';
            this.requiresBuild = true;
            this.createShaders();
            // Create vertex shader scripts
            this._vertShader = gl.createShader(gl.VERTEX_SHADER);
            var vertexSource = this._rawVertexSource;
            var fragmentSource = this._rawFragmentSource;
            // Set the source and compile
            gl.shaderSource(this._vertShader, vertexSource);
            gl.compileShader(this._vertShader);
            // Check if the vertex shader was compiled
            if (!gl.getShaderParameter(this._vertShader, gl.COMPILE_STATUS)) {
                this._compileStatus = gl.getShaderInfoLog(this._vertShader);
                Trike.Utils.compilerError(this._compileStatus, vertexSource);
                this._error = true;
                return false;
            }
            // Create fragment shader
            this._fragShader = gl.createShader(gl.FRAGMENT_SHADER);
            // Set the source and compile
            gl.shaderSource(this._fragShader, fragmentSource);
            gl.compileShader(this._fragShader);
            // Check if the vertex shader was compiled
            if (!gl.getShaderParameter(this._fragShader, gl.COMPILE_STATUS)) {
                this._compileStatus = gl.getShaderInfoLog(this._fragShader);
                Trike.Utils.compilerError(this._compileStatus, fragmentSource);
                this._error = true;
                return false;
            }
            var program = gl.createProgram();
            gl.attachShader(program, this._vertShader);
            gl.attachShader(program, this._fragShader);
            gl.linkProgram(program);
            this._program = program;
            var isPassMaterial = false;
            var passMaterial;
            if (this instanceof Trike.PassMaterial) {
                isPassMaterial = true;
                passMaterial = this;
            }
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                this._compileStatus = gl.getProgramInfoLog(program);
                Trike.Utils.compilerError(this._compileStatus, vertexSource + fragmentSource);
                this._error = true;
                return false;
            }
            // Now that the program is compiled, we need to fetch the uniform and attribute locations
            var uniforms = this._uniforms;
            var attributes = this._attributes;
            for (var u in uniforms) {
                uniforms[u].location = gl.getUniformLocation(program, uniforms[u].name);
                if (!uniforms[u].location) {
                    if (isPassMaterial) {
                        this._compileStatus = 'A uniform \'' + uniforms[u].name + '\' for the material ' + passMaterial.parentMaterial.constructor.name + ' (' + passMaterial.type + ') was not located. The variable might have been removed as an optimization because it was not used in the program. Please check the shader source code and uniform array.';
                        Trike.Utils.compilerError(this._compileStatus, '');
                        return false;
                    }
                    else {
                        this._compileStatus = 'A uniform \'' + uniforms[u].name + '\' for the material \'' + this.constructor.name + '\' was not located. The variable might have been removed as an optimization because it was not used in the program. Please check the shader source code and uniform array.';
                        Trike.Utils.compilerError(this._compileStatus, '');
                        return false;
                    }
                }
            }
            for (var a in attributes)
                if (attributes[a]) {
                    attributes[a].location = gl.getAttribLocation(program, attributes[a].name);
                    if (attributes[a].location === -1) {
                        if (isPassMaterial) {
                            // The uniform is not located in the shader - so remove it
                            delete this._attributes[a];
                        }
                        else {
                            this._compileStatus = 'An attribute \'' + attributes[a].name + '\' for the material \'' + this.constructor.name + '\' was defined, but doesnt seem to be present in the shader.';
                            Trike.Utils.compilerError(this._compileStatus, '');
                            return false;
                        }
                    }
                }
            this.requiresBuild = false;
            return true;
        };
        /**
        * Cleans up the object.
        */
        MaterialMulti.prototype.dispose = function () {
            MaterialMulti.numMaterials--;
            if (MaterialMulti.numMaterials === 0) {
                for (var i in MaterialMulti.materialPasses)
                    MaterialMulti.materialPasses[i].dispose();
                MaterialMulti.materialPasses = null;
            }
            for (var i in this._materials)
                this._materials[i].dispose();
            this._materials = null;
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(MaterialMulti.prototype, "precision", {
            /**
            * Gets the shader precision.
            * @returns {ShaderPrecision}
            */
            get: function () {
                // 0 = low precision, 1 = medium, 2 = high supported by this graphics card
                var precision = Trike.Capabilities.getSingleton().precision;
                var val = this._precision;
                if (val === Trike.ShaderPrecision.HIGH && precision !== 2) {
                    if (precision === 1)
                        val = Trike.ShaderPrecision.MEDIUM;
                    else
                        val = Trike.ShaderPrecision.LOW;
                }
                if (val === Trike.ShaderPrecision.MEDIUM && precision === 0)
                    val = Trike.ShaderPrecision.LOW;
                return val;
            },
            /**
            * Sets the shader precision.
            * @param {ShaderPrecision} val
            */
            set: function (val) {
                this._precision = val;
                this.requiresBuild = true;
                var materials = this._materials;
                for (var i in materials)
                    materials[i].precision = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialMulti.prototype, "skinning", {
            /**
            * Gets if this material uses skinning
            * @returns {boolean}
            */
            get: function () { return this._skinning; },
            /**
            * Sets if this material uses skinning. This will add/remove the appropriate shader uniforms.
            * @param {boolean} val
            */
            set: function (val) {
                if (!this._skinning && val) {
                    this.addAttribute(new AttributeVar('skinIndex', Trike.AttributeType.SKIN_INDEX));
                    this.addAttribute(new AttributeVar('skinWeight', Trike.AttributeType.SKIN_WEIGHT));
                    this.addUniform(new UniformVar('boneTexture', Trike.UniformType.TEXTURE));
                    this.addUniform(new UniformVar('boneTextureWidth', Trike.UniformType.INT));
                    this.addUniform(new UniformVar('boneTextureHeight', Trike.UniformType.INT));
                    this.addDefine(Trike.ShaderDefines.SKINNING);
                    if (this._numInfluences === -1)
                        this.numInfluences = 2;
                }
                else if (this._skinning && !val) {
                    this.removeAttribute(Trike.AttributeType.SKIN_INDEX);
                    this.removeAttribute(Trike.AttributeType.SKIN_WEIGHT);
                    this.removeUniform('boneTexture');
                    this.removeUniform('boneTextureWidth');
                    this.removeUniform('boneTextureHeight');
                    this.removeDefine(Trike.ShaderDefines.SKINNING);
                }
                this._skinning = val;
                var materials = this._materials;
                for (var i in materials)
                    materials[i].skinning = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialMulti.prototype, "numInfluences", {
            /**
            * Gets the number of bone influences that this material can handle.
            * @returns {number} val
            */
            get: function () { return this._numInfluences; },
            /**
            * Sets the number of bone influences that this material can handle. The default, if none is set, is 2. This cannot be greater than 4 and must
            * be an integer value.
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine(Trike.ShaderDefines.BONE_INFLUENCES_1);
                this.removeDefine(Trike.ShaderDefines.BONE_INFLUENCES_2);
                this.removeDefine(Trike.ShaderDefines.BONE_INFLUENCES_3);
                this.removeDefine(Trike.ShaderDefines.BONE_INFLUENCES_4);
                if (val > 4)
                    throw new Error('You cannot have more than 4 influences');
                if (val === 1)
                    this.addDefine(Trike.ShaderDefines.BONE_INFLUENCES_1);
                if (val === 2)
                    this.addDefine(Trike.ShaderDefines.BONE_INFLUENCES_2);
                if (val === 3)
                    this.addDefine(Trike.ShaderDefines.BONE_INFLUENCES_3);
                if (val === 4)
                    this.addDefine(Trike.ShaderDefines.BONE_INFLUENCES_4);
                this._numInfluences = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialMulti.prototype, "blendMode", {
            /**
            * Gets the current blend mode
            * @returns {BlendMode}
            */
            get: function () { return this._blendMode; },
            /**
            * Sets the blend mode of the material. Blending works on three variables - the source factor, destination factor and blend equation.
            * The source factor can be thought of as the current pixel and the destination is the one that's already in the frame buffer. Typically
            * the equation is to add. The add equation looks something like this:
            *
            * Rresult = Rs * Sr + Rd * Dr
            * Gresult = Gs * Sg + Gd * Dg
            * Bresult = Bs * Sb + Bd * Db
            * Aresult = As * Sa + Ad * Da
            *
            * The source factor is multiplied by the source value and added to the desination value times by its destination factor.
            * In trike there 3 pre-built blend modes. If you want to create your own, simply set this to custom and set the sourceFactor,
            * destinationFactor and blendEquation yourself.
            * @param {BlendMode} val
            */
            set: function (val) {
                if (this._blendMode === val)
                    return;
                if (this._blendMode === Trike.BlendMode.PremultipliedAlpha)
                    this.removeDefine(Trike.ShaderDefines.PREMULTIPLIED_ALPHA);
                this._blendMode = val;
                if (val === Trike.BlendMode.Additive) {
                    this.sourceFactor = Trike.PixelFactor.SourceAlpha;
                    this.destinationFactor = Trike.PixelFactor.One;
                    this.blendEquation = Trike.BlendEquation.Add;
                }
                else if (val === Trike.BlendMode.Subtractive) {
                    this.sourceFactor = Trike.PixelFactor.OneMinusSourceColor;
                    this.destinationFactor = Trike.PixelFactor.Zero;
                    this.blendEquation = Trike.BlendEquation.Add;
                }
                else if (val === Trike.BlendMode.Multiplication) {
                    this.sourceFactor = Trike.PixelFactor.Zero;
                    this.destinationFactor = Trike.PixelFactor.SourceColor;
                    this.blendEquation = Trike.BlendEquation.Add;
                }
                else if (val === Trike.BlendMode.Normal) {
                    this.sourceFactor = Trike.PixelFactor.SourceAlpha;
                    this.destinationFactor = Trike.PixelFactor.OneMinusSourceAlpha;
                    this.blendEquation = Trike.BlendEquation.Add;
                }
                else if (val === Trike.BlendMode.PremultipliedAlpha) {
                    this.sourceFactor = Trike.PixelFactor.One;
                    this.destinationFactor = Trike.PixelFactor.OneMinusSourceAlpha;
                    this.blendEquation = Trike.BlendEquation.Add;
                    this.addDefine(Trike.ShaderDefines.PREMULTIPLIED_ALPHA);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialMulti.prototype, "vertexShader", {
            /**
            * Gets the vertex shader program
            * @returns {WebGLShader}
            */
            get: function () { return this._vertShader; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialMulti.prototype, "fragmentShader", {
            /**
            * Gets the fragment shader program
            * @returns {WebGLShader}
            */
            get: function () { return this._fragShader; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialMulti.prototype, "program", {
            /**
            * Gets the glsl program
            * @returns {WebGLProgram}
            */
            get: function () { return this._program; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialMulti.prototype, "compileStatus", {
            /**
            * Gets the status of the compilation
            * @returns {string}
            */
            get: function () { return this._compileStatus; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialMulti.prototype, "materials", {
            /**
            * Gets the sub materials by their PassType
            * @returns {[pass: number]: PassMaterial}
            */
            get: function () { return this._materials; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialMulti.prototype, "wireframe", {
            /**
            * Gets if this material is wireframe
            * @returns {boolean}
            */
            get: function () { return this._wireframe; },
            /**
            * Sets if this material is wireframe
            * @param {boolean} val
            */
            set: function (val) {
                this._wireframe = val;
                var materials = this._materials;
                for (var i in materials)
                    materials[i]._wireframe = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialMulti.prototype, "depthWrite", {
            /**
            * Gets if this material is writing depth values
            * @returns {boolean}
            */
            get: function () { return this._depthWrite; },
            /**
            * Sets if this material is writing depth values
            * @param {boolean} val
            */
            set: function (val) {
                this._depthWrite = val;
                var materials = this._materials;
                for (var i in materials)
                    materials[i]._depthWrite = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialMulti.prototype, "depthRead", {
            /**
            * Gets if this material is reading depth values
            * @returns {boolean}
            */
            get: function () { return this._depthRead; },
            /**
            * Sets if this material is reading depth values
            * @param {boolean} val
            */
            set: function (val) {
                this._depthRead = val;
                var materials = this._materials;
                for (var i in materials)
                    materials[i]._depthRead = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialMulti.prototype, "cullMode", {
            /**
            * Gets material Cull format
            * @returns {CullFormat}
            */
            get: function () { return this._cullMode; },
            /**
            * Sets material Cull format
            * @param {CullFormat} val
            */
            set: function (val) {
                this._cullMode = val;
                var materials = this._materials;
                for (var i in materials)
                    materials[i].cullMode = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialMulti.prototype, "transparent", {
            /**
            * Gets if this material is transparent
            * @param {boolean} val
            */
            get: function () { return this._transparent; },
            /**
            * Sets if this material is transparent
            * @param {boolean} val
            */
            set: function (val) {
                this._transparent = val;
                var materials = this._materials;
                for (var i in materials)
                    materials[i]._transparent = val;
            },
            enumerable: true,
            configurable: true
        });
        /*
        * Checks the uniforms or attributes of the material after a potentially breaking change
        */
        MaterialMulti.prototype._validate = function () {
        };
        /**
        * Gets or sets the softening filtering method of the shadow map
        * @param val {ShadowSoftener} [Optional]
        * @returns {ShadowSoftener}
        */
        MaterialMulti.prototype.shadowSoftener = function (val) {
            if (val === undefined)
                return this._shadowType;
            this._shadowType = val;
            this.materials[Trike.PassType.GBuffer].removeDefine(Trike.ShaderDefines.SHADOW_FILTER_INTERPOLATED);
            this.materials[Trike.PassType.GBuffer].removeDefine(Trike.ShaderDefines.SHADOW_FILTER_PCF);
            this.materials[Trike.PassType.GBuffer].removeDefine(Trike.ShaderDefines.SHADOW_FILTER_PCF_SOFT);
            if (val === Trike.ShadowSoftener.Interpolated)
                this.materials[Trike.PassType.GBuffer].addDefine(Trike.ShaderDefines.SHADOW_FILTER_INTERPOLATED);
            else if (val === Trike.ShadowSoftener.PCF)
                this.materials[Trike.PassType.GBuffer].addDefine(Trike.ShaderDefines.SHADOW_FILTER_PCF);
            else if (val === Trike.ShadowSoftener.PCFSoft)
                this.materials[Trike.PassType.GBuffer].addDefine(Trike.ShaderDefines.SHADOW_FILTER_PCF_SOFT);
            return val;
        };
        /**
        * Gets or sets the quality of the shadow mapping filtering system
        * @param val {ShadowQuality} [Optional]
        * @returns {ShadowQuality}
        */
        MaterialMulti.prototype.shadowQuality = function (val) {
            if (val === undefined)
                return this._shadowFilter;
            this._shadowFilter = val;
            if (this._shadowFilter === Trike.ShadowQuality.High) {
                this.materials[Trike.PassType.GBuffer].addDefine(Trike.ShaderDefines.SHADOW_TYPE_VSM);
                this.materials[Trike.PassType.ShadowLightPass].addDefine(Trike.ShaderDefines.SHADOW_TYPE_VSM);
                this.materials[Trike.PassType.ShadowLightPass].addDefine(Trike.ShaderDefines.STANDARD_DERIVATIVES);
                this.materials[Trike.PassType.ShadowLightPass].cullMode = Trike.CullFormat.Front;
            }
            else {
                this.materials[Trike.PassType.GBuffer].removeDefine(Trike.ShaderDefines.SHADOW_TYPE_VSM);
                this.materials[Trike.PassType.ShadowLightPass].removeDefine(Trike.ShaderDefines.SHADOW_TYPE_VSM);
                this.materials[Trike.PassType.ShadowLightPass].removeDefine(Trike.ShaderDefines.STANDARD_DERIVATIVES);
                this.materials[Trike.PassType.ShadowLightPass].cullMode = Trike.CullFormat.Back;
            }
            return val;
        };
        /**
        * Gets or sets or the number of shadows this material supports
        * @param val {number} [Optional]
        * @returns {number}
        */
        MaterialMulti.prototype.maxNumShadows = function (val) {
            if (val === undefined)
                return this._maxNumShadows;
            if (val < 0)
                val = 0;
            if (this._maxNumShadows === val)
                return this._maxNumShadows;
            var gBuffer = this.materials[Trike.PassType.GBuffer];
            gBuffer.removeDefine('#define MAX_SHADOWS ' + this._maxNumShadows.toFixed(0));
            this._maxNumShadows = val;
            gBuffer.receivesShadows = false;
            gBuffer.removeDefine(Trike.ShaderDefines.SHADOW_MAPPING);
            gBuffer.removeUniform('shadowMap');
            gBuffer.removeUniform('shadowMapSize');
            gBuffer.removeUniform('shadowBias');
            gBuffer.removeUniform('shadowDarkness');
            gBuffer.removeUniform('shadowMatrix');
            gBuffer.removeUniform('modelMatrix');
            if (val > 0) {
                var uTextures = new Array(val);
                var uShadowSizes = new Array(val);
                var uShadowBiases = new Array(val);
                var uShadowDarknesses = new Array(val);
                var uShadowMatrices = new Trike.UniformArray(new Array(val), 16);
                for (var i = 0; i < val; i++) {
                    uTextures[i] = null;
                    uShadowSizes[i] = 0;
                    uShadowBiases[i] = 0;
                    uShadowDarknesses[i] = 0;
                    uShadowMatrices.values[i] = new Trike.Matrix4();
                }
                gBuffer.receivesShadows = true;
                gBuffer.addUniform(new UniformVar('shadowMap', Trike.UniformType.TEXTURE_ARRAY, uTextures));
                gBuffer.addUniform(new UniformVar('shadowMapSize', Trike.UniformType.FLOAT_ARRAY, uShadowSizes));
                gBuffer.addUniform(new UniformVar('shadowBias', Trike.UniformType.FLOAT_ARRAY, uShadowBiases));
                gBuffer.addUniform(new UniformVar('shadowDarkness', Trike.UniformType.FLOAT_ARRAY, uShadowDarknesses));
                gBuffer.addUniform(new UniformVar('modelMatrix', Trike.UniformType.MAT4));
                gBuffer.addUniform(new UniformVar('shadowMatrix', Trike.UniformType.MAT4_ARRAY, uShadowMatrices));
                gBuffer.addDefine(Trike.ShaderDefines.SHADOW_MAPPING);
                gBuffer.addDefine('#define MAX_SHADOWS ' + this._maxNumShadows.toFixed(0));
                this.shadowQuality(this._shadowFilter);
            }
            this._validate();
        };
        MaterialMulti.numMaterials = 0;
        return MaterialMulti;
    }(Trike.EventDispatcher));
    Trike.MaterialMulti = MaterialMulti;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Low level materials that do not contain any child materials. Typically generated by
    * other materials.
    */
    var PassMaterial = (function (_super) {
        __extends(PassMaterial, _super);
        /**
        * Creates a new pass material instance
        */
        function PassMaterial(type, parent) {
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.type = type;
            this.parentMaterial = parent;
        }
        /**
        * Cleans up the material
        */
        PassMaterial.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.parentMaterial = null;
        };
        /**
        * Use this function to set a uniform value on the material.
        * @param {string} name The name of the uniform
        * @param {any} val The new value of the uniform
        * @param {boolean} shared If true, then this value should be applied to all child materials
        */
        PassMaterial.prototype.setUniform = function (name, val, shared) {
            if (shared === void 0) { shared = true; }
            var uniforms = this._uniforms;
            var uniform = uniforms[name];
            var shaderTs = this.parentMaterial._shaderTextures;
            // If the value is exactly the same, then dont update anything
            if (uniform.value === val)
                return uniform;
            // Remove old value from shader texture array
            if (uniform.type === Trike.UniformType.TEXTURE && uniform.value instanceof Trike.ShaderTexture && shaderTs.indexOf(uniform.value) !== -1)
                shaderTs.splice(shaderTs.indexOf(uniform.value), 1);
            var toRet = _super.prototype.setUniform.call(this, name, val, shared);
            // Check for shader textures
            if (uniform.type === Trike.UniformType.TEXTURE && uniform.value instanceof Trike.ShaderTexture && shaderTs.indexOf(uniform.value) === -1)
                shaderTs.push(uniform.value);
            return toRet;
        };
        /**
        * Adds a uniform to this material. Will trigger the material to be re-built.
        */
        PassMaterial.prototype.addUniform = function (val, shared) {
            if (shared === void 0) { shared = true; }
            _super.prototype.addUniform.call(this, val, shared);
            var shaderTs = this.parentMaterial._shaderTextures;
            // Check for shader textures
            if (val.type === Trike.UniformType.TEXTURE && val.value instanceof Trike.ShaderTexture && shaderTs.indexOf(val.value) === -1)
                shaderTs.push(val.value);
        };
        /**
        * Removes a uniform from this material. Will trigger the material to be re-built.
        */
        PassMaterial.prototype.removeUniform = function (name, shared) {
            if (shared === void 0) { shared = true; }
            var uniform = this._uniforms[name];
            _super.prototype.removeUniform.call(this, name, shared);
            var shaderTs = this.parentMaterial._shaderTextures;
            // Check for shader textures
            if (uniform && uniform.type === Trike.UniformType.TEXTURE && uniform.value instanceof Trike.ShaderTexture && shaderTs.indexOf(uniform.value) !== -1)
                shaderTs.splice(shaderTs.indexOf(uniform.value), 1);
        };
        return PassMaterial;
    }(Trike.MaterialMulti));
    Trike.PassMaterial = PassMaterial;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Shader code snippets
    */
    var ShaderFragments;
    (function (ShaderFragments) {
        var LightingFunctions = (function () {
            function LightingFunctions() {
            }
            /**
            * http://www.standardabweichung.de/code/javascript/webgl-glsl-fresnel-schlick-approximation
            * The Fresnal function returns higher values when the view is perpendicular to the surface
            * In water this is like viewing from the top and its non-reflective, and then viewing it
            * from the surface and it is.
            */
            LightingFunctions.fresnel = function () {
                return "\n\t\t\t\tfloat fresnel(vec3 direction, vec3 normal, float fresnelPower, bool invert)\n\t\t\t\t{\n\t\t\t\t\tvec3 nDirection = normalize(direction);\n\t\t\t\t\tvec3 nNormal = normalize(normal);\n\t\t\t\t\tvec3 halfDirection = normalize(nNormal + nDirection);\n\n\t\t\t\t\tfloat cosine = dot(halfDirection, nDirection);\n\t\t\t\t\tfloat product = max(cosine, 0.0);\n\t\t\t\t\tfloat factor = invert ? 1.0 - pow(product, fresnelPower) : pow(product, fresnelPower);\n\n\t\t\t\t\treturn factor;\n\t\t\t\t}\n\t\t\t";
            };
            return LightingFunctions;
        }());
        ShaderFragments.LightingFunctions = LightingFunctions;
        /**
        * Shader code snippets for fragment parameters
        */
        var ShadowMapping = (function () {
            function ShadowMapping() {
            }
            /**
            * Vertex shadow map params
            */
            ShadowMapping.vertParams = function () {
                return "\n\t\t\t\t#ifdef SHADOW_MAPPING\n                \tvarying vec4 vShadowCoord[MAX_SHADOWS];\n                \tvarying vec4 vShadowWorldPos[MAX_SHADOWS];\n\t\t\t\t\tuniform mat4 shadowMatrix[MAX_SHADOWS];\n                #endif\n\t\t\t";
            };
            /**
            * Vertex shadow map main
            */
            ShadowMapping.vertMain = function () {
                return "\n\t\t\t\t#ifdef SHADOW_MAPPING\n                \tfor(int i = 0; i < MAX_SHADOWS; i ++ )\n\t\t\t\t\t{\n                \t\tvShadowCoord[i] = shadowMatrix[i] * worldPosition;\n                \t\tvShadowWorldPos[i] = worldPosition;\n                \t\tshadowMatrix[i] * worldPosition;\n\t\t\t\t\t}\n                #endif\n\t\t\t";
            };
            /**
            * Fragment shadow map params
            */
            ShadowMapping.fragParams = function () {
                return "\n\t\t\t\t#ifdef SHADOW_MAPPING\n\n                \tuniform sampler2D shadowMap[MAX_SHADOWS];\n                \tuniform float shadowMapSize[MAX_SHADOWS];\n                \tuniform float shadowDarkness[MAX_SHADOWS];\n                \tuniform float shadowBias[MAX_SHADOWS];\n                \tvarying vec4 vShadowCoord[MAX_SHADOWS];\n                \tvarying vec4 vShadowWorldPos[MAX_SHADOWS];\n\n                \t#if defined(SHADOW_TYPE_VSM)\n\n                \t\tconst float positiveExponent = 40.0;\n                \t\tconst float negativeExponent = 5.0;\n                \t\tvec2 exponents = vec2(positiveExponent, negativeExponent);\n\n                \t\tvec2 warpDepth(float depth)\n                \t\t{\n                \t\t\tdepth = 2.0 * depth - 1.0;\n                \t\t\tfloat pos = exp(exponents.x * depth);\n                \t\t\tfloat neg = -exp(-exponents.y * depth);\n                \t\t\tvec2 wDepth = vec2(pos, neg);\n                \t\t\treturn wDepth;\n                \t\t}\n\n                \t\tfloat Chebyshev(vec2 moments, float mean, float minVariance )\n                \t\t{\n                \t\t\tfloat shadow = 1.0;\n                \t\t\tif ( mean <= moments.x )\n                \t\t\t{\n                \t\t\t\tshadow = 1.0;\n                \t\t\t\treturn shadow;\n                \t\t\t}\n                \t\t\telse\n                \t\t\t{\n                \t\t\t\tfloat variance = moments.y - (moments.x * moments.x);\n                \t\t\t\tvariance = max(variance, minVariance);\n                \t\t\t\tfloat d = mean - moments.x;\n                \t\t\t\tshadow = variance / (variance + (d * d));\n                \t\t\t\treturn shadow;\n                \t\t\t}\n                \t\t}\n\n                \t#else\n\n                \t\t#if !defined(SHADOW_TYPE_VSM)\n\n                \t\t\tfloat unpackDepth( const in vec4 rgba_depth )\n                \t\t\t{\n                \t\t\t\tconst vec4 bit_shift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n                \t\t\t\tfloat depth = dot(rgba_depth, bit_shift);\n                \t\t\t\treturn depth;\n                \t\t\t}\n\n                \t\t#endif\n\n                \t\t#if defined(SHADOW_FILTER_PCF) || defined(SHADOW_FILTER_INTERPOLATED) || defined(SHADOW_FILTER_PCF_SOFT)\n\n\t\t\t\t\t\t\tfloat texture2DCompare(sampler2D depths, vec2 uv, float compare)\n                \t\t\t{\n                \t\t\t\tvec4 depthSample = texture2D(depths, uv);\n                \t\t\t\tfloat depth = unpackDepth(depthSample);\n                \t\t\t\treturn step(compare, depth);\n                \t\t\t}\n\n                \t\t#endif\n\n                \t\t#if defined(SHADOW_FILTER_PCF_SOFT) || defined(SHADOW_FILTER_INTERPOLATED)\n\n                \t\t\tfloat texture2DShadowLerp(sampler2D depths, vec2 size, vec2 uv, float compare)\n                \t\t\t{\n                \t\t\t\tvec2 texelSize = vec2(1.0) / size;\n                \t\t\t\tvec2 f = fract(uv * size + 0.5);\n                \t\t\t\tvec2 centroidUV = floor(uv * size + 0.5) / size;\n\n                \t\t\t\tfloat lb = texture2DCompare(depths, centroidUV + texelSize * vec2(0.0, 0.0), compare);\n                \t\t\t\tfloat lt = texture2DCompare(depths, centroidUV + texelSize * vec2(0.0, 1.0), compare);\n                \t\t\t\tfloat rb = texture2DCompare(depths, centroidUV + texelSize * vec2(1.0, 0.0), compare);\n                \t\t\t\tfloat rt = texture2DCompare(depths, centroidUV + texelSize * vec2(1.0, 1.0), compare);\n                \t\t\t\tfloat a = mix(lb, lt, f.y);\n                \t\t\t\tfloat b = mix(rb, rt, f.y);\n                \t\t\t\tfloat c = mix(a, b, f.x);\n                \t\t\t\treturn c;\n                \t\t\t}\n\n                \t\t#endif\n\n                \t\t#if defined(SHADOW_FILTER_PCF)\n\n                \t\t\tfloat PCF(sampler2D depths, vec2 size, vec2 uv, float compare)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfloat result = 0.0;\n\n                \t\t\t\tresult += texture2DCompare(depths, uv + vec2(-1.0, -1.0) / size, compare);\n                \t\t\t\tresult += texture2DCompare(depths, uv + vec2(-1.0, 0.0) / size, compare);\n                \t\t\t\tresult += texture2DCompare(depths, uv + vec2(-1.0, 1.0) / size, compare);\n\n                \t\t\t\tresult += texture2DCompare(depths, uv + vec2(0.0, -1.0) / size, compare);\n                \t\t\t\tresult += texture2DCompare(depths, uv + vec2(0.0, 0.0) / size, compare);\n                \t\t\t\tresult += texture2DCompare(depths, uv + vec2(0.0, 1.0) / size, compare);\n\n                \t\t\t\tresult += texture2DCompare(depths, uv + vec2(1.0, -1.0) / size, compare);\n                \t\t\t\tresult += texture2DCompare(depths, uv + vec2(1.0, 0.0) / size, compare);\n                \t\t\t\tresult += texture2DCompare(depths, uv + vec2(1.0, 1.0) / size, compare);\n\n\t\t\t\t\t\t\t\treturn result / 9.0;\n\t\t\t\t\t\t\t}\n\n                \t\t#endif\n\n                \t\t#if defined(SHADOW_FILTER_PCF_SOFT)\n\n                \t\t\tfloat PCFInterpolated(sampler2D depths, vec2 size, vec2 uv, float compare)\n                \t\t\t{\n                \t\t\t\tfloat result = 0.0;\n\n                \t\t\t\tresult += texture2DShadowLerp(depths, size, uv + vec2(-1.0, -1.0) / size, compare);\n                \t\t\t\tresult += texture2DShadowLerp(depths, size, uv + vec2(-1.0, 0.0) / size, compare);\n                \t\t\t\tresult += texture2DShadowLerp(depths, size, uv + vec2(-1.0, 1.0) / size, compare);\n\n                \t\t\t\tresult += texture2DShadowLerp(depths, size, uv + vec2(0.0, -1.0) / size, compare);\n                \t\t\t\tresult += texture2DShadowLerp(depths, size, uv + vec2(0.0, 0.0) / size, compare);\n                \t\t\t\tresult += texture2DShadowLerp(depths, size, uv + vec2(0.0, 1.0) / size, compare);\n\n                \t\t\t\tresult += texture2DShadowLerp(depths, size, uv + vec2(1.0, -1.0) / size, compare);\n                \t\t\t\tresult += texture2DShadowLerp(depths, size, uv + vec2(1.0, 0.0) / size, compare);\n                \t\t\t\tresult += texture2DShadowLerp(depths, size, uv + vec2(1.0, 1.0) / size, compare);\n\n                \t\t\t\treturn result / 9.0;\n                \t\t\t}\n\n                \t\t#endif\n                \t#endif\n                #endif\n\t\t\t";
            };
            /**
            * Fragment shadow map main
            */
            ShadowMapping.fragMain = function () {
                return "\n\t\t\t\t#ifdef SHADOW_MAPPING\n\n\t\t\t\t\tfloat shadowAmount = 1.0;\n\n\t\t\t\t\tfor(int i = 0; i < MAX_SHADOWS; i ++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tvec3 shadowCoord = vShadowCoord[i].xyz / vShadowCoord[i].w;\n\t\t\t\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t\t\t\t\t// if ( all( something, something ) ) using this instead\n\t\t\t\t\t\tbvec4 inFrustumVec = bvec4(shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0);\n\t\t\t\t\t\tbool inFrustum = all(inFrustumVec);\n\n\t\t\t\t\t\t// don't shadow pixels outside of light frustum\n\t\t\t\t\t\t// use just first frustum (for cascades)\n\t\t\t\t\t\t// don't shadow pixels behind far plane of light frustum\n\t\t\t\t\t\tbool frustumTest = all( bvec2(inFrustum, shadowCoord.z <= 1.0) );\n\n\t\t\t\t\t\tif(frustumTest)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// http://gamedev.stackexchange.com/questions/66030/exponential-variance-shadow-mapping-implementation\n\t\t\t\t\t\t\t#if defined(SHADOW_TYPE_VSM)\n\t\t\t\t\t\t\t\t// Suppress warnings\n                \t\t\t\tshadowMapSize;\n\t\t\t\t\t\t\t\tvec4 moments = texture2D(shadowMap[i], shadowCoord.xy);\n\t\t\t\t\t\t\t\tvec2 posMoments = vec2(moments.x, moments.z);\n\t\t\t\t\t\t\t\tvec2 negMoments = vec2(moments.y, moments.w);\n\t\t\t\t\t\t\t\tvec2 wDepth = warpDepth(shadowCoord.z);\n                \t\t\t\tvec2 depthScale = shadowBias[i] * exponents * wDepth;\n\t\t\t\t\t\t\t\tvec2 minVariance = depthScale * depthScale;\n\t\t\t\t\t\t\t\tfloat posResult = Chebyshev(posMoments, wDepth.x, minVariance.x );\n\t\t\t\t\t\t\t\tfloat negResult = Chebyshev(negMoments, wDepth.y, minVariance.y );\n\t\t\t\t\t\t\t\tfloat shadow = min(posResult, negResult);\n\t\t\t\t\t\t\t\tshadowAmount = shadowAmount * clamp( shadow + (1.0 - shadowDarkness[i]), 0.0, 1.0 );\n\n\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t// Interpolated Filtering\n\t\t\t\t\t\t\t\t#if defined(SHADOW_FILTER_INTERPOLATED)\n                \t\t\t\t\tfloat illuminated = texture2DShadowLerp( shadowMap[i], vec2(shadowMapSize[i]), shadowCoord.xy, shadowCoord.z + shadowBias[i] );\n\t\t\t\t\t\t\t\t\tshadowAmount = shadowAmount * clamp( illuminated + ( 1.0 - shadowDarkness[i] ), 0.0, 1.0 );\n\n\t\t\t\t\t\t\t\t// PCF Filtering\n                \t\t\t\t#elif defined(SHADOW_FILTER_PCF)\n                \t\t\t\t\tfloat illuminated = PCF( shadowMap[i], vec2(shadowMapSize[i]), shadowCoord.xy, shadowCoord.z + shadowBias[i] );\n                \t\t\t\t\tshadowAmount = shadowAmount * clamp( illuminated + ( 1.0 - shadowDarkness[i] ), 0.0, 1.0 );\n\n\t\t\t\t\t\t\t\t// PCF Interpolated Filtering\n                \t\t\t\t#elif defined(SHADOW_FILTER_PCF_SOFT)\n                \t\t\t\t\tfloat illuminated = PCFInterpolated( shadowMap[i], vec2(shadowMapSize[i]), shadowCoord.xy, shadowCoord.z + shadowBias[i] );\n                \t\t\t\t\tshadowAmount = shadowAmount * clamp( illuminated + ( 1.0 - shadowDarkness[i] ), 0.0, 1.0 );\n\n\t\t\t\t\t\t\t\t// No Filtering\n                \t\t\t\t#else\n                \t\t\t\t\tshadowMapSize; // Suppress warnings\n                \t\t\t\t\tvec4 rgbaDepth = texture2D(shadowMap[i], shadowCoord.xy);\n                \t\t\t\t\tfloat fDepth = unpackDepth(rgbaDepth);\n                \t\t\t\t\tif( fDepth < shadowCoord.z + shadowBias[i] )\n                \t\t\t\t\t\tshadowAmount = shadowAmount * ( 1.0 - shadowDarkness[i] );\n\n                \t\t\t\t#endif\n                \t\t\t#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t";
            };
            return ShadowMapping;
        }());
        ShaderFragments.ShadowMapping = ShadowMapping;
        /**
        * Shader code snippets for fragment parameters
        */
        var FragParams = (function () {
            function FragParams() {
            }
            /**
            * Diffuse map params
            */
            FragParams.map = function () {
                return "\n\t\t\t\t#ifdef USE_MAP\n\t\t\t\t\t\tuniform sampler2D map;\n\t\t\t\t#endif\n\t\t\t\t";
            };
            /**
            * Tone mapping params
            */
            FragParams.toneMapping = function () {
                return "\n\t\t\t\t\tuniform float brightness;\n\t\t\t\t\t#if defined( TONEMAP_UNCHARTED )\n                \t\tconst float A = 0.15;\n                \t\tconst float B = 0.50;\n                \t\tconst float C = 0.10;\n                \t\tconst float D = 0.20;\n                \t\tconst float E = 0.02;\n                \t\tconst float F = 0.30;\n                \t\tuniform float whiteValue;\n                \t\tvec3 tonemap(vec3 x)\n                \t\t{\n                \t\t\treturn ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;\n                \t\t}\n\t\t\t\t\t#endif\n\t\t\t\t";
            };
            /**
            * Code that defines the corners of the frustum.
            * See http://mynameismjp.wordpress.com/2009/03/10/reconstructing-position-from-depth/
            */
            FragParams.frustumCorners = function () {
                return "\n\t\t\t\t\tvarying vec3 frustumCorner;\n\t\t\t\t";
            };
            /**
            * Code to get eye to pixel ray in viewspace
            */
            FragParams.eyeRayVS = function () {
                return "\n\t\t\t\tuniform mat4 invProjectionMatrix;\n\n                vec3 eyeRayVS( float frameWidth, float frameHeight )\n\t\t\t\t{\n                \tvec2 fragCoordinate = gl_FragCoord.xy / vec2(frameWidth, frameHeight);\n                \tfragCoordinate = ( fragCoordinate - 0.5 ) * 2.0;\n                \tvec4 deviceNormal = vec4( fragCoordinate, 0.0, 1.0);\n                \tvec3 eyeDirection = normalize((invProjectionMatrix * deviceNormal).xyz);\n                \treturn eyeDirection;\n                }\n\t\t\t";
            };
            /**
            * dashed line parameters
            */
            FragParams.dashes = function () {
                return "\n\t\t\t\t#ifdef DASH\n\t\t\t\t    uniform float dashAmount;\n\t\t\t\t    varying float lengthSoFar;\n\t\t\t\t#endif\n\t\t\t";
            };
            /**
            * The common uniform and varying declarations used by fragment shaders.
            * These can be turned on and off by using DEFINE statements.
            */
            FragParams.defaults = function () {
                return "\n\t\t\t\t\t#ifdef STANDARD_DERIVATIVES\n\t\t\t\t\t\t#extension GL_OES_standard_derivatives : enable\n\t\t\t\t\t\t#extension OES_half_float_linear : enable\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef ATTR_COLOR\n\t\t\t\t\t\tvarying vec4 vColor;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef ATTR_UV\n\t\t\t\t\t\tvarying vec2 vUv;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef ATTR_NORMAL\n\t\t\t\t\t\tvarying vec3 vNormal;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if defined(ATTR_NORMAL) || defined(FORWARD_NORMAL)\n\t\t\t\t\t\tvarying vec3 normalView;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef USE_BUMPMAP\n                \t\tvarying vec3 vViewPosition;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if defined(REFRACTION_MAP) || defined(REFLECTION_MAP)\n\t\t\t\t\t\tvarying vec4 clipPos;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if defined(PASS_GBUFFER2)\n\t\t\t\t\t\tvarying float vDepth;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if defined(PASS_GBUFFER)\n\n                \t\t#if defined(REFRACTION_MAP) || defined(REFLECTION_MAP)\n                \t\t\tuniform float viewHeight;\n                \t\t\tuniform float viewWidth;\n                \t\t#endif\n\n\t\t\t\t\t#elif defined(PASS_GBUFFER2)\n\t\t\t\t\t\tuniform float opacity;\n\n                \t\t#ifdef TRANSLUCENCY_ENABLED\n                \t\t\tuniform float translucencyScale;\n                \t\t\tuniform float translucencyDistortion;\n                \t\t\tuniform float translucencyPower;\n                \t\t\t#ifdef TRANSLUCENCY_MAP\n                \t\t\t\tuniform sampler2D translucencyMap;\n                \t\t\t#endif\n                \t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if defined(PASS_SHADOW) && !defined(SHADOW_TYPE_VSM)\n\n                \t\tvec4 pack_depth( const in float depth )\n\t\t\t\t\t\t{\n                \t\t\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n                \t\t\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n                \t\t\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n                \t\t\tres -= res.xxyz * bit_mask;\n                \t\t\treturn res;\n                \t\t}\n\n\t\t\t\t\t#endif\n\t\t\t\t";
            };
            /**
            * The common uniform and varying declarations used by fragment shaders for custom clip mapping
            */
            FragParams.clippingParams = function () {
                return "\n\t\t\t\t\tvarying vec4 vEyePosition;\n\t\t\t\t\tuniform float customClipping;\n\t\t\t\t\tuniform vec4 customClipPlane;\n\t\t\t\t";
            };
            /**
            * Reflection parameter declarations
            */
            FragParams.reflectionParams = function () {
                return "\n\t\t\t\t\t#ifdef REFLECTION_MAP\n                \t\tuniform sampler2D reflectionSampler;\n                \t\tuniform float mirrorDistortion;\n                \t\tuniform float mirrorReflectivity;\n                \t\tvarying vec4 mirrorCoord;\n\t\t\t\t\t#endif\n\t\t\t\t";
            };
            /**
            * Refraction parameter declarations
            */
            FragParams.refractionParams = function () {
                return "\n\t\t\t\t\t#ifdef REFRACTION_MAP\n\t\t\t\t\t\t\tuniform sampler2D gBuffer2;\n                \t\t\tuniform sampler2D compositionPass;\n                \t\t\tuniform float refractionDistortion;\n                \t\t\tuniform float refractionReflectivity;\n                \t\t\tuniform float cameraFar;\n                \t\t#endif\n\t\t\t\t";
            };
            /**
            * Bump Map parameter declarations
            */
            FragParams.bumpmapUniforms = function () {
                return "\n\t\t\t\t\t#ifdef USE_BUMPMAP\n\t\t\t\t\t\tuniform sampler2D bumpMap;\n\t\t\t\t\t\tuniform float bumpScale;\n\t\t\t\t\t#endif\n\t\t\t\t";
            };
            FragParams.saturate = function () {
                return "\n\t\t\t\tvec3 saturate(vec3 rgb, float adjustment)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Algorithm from Chapter 16 of OpenGL Shading Language\n                \t\tconst vec3 W = vec3(0.2125, 0.7154, 0.0721);\n                \t\tvec3 intensity = vec3(dot(rgb, W));\n                \t\treturn mix(intensity, rgb, adjustment);\n\t\t\t\t\t}\n\t\t\t\t";
            };
            /**
            * Encodes a 3d normalized normal and makes it into a 2d spherical normal
            * http://mynameismjp.wordpress.com/2009/06/17/storing-normals-using-spherical-coordinates/
            */
            FragParams.encodeNormal = function () {
                return "\n\t\t\t\t\tvec2 encodeNormalCrysis( vec3 cartesian )\n\t\t\t\t\t{\n\t\t\t\t\t\tvec2 spherical;\n\t\t\t\t\t\tspherical.x = atan( cartesian.y, cartesian.x ) / 3.14159;\n\t\t\t\t\t\tspherical.y = cartesian.z;\n\t\t\t\t\t\treturn spherical * 0.5 + 0.5;\n\t\t\t\t\t}\n\n\t\t\t\t\t// encodes a 3 component normal vector to a 2 component normal vector\n\t\t\t\t\t//(untested - you may need to swap the normal http://pixellight.sourceforge.net/docs/PixelLightCompositing.pdf)\n\t\t\t\t\tvec2 encodeNormalVector( vec3 normal )\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat p = sqrt( normal.z * 8.0 + 8.0);\n\t\t\t\t\t\treturn vec2( normal.xy / p + 0.5 );\n\t\t\t\t\t}\n\t\t\t\t";
            };
            /**
            * Takes a 2d spherical and converts it to a 3d cartesian one
            * http://mynameismjp.wordpress.com/2009/06/17/storing-normals-using-spherical-coordinates/
            */
            FragParams.decodeNormal = function () {
                return "\n\t\t\t\t\tvec3 decodeNormalCrysis( vec2 spherical )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec2 sinCosTheta, sinCosPhi;\n\n\t\t\t\t\t\t\tspherical = spherical * 2.0 - 1.0;\n\t\t\t\t\t\t\tfloat angle = spherical.x * 3.14159;\n\t\t\t\t\t\t\tsinCosTheta.x = sin(angle);\n\t\t\t\t\t\t\tsinCosTheta.y = cos(angle);\n\t\t\t\t\t\t\tsinCosPhi = vec2( sqrt( 1.0 - spherical.y * spherical.y ), spherical.y);\n\n\t\t\t\t\t\t\treturn vec3( sinCosTheta.y * sinCosPhi.x, sinCosTheta.x * sinCosPhi.x, sinCosPhi.y );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// decodes a 2 component normal vector to a 3 component normal vector\n\t\t\t\t\t\t//(untested - you may need to swap the normal http://pixellight.sourceforge.net/docs/PixelLightCompositing.pdf)\n\t\t\t\t\t\tvec3 decodeNormalVector( vec2 normal )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec2 fenc = normal * 4.0 - 2.0;\n\t\t\t\t\t\t\tfloat f = dot(fenc, fenc);\n\t\t\t\t\t\t\tfloat g = sqrt( 1.0 - f / 4.0 );\n\t\t\t\t\t\t\tvec3 n;\n\t\t\t\t\t\t\tn.xy = fenc * g;\n\t\t\t\t\t\t\tn.z = 1.0 - f / 2.0;\n\t\t\t\t\t\t\treturn n;\n\t\t\t\t\t\t}\n\t\t\t\t";
            };
            /**
            * Code that converts a Vec3 to a float in a shader
            */
            FragParams.vecToFloat = function () {
                return "\n\t\t\t\t\tconst float unit = 255.0/256.0;\n\n\t\t\t\t\tfloat vec3_to_float( vec3 data )\n\t\t\t\t\t{\n\t\t\t\t\t\t//\tIn order for the compression to work, the data must be in the 0 to 1 range\n\t\t\t\t\t\tvec3 compressedData = clamp(data, vec3(0.0), vec3(1.0));\n                \t\tcompressedData = 0.999 * compressedData;\n\t\t\t\t\t\thighp float compressed = fract( compressedData.x * unit ) + floor( compressedData.y * unit * 255.0 ) + floor( compressedData.z * unit * 255.0 ) * 255.0;\n\t\t\t\t\t\treturn compressed;\n\t\t\t\t\t}\n\t\t\t\t";
            };
            /**
            * Code that converts a float to a Vec3 in a shader
            */
            FragParams.floatToVec = function () {
                return "\n\t\t\t\tvec3 float_to_vec3( float data )\n\t\t\t\t\t{\n\t\t\t\t\t\tvec3 uncompressed;\n\t\t\t\t\t\tuncompressed.x = fract( data );\n\t\t\t\t\t\tfloat zInt = floor( data / 255.0 );\n\t\t\t\t\t\tuncompressed.z = fract( zInt / 255.0 );\n\t\t\t\t\t\tuncompressed.y = fract( floor( data - ( zInt * 255.0 ) ) / 255.0 );\n\t\t\t\t\t\treturn uncompressed;\n\t\t\t\t\t}\n\t\t\t\t";
            };
            /**
            * Bump Map parameter declarations
            */
            FragParams.bumpmapFunctions = function () {
                return "\n\t\t\t#ifdef USE_BUMPMAP\n\n\t\t\t\t\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n\t\t\t\t\t// http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\t\t\t\t\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\t\t\t\t\tvec2 dHdxy_fwd( vec2 uv, sampler2D bumps, float bScale )\n\t\t\t\t\t{\n\t\t\t\t\t\tvec2 dSTdx = dFdx( uv );\n\t\t\t\t\t\tvec2 dSTdy = dFdy( uv );\n\t\t\t\t\t\tfloat Hll = bScale * texture2D( bumps, uv ).x;\n\t\t\t\t\t\tfloat dBx = bScale * texture2D( bumps, uv + dSTdx ).x - Hll;\n\t\t\t\t\t\tfloat dBy = bScale * texture2D( bumps, uv + dSTdy ).x - Hll;\n\t\t\t\t\t\treturn vec2( dBx, dBy );\n\t\t\t\t\t}\n\n\n\t\t\t\t\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy )\n\t\t\t\t\t{\n\t\t\t\t\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\t\t\t\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\t\t\t\t\tvec3 vN = surf_norm;\n\n\t\t\t\t\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\t\t\t\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\t\t\t\t\tfloat fDet = dot( vSigmaX, R1 );\n\n\t\t\t\t\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\t\t\t\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\t\t\t";
            };
            /**
            * Environment map parameters
            */
            FragParams.environmentMapping = function () {
                return "\n\t\t\t\t#ifdef USE_ENV_MAP\n                \t\tvarying vec3 vWorldPosition;\n                \t\tuniform float chromeReflectivity;\n                \t\tuniform samplerCube envMap;\n                \t\tuniform float flipEnvMap;\n                \t\tuniform int combine;\n                \t\tuniform float useRefract;\n                \t\tuniform float refractionRatio;\n                \t\tuniform vec3 cameraPosition;\n\t\t\t\t\t\tuniform mat4 viewMatrix;\n\t\t\t\t\t#endif\n\t\t\t\t";
            };
            return FragParams;
        }());
        ShaderFragments.FragParams = FragParams;
        /**
        * Shader code snippets for the fragment shader main function
        */
        var FragMain = (function () {
            function FragMain() {
            }
            /**
            * Disregards fragments for a custom clip plane
            */
            FragMain.clippingTest = function () {
                return "\n\t\t\t\t\tif ( customClipping == 1.0 && dot( vEyePosition, customClipPlane ) < 0.0 ) discard;\n\t\t\t\t";
            };
            /**
            * Tone mapping params
            */
            FragMain.toneMapping = function () {
                return "\n\t\t\t\t\t// http://filmicgames.com/archives/75\n                \tvec3 preToneMap = gl_FragColor.xyz;\n                \tpreToneMap *= brightness;\n                \tvec3 postToneMap;\n\n                \t#if defined( TONEMAP_SIMPLE )\n                \t\tpostToneMap = sqrt( preToneMap );\n                \t#elif defined( TONEMAP_LINEAR )\n                \t\tpostToneMap = pow( preToneMap, vec3( 1.0 / 2.2 ) );\n                \t#elif defined( TONEMAP_REINHARD )\n                \t\tpreToneMap = preToneMap / ( 1.0 + preToneMap );\n                \t\tpostToneMap = pow( preToneMap, vec3( 1.0 / 2.2 ) );\n                \t#elif defined( TONEMAP_FILMIC )\n                \t\tvec3 x = max( vec3( 0.0 ), preToneMap - 0.004 );\n                \t\tpostToneMap = ( x * ( 6.2 * x + 0.5 ) ) / ( x * ( 6.2 * x + 1.7 ) + 0.06 );\n                \t#elif defined( TONEMAP_UNCHARTED )\n                \t\tfloat ExposureBias = 2.0;\n                \t\tvec3 curr = tonemap(ExposureBias * preToneMap );\n                \t\tvec3 whiteScale = vec3(1.0) / tonemap(vec3(whiteValue));\n                \t\tvec3 color = curr * whiteScale;\n                \t\tpostToneMap = pow(color, vec3(1.0 / 2.2));\n                \t#else\n                \t\tpostToneMap = pow( preToneMap, vec3(1.0 / 2.2));;\n                \t#endif\n\n\t\t\t\t\tgl_FragColor.xyz = postToneMap;\n\t\t\t\t";
            };
            /**
            * Adds reflection contributions to a texelColor
            */
            FragMain.reflection = function () {
                return "\n\t\t\t\t\t#ifdef REFLECTION_MAP\n\t\t\t\t\t\tvec2 mirrorDistortedUV = (normal.xz * mirrorDistortion);\n\n                \t\tvec4 r2Distortion = vec4( mirrorDistortedUV.x, 0.0, mirrorDistortedUV.y, 0.0 );\n                \t\tvec3 mirrorSample = texture2DProj(reflectionSampler, mirrorCoord + r2Distortion ).xyz;\n\n\t\t\t\t\t\t// Multiply\n                \t\tif (MIRROR_METHOD == 1.0)\n\t\t\t\t\t\t\ttexelColor.xyz = mix( texelColor.xyz, texelColor.xyz * mirrorSample, mirrorReflectivity );\n\n\t\t\t\t\t\t// Mix\n\t\t\t\t\t\telse\n                \t\t\ttexelColor.xyz = mix( texelColor.xyz, mirrorSample, mirrorReflectivity );\n                \t#endif\n\t\t\t\t";
            };
            /**
            * Adds refraction contributions to a texelColor
            */
            FragMain.refraction = function () {
                return "\n\t\t\t\t\t#ifdef REFRACTION_MAP\n\n                \t\tvec2 screenUV = ( gl_FragCoord.xy / vec2(viewWidth, viewHeight) );\n                \t\tvec4 gBuffer2Sample = texture2D( gBuffer2, screenUV );\n                \t\tfloat worldDepth = gBuffer2Sample.z;\n                \t\tfloat currentDepth = clipPos.z / cameraFar;\n\n                \t\tvec4 r1Distortion = vec4( normal * refractionDistortion, 0.0 );\n                \t\tvec2 distortedUv = screenUV - r1Distortion.xz;\n\t\t\t\t\t\tgBuffer2Sample = texture2D( gBuffer2, distortedUv );\n                \t\tfloat distortedDepth = gBuffer2Sample.z;\n\n\t\t\t\t\t\t// Makes sure the distortion of the refraction does not happen if the\n\t\t\t\t\t\t// object is in front of the material being drawn\n                \t\tif ( distortedDepth < currentDepth )\n                \t\t{\n                \t\t\tr1Distortion.x = 0.0;\n                \t\t\tr1Distortion.y = 0.0;\n                \t\t\tr1Distortion.z = 0.0;\n               \t\t\t}\n\n                \t\tvec3 r3 = vec3(texture2D(compositionPass, distortedUv ));\n\n\t\t\t\t\t\t// Filmic tone map\n\t\t\t\t\t\t// r3 = max( vec3( 0.0 ), r3 - 0.004 );\n                \t\t// r3 = ( r3 * ( 6.2 * r3 + 0.5 ) ) / ( r3 * ( 6.2 * r3 + 1.7 ) + 0.06 );\n\n                \t\tif ( REFRACTION_METHOD == 1.0)\n                \t\t\ttexelColor.xyz = mix( texelColor.xyz, texelColor.xyz * r3, refractionReflectivity );\n                \t\telse // Mix\n                \t\t\ttexelColor.xyz = mix( texelColor.xyz, r3, refractionReflectivity );\n                \t#endif\n\t\t\t\t";
            };
            /**
            * Diffuse map alpha testing
            */
            FragMain.alphaTest = function () {
                return "\n\t\t\t\t\t#ifdef USE_MAP\n\t\t\t\t\t\tvec4 texelColor = texture2D( map, vUv );\n\t\t\t\t\t\t#ifdef ALPHATEST\n\t\t\t\t\t\t\tif ( texelColor.a < ALPHATEST ) discard;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t#endif\n\t\t\t\t";
            };
            /**
            * line dashes compuations
            */
            FragMain.dashes = function () {
                return "\n\t\t\t\t#ifdef DASH\n\t\t\t\t    if ( floor( 2.0 * fract( lengthSoFar * dashAmount )) <= 0.0 )\n\t\t\t\t        discard;\n\t\t\t\t#endif\n\t\t\t";
            };
            FragMain.packTranslucency = function () {
                return "\n\t\t\t\t\t//\ttranslucency distortion, scale, power\n\t\t\t\t\t\t#ifdef TRANSLUCENCY_ENABLED\n\t\t\t\t\t\t\tfloat transValue = translucencyScale;\n\t\t\t\t\t\t\t#ifdef TRANSLUCENCY_MAP\n\t\t\t\t\t\t\t\tvec4 texelTranslucency = texture2D( translucencyMap, vUv ) * translucencyScale;\n\t\t\t\t\t\t\t\ttransValue = texelTranslucency.r;\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\tgl_FragColor.y = vec3_to_float( vec3( translucencyDistortion, transValue, translucencyPower ) );\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tgl_FragColor.y = 0.0;\n\t\t\t\t\t\t#endif\n\t\t\t\t";
            };
            /**
            * Gets the texture coordinates for a screen quad
            */
            FragMain.quadTexCoord = function () {
                return "\n\t\t\t\t\tvec2 texCoord = gl_FragCoord.xy / vec2( viewWidth, viewHeight );\n\t\t\t\t";
            };
            /**
            * Computes the position of a fragment to view/eye space
            * See http://mynameismjp.wordpress.com/2009/03/10/reconstructing-position-from-depth/
            */
            FragMain.computeVertexPositionVS = function () {
                return "\n\t\t\t\t\tvec4 gBuffer2Sample = texture2D( gBuffer2, texCoord );\n\t\t\t\t\tfloat normalizedDepth = gBuffer2Sample.z;\n\n\t\t\t\t\t#ifdef QUAD_LIGHTING\n\t\t\t\t\t\tvec4 vertexPositionVS = vec4( normalizedDepth * frustumCorner, 1.0 );\n\t\t\t\t\t#else\n\t\t\t\t\t\tvec3 frustumRay = vertVS.xyz * (cameraFar / -vertVS.z);\n\t\t\t\t\t\tvec4 vertexPositionVS = vec4( normalizedDepth * frustumRay, 1.0 );\n\t\t\t\t\t#endif\n\t\t\t\t";
            };
            /**
            * Unpacks the colours from the deffered render textures
            */
            FragMain.unpackColorMap = function () {
                return "\n\t\t\t\t\tvec4 gBufferSample = texture2D( gBuffer, texCoord );\n\t\t\t\t\tvec3 freeOpacShininess = float_to_vec3( abs( gBuffer2Sample.w ) );\n\n\t\t\t\t\tvec3 diffuseColor = float_to_vec3( abs( gBufferSample.x ) );\n\t\t\t\t\tvec3 specularColor = float_to_vec3( abs( gBufferSample.y ) );\n\t\t\t\t\tvec3 emissiveColor = float_to_vec3( abs( gBufferSample.w ) );\n\n\t\t\t\t\tvec3 translucencies = float_to_vec3( abs( gBuffer2Sample.y ) );\n\t\t\t\t\tfloat translucencyDistortion = abs( translucencies.x );\n\t\t\t\t\tfloat translucencyScale = abs( translucencies.y );\n\t\t\t\t\tfloat translucencyPower = abs( translucencies.z );\n\t\t\t\t\tfloat shininess = abs( freeOpacShininess.z ) * 2000.0;\n\t\t\t\t";
            };
            /**
            * Environment computations
            */
            FragMain.environmentMapping = function () {
                return "\n\t\t\t\t#ifdef USE_ENV_MAP\n\t\t\t\t    vec3 reflectVec;\n\n\t\t\t\t    vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n\n\t\t\t\t\tvec3 worldNormal = normalize( vec3( vec4(normal, 0.0) * viewMatrix ) );\n\n\n\t\t\t\t    if ( useRefract == 1.0 )\n\t\t\t\t        reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t\t\t    else\n\t\t\t\t        reflectVec = reflect( cameraToVertex, worldNormal );\n\n\t\t\t\t    #ifdef DOUBLE_SIDED\n\t\t\t\t        float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\t\t\t\t        vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\t\t\t    #else\n\t\t\t\t        vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\t\t\t    #endif\n\n\t\t\t\t\t// Multiply\n                \tif (CHROME_METHOD == 1.0)\n                \t\ttexelColor.xyz = mix( texelColor.xyz, texelColor.xyz * cubeColor.xyz, chromeReflectivity );\n\n\t\t\t\t\t// Mix\n\t\t\t\t\telse\n                \t\ttexelColor.xyz = mix( texelColor.xyz, cubeColor.xyz, chromeReflectivity );\n\t\t\t\t#endif\n\t\t\t";
            };
            /**
            * Compute the diffuse light component
            */
            FragMain.computeDiffuse = function () {
                return "\n\t\t\t\t\tfloat dotProduct = dot( normal, lightVector );\n\t\t\t\t\tfloat diffuseFull = max( dotProduct, 0.0 );\n\t\t\t\t\tvec3 diffuse = vec3( diffuseFull );\n\t\t\t\t";
            };
            /**
            * Compute the diffuse light for the materials translucency
            */
            FragMain.computeTranslucency = function () {
                return "\n\t\t\t\tfloat translucencyFactor = 0.0;\n\t\t\t\tif (translucencyPower > 0.0)\n\t\t\t\t{\n\t\t\t\t\tvec3 translucencyNormal = normalize( lightVector + ( normal * translucencyDistortion ) );\n\t\t\t\t\tfloat translucencyDot = pow( clamp( dot( normalize( -vertexPositionVS.xyz ), -translucencyNormal ), 0.0, 1.0 ), translucencyPower * 100.0 ) * translucencyIntensity;\n\t\t\t\t\ttranslucencyFactor = attenuation * translucencyDot * translucencyScale;\n\t\t\t\t}";
            };
            /**
            * Compute the specular component of the light equation
            */
            FragMain.computeSpecular = function () {
                return "\n\t\t\t\t\tvec3 halfVector = normalize( lightVector - normalize( vertexPositionVS.xyz ) );\n\t\t\t\t\tfloat dotNormalHalf = max( dot( normal, halfVector ), 0.0 );\n\t\t\t\t\tfloat specularNormalization = (shininess + 2.0001) / 8.0;\n\t\t\t\t\tvec3 schlick = specularColor + vec3(1.0 - specularColor) * pow( 1.0 - dot(lightVector, halfVector), 5.0);\n\t\t\t\t\tvec3 specular = (schlick * max(pow(dotNormalHalf, shininess), 0.0) * diffuse * specularNormalization) * specularColor;\n\t\t\t\t";
            };
            /**
            * Combines the lighting components
            */
            FragMain.combineLighting = function () {
                return "\n\t\t\t\t\tvec3 textureMap = float_to_vec3( abs( gBufferSample.z ) );\n\n\t\t\t\t\t// Gama correction http://filmicgames.com/archives/299\n\t\t\t\t\t#if defined(GAMA_INPUT)\n                \t\ttextureMap = textureMap * textureMap;\n\t\t\t\t\t#endif\n\n\t\t\t\t\tvec3 light = lightIntensity * lightColor;\n\t\t\t\t\tgl_FragColor = vec4( light * ( diffuseColor * diffuse  * attenuation * textureMap + specular ) * attenuation, 1.0 );\n\n\t\t\t\t\t// translucency\n\t\t\t\t\tgl_FragColor.xyz += diffuseColor * translucencyColor * translucencyFactor * textureMap;\n\t\t\t\t";
            };
            /**
            * Computes the normal of a fragment
            */
            FragMain.computeNormal = function () {
                return "vec3 normal = normalize( float_to_vec3( abs( gBuffer2Sample.x ) ) * 2.0 - 1.0 ); ";
            };
            return FragMain;
        }());
        ShaderFragments.FragMain = FragMain;
        /**
        * Shader code snippets for the vertex shader main function
        */
        var VertMain = (function () {
            function VertMain() {
            }
            /**
            * Computes the vertex defaults
            */
            VertMain.defaults = function () {
                return "\n\t\t\t\t#ifdef ATTR_COLOR\n\t\t\t\t    vColor = color;\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef ATTR_UV\n\t\t\t\t    vUv = uv * uvScale;\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef ATTR_POSITION\n\n\t\t\t\t    vec4 mvPosition;\n\n\t\t\t\t\t#ifdef USE_SKINNING\n\t\t\t\t\t\tmvPosition = modelViewMatrix * skinned;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\n\t\t\t\t\t\tmvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\n\t\t\t\t\t\tmvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\t#endif\n\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef ATTR_NORMAL\n\t\t\t\t    vec3 objectNormal;\n\n\t\t\t\t    #ifdef USE_SKINNING\n\t\t\t\t        objectNormal = skinnedNormal.xyz;\n\t\t\t\t    #endif\n\n\t\t\t\t    #if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\n\t\t\t\t        objectNormal = morphedNormal;\n\t\t\t\t    #endif\n\n\t\t\t\t    #if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\n\t\t\t\t        objectNormal = normal;\n\t\t\t\t    #endif\n\n\t\t\t\t    #ifdef FLIP_SIDED\n\t\t\t\t        objectNormal = -objectNormal;\n\t\t\t\t    #endif\n\n\t\t\t\t    vec3 transformedNormal = normalMatrix * objectNormal;\n\t\t\t\t    transformedNormal = normalize( transformedNormal );\n\t\t\t\t    vNormal = transformedNormal;\n\n\t\t\t\t#endif\n\n                #if defined(USE_ENV_MAP) || defined(REFLECTION_MAP) || defined(SHADOW_MAPPING)\n                \t#ifdef USE_SKINNING\n                \t\tvec4 worldPosition = modelMatrix * vec4( skinned.xyz, 1.0 );\n                \t #else\n                \t\tvec4 worldPosition = modelMatrix *  vec4( position, 1.0 );\n                \t#endif\n                #endif\n\n                #ifdef USE_BUMPMAP\n                \tvViewPosition = -mvPosition.xyz;\n                #endif\n\t\t\t";
            };
            /**
            * Computes the clip position for refraction
            */
            VertMain.refraction = function () {
                return "\n\t\t\t\t    #if defined(REFRACTION_MAP)\n                \t\tclipPos = gl_Position;\n                    #endif\n\t\t\t\t";
            };
            /**
            * Computes the clipping defaults. Used for custom clip planes.
            */
            VertMain.clipping = function () {
                return "vEyePosition = mvPosition;";
            };
            /**
            * Computes the environment map computations
            */
            VertMain.reflection = function () {
                return "\n\t\t\t\t\t#if defined(REFLECTION_MAP)\n                \t\tmirrorCoord = textureMatrix * worldPosition;\n\t\t\t\t\t#endif\n\t\t\t\t";
            };
            /**
            * Computes the environment map computations
            */
            VertMain.environmentMapping = function () {
                return "\n\t\t\t\t\t#if defined(USE_ENV_MAP)\n                \t\tvWorldPosition = worldPosition.xyz;\n\t\t\t\t\t#endif\n\t\t\t\t";
            };
            /**
            * Computes the dash length
            */
            VertMain.dash = function () {
                return "\n\t\t\t\t\t#ifdef DASH\n\t\t\t\t\t\tlengthSoFar = distance;\n\t\t\t\t\t#endif\n\t\t\t\t";
            };
            /**
            * Assigns the frustum corner for the targeted vertex
            * See http://mynameismjp.wordpress.com/2009/03/10/reconstructing-position-from-depth/
            */
            VertMain.frustumCorners = function () {
                return "\n\t\t\t\t\tfrustumCorner = frustumCorners[int( frustumCornerIndex )];\n\t\t\t\t";
            };
            /**
            * Makes sure that the gl_position is within its the defined boundaries
            */
            VertMain.checkBoundaries = function () {
                return "\n\t\t\t\tif (limitScreenQuad == 1.0)\n\t\t\t\t{\n\t\t\t\t\tif ( gl_Position.x < minMax.x ) gl_Position.x = minMax.x;\n\t\t\t\t\telse if ( gl_Position.x > minMax.z ) gl_Position.x = minMax.z;\n\t\t\t\t\tif ( gl_Position.y > minMax.w ) gl_Position.y = minMax.w;\n\t\t\t\t\telse if ( gl_Position.y < minMax.y ) gl_Position.y = minMax.y;\n\t\t\t\t}\n\t\t\t";
            };
            /**
            * The vertex main function variables for skinned meshes
            */
            VertMain.skin = function () {
                return "\n\t\t\t\t#ifdef USE_SKINNING\n\t\t\t\t\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\t\t\t\t\t#if BONE_INFLUENCES > 1\n\t\t\t\t\t\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\t\t\t\t\t#endif\n\t\t\t\t\t#if BONE_INFLUENCES > 2\n\t\t\t\t\t\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\t\t\t\t\t#endif\n\t\t\t\t\t#if BONE_INFLUENCES > 3\n\t\t\t\t\t\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t";
            };
            /**
            * The normal transformations of skinned meshes
            */
            VertMain.skinTransformNormals = function () {
                return "\n\t\t\t\t#ifdef ATTR_NORMAL\n\t\t\t\t    #ifdef USE_SKINNING\n\t\t\t\t\t\tmat4 skinMatrix = skinWeight.x * boneMatX;\n\n\t\t\t\t\t\t#if BONE_INFLUENCES > 1\n\t\t\t\t\t\t\tskinMatrix \t+= skinWeight.y * boneMatY;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#if BONE_INFLUENCES > 2\n\t\t\t\t\t\t\tskinMatrix \t+= skinWeight.z * boneMatZ;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#if BONE_INFLUENCES > 3\n\t\t\t\t\t\t\tskinMatrix \t+= skinWeight.w * boneMatW;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#ifdef USE_MORPHNORMALS\n\t\t\t\t\t\t\tvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\t\t\t\t\t\t#endif\n\t\t\t\t    #endif\n\t\t\t\t#endif\n\t\t\t";
            };
            /**
            * The vertex position transformations of skinned meshes
            */
            VertMain.skinTransform = function () {
                return "\n\t\t\t\t#ifdef USE_SKINNING\n\t\t\t\t\t#ifdef USE_MORPHTARGETS\n\t\t\t\t\t\tvec4 skinVertex = vec4( morphed, 1.0 );\n\t\t\t\t\t#else\n\t\t\t\t\t\tvec4 skinVertex = vec4( position, 1.0 );\n\t\t\t\t\t#endif\n\n\t\t\t\t\tvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\n\n\t\t\t\t\t#if BONE_INFLUENCES > 1\n\t\t\t\t\t\tskinned += boneMatY * skinVertex * skinWeight.y;\n\t\t\t\t\t#endif\n\t\t\t\t\t#if BONE_INFLUENCES > 2\n\t\t\t\t\t\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\t\t\t\t\t#endif\n\t\t\t\t\t#if BONE_INFLUENCES > 3\n\t\t\t\t\t\tskinned += boneMatW * skinVertex * skinWeight.w;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t";
            };
            return VertMain;
        }());
        ShaderFragments.VertMain = VertMain;
        /**
        * Shader code snippets for vertex parameters
        */
        var VertParams = (function () {
            function VertParams() {
            }
            /**
            * The common attribute and varying declarations for the vertex shader.
            * These can be turned on and off by using DEFINE statements.
            */
            VertParams.defaults = function () {
                return "\n\t\t\t\tuniform mat4 modelViewMatrix;\n\t\t\t\tuniform mat4 projectionMatrix;\n\n                #if defined(USE_ENV_MAP) || defined(REFLECTION_MAP) || defined(SHADOW_MAPPING)\n                \tuniform mat4 modelMatrix;\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef ATTR_POSITION\n\t\t\t\t    attribute vec3 position;\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef ATTR_COLOR\n\t\t\t\t\tattribute vec4 color;\n\t\t\t\t\tvarying vec4 vColor;\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef ATTR_UV\n\t\t\t\t\tattribute vec2 uv;\n\t\t\t\t\tvarying vec2 vUv;\n\t\t\t\t\tuniform vec2 uvScale;\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef ATTR_NORMAL\n\t\t\t\t\tuniform mat3 normalMatrix;\n\t\t\t\t\tattribute vec3 normal;\n\t\t\t\t\tvarying vec3 vNormal;\n\t\t\t\t#endif\n\n                #if defined(ATTR_NORMAL) || defined(FORWARD_NORMAL)\n                \tvarying vec3 normalView;\n                #endif\n\n                #ifdef USE_BUMPMAP\n                \tvarying vec3 vViewPosition;\n                #endif\n\n                #if defined(PASS_GBUFFER2)\n                    uniform float cameraFar;\n                #endif\n\n                #if defined(REFRACTION_MAP) || defined(REFLECTION_MAP)\n                    varying vec4 clipPos;\n                #endif\n\n\t\t\t\t#if defined(PASS_GBUFFER2)\n                    varying float vDepth;\n                #endif\n\t\t\t";
            };
            /**
            * The common attribute and varying declarations for refractions
            */
            VertParams.reflectionParams = function () {
                return "\n\t\t\t\t#ifdef REFLECTION_MAP\n                \tuniform mat4 textureMatrix;\n                \tvarying vec4 mirrorCoord;\n                #endif\n\t\t\t";
            };
            /**
            * The common attribute and varying declarations for the vertex shader clip mapping variables
            */
            VertParams.clippingParameters = function () {
                return "varying vec4 vEyePosition;";
            };
            /**
            * Code that defines the corners of the frustum
            * See http://mynameismjp.wordpress.com/2009/03/10/reconstructing-position-from-depth/
            */
            VertParams.frustumCorners = function () {
                return "\n\t\t\t\tuniform vec3 frustumCorners[8];\n\t\t\t\tvarying vec3 frustumCorner;\n\t\t\t\tattribute float frustumCornerIndex;\n\t\t\t";
            };
            /**
            * Code that defines the min/max boundaries of a scren quad
            */
            VertParams.screenQuadBoundaries = function () {
                return "\n\t\t\t\tuniform vec4 minMax;\n\t\t\t\tuniform float limitScreenQuad;\n\t\t\t";
            };
            /**
            * Variables for the environment maps effect
            */
            VertParams.envMap = function () {
                return "\n\t\t\t\t#ifdef USE_ENV_MAP\n\t\t\t\t    varying vec3 vWorldPosition;\n\t\t\t\t#endif\n\t\t\t";
            };
            /**
            * Variables for the line dashes
            */
            VertParams.dash = function () {
                return "\n\t\t\t\t#ifdef DASH\n\t\t\t\t    attribute float distance;\n\t\t\t\t    varying float lengthSoFar;\n\t\t\t\t#endif\n\t\t\t";
            };
            /**
            * The vertex declarations for skinned meshes
            */
            VertParams.skinDeclarations = function () {
                return "\n\t\t\t\t#ifdef USE_SKINNING\n\n\t\t\t\t    uniform sampler2D boneTexture;\n\t\t\t\t    uniform int boneTextureWidth;\n\t\t\t\t    uniform int boneTextureHeight;\n\n\t\t\t\t    attribute vec4 skinIndex;\n\t\t\t\t    attribute vec4 skinWeight;\n\n\t\t\t\t    mat4 getBoneMatrix( const in float i ) {\n\n\t\t\t\t    float j = i * 4.0;\n\t\t\t\t    float x = mod( j, float( boneTextureWidth ) );\n\t\t\t\t    float y = floor( j / float( boneTextureWidth ) );\n\n\t\t\t\t    float dx = 1.0 / float( boneTextureWidth );\n\t\t\t\t    float dy = 1.0 / float( boneTextureHeight );\n\n\t\t\t\t    y = dy * ( y + 0.5 );\n\n\t\t\t\t    vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\t\t    vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\t\t    vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\t\t    vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\t\t\t    mat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\t\t\t    return bone;\n\t\t\t\t}\n\n\t\t\t\t#endif\n\t\t\t";
            };
            return VertParams;
        }());
        ShaderFragments.VertParams = VertParams;
        /**
        * Shader code snippets for GLSL noise
        * See https://github.com/ashima/webgl-noise for more
        * Authors Ian McEwan, Ashima Arts.
        */
        var NoiseFunctions = (function () {
            function NoiseFunctions() {
            }
            NoiseFunctions.simplex4D = function () {
                return "\n\t\t\t\tvec4 mod289( vec4 x )\n\t\t\t\t{\n\t\t\t\t\treturn x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\t\t\t\t}\n\n\t\t\t\tfloat mod289( float x )\n\t\t\t\t{\n\t\t\t\t\treturn x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\t\t\t\t}\n\n\t\t\t\tvec4 permute( vec4 x )\n\t\t\t\t{\n\t\t\t\t\treturn mod289( ( ( x * 34.0 ) + 1.0 ) * x);\n\t\t\t\t}\n\n\t\t\t\tfloat permute( float x )\n\t\t\t\t{\n\t\t\t\t\treturn mod289( ( ( x * 34.0 ) + 1.0 ) * x);\n\t\t\t\t}\n\n\t\t\t\tvec4 taylorInvSqrt( vec4 r )\n\t\t\t\t{\n\t\t\t\t\treturn 1.79284291400159 - 0.85373472095314 * r;\n\t\t\t\t}\n\n\t\t\t\tfloat taylorInvSqrt( float r )\n\t\t\t\t{\n\t\t\t\t\treturn 1.79284291400159 - 0.85373472095314 * r;\n\t\t\t\t}\n\n\t\t\t\tvec4 grad4( float j, vec4 ip )\n\t\t\t\t{\n\t\t\t\t\tconst vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n\t\t\t\t\tvec4 p,s;\n\n\t\t\t\t\tp.xyz = floor( fract( vec3( j ) * ip.xyz ) * 7.0 ) * ip.z - 1.0;\n\t\t\t\t\tp.w = 1.5 - dot( abs( p.xyz ), ones.xyz);\n\t\t\t\t\ts = vec4( lessThan( p, vec4( 0.0 ) ));\n\t\t\t\t\tp.xyz = p.xyz + ( s.xyz * 2.0 - 1.0 ) * s.www;\n\n\t\t\t\t\treturn p;\n\t\t\t\t}\n\n\t\t\t\t// (sqrt(5) - 1)/4 = F4, used once below\n\t\t\t\t#define F4 0.309016994374947451\n\n\t\t\t\tfloat snoise( vec4 v )\n\t\t\t\t{\n\t\t\t\t\tconst vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n\t\t\t\t\t0.276393202250021,  // 2 * G4\n\t\t\t\t\t0.414589803375032,  // 3 * G4\n\t\t\t\t\t-0.447213595499958 ); // -1 + 4 * G4\n\n\t\t\t\t\t// First corner\n\t\t\t\t\tvec4 i = floor( v + dot( v, vec4( F4 ) ) );\n\t\t\t\t\tvec4 x0 = v - i + dot( i, C.xxxx );\n\n\t\t\t\t\t// Other corners\n\t\t\t\t\t// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n\t\t\t\t\tvec4 i0;\n\t\t\t\t\tvec3 isX = step( x0.yzw, x0.xxx );\n\t\t\t\t\tvec3 isYZ = step( x0.zww, x0.yyz );\n\t\t\t\t\ti0.x = isX.x + isX.y + isX.z;\n\t\t\t\t\ti0.yzw = 1.0 - isX;\n\t\t\t\t\ti0.y += isYZ.x + isYZ.y;\n\t\t\t\t\ti0.zw += 1.0 - isYZ.xy;\n\t\t\t\t\ti0.z += isYZ.z;\n\t\t\t\t\ti0.w += 1.0 - isYZ.z;\n\n\t\t\t\t\t// i0 now contains the unique values 0,1,2,3 in each channel\n\t\t\t\t\tvec4 i3 = clamp( i0, 0.0, 1.0 );\n\t\t\t\t\tvec4 i2 = clamp( i0 - 1.0, 0.0, 1.0 );\n\t\t\t\t\tvec4 i1 = clamp( i0 - 2.0, 0.0, 1.0 );\n\n\t\t\t\t\tvec4 x1 = x0 - i1 + C.xxxx;\n\t\t\t\t\tvec4 x2 = x0 - i2 + C.yyyy;\n\t\t\t\t\tvec4 x3 = x0 - i3 + C.zzzz;\n\t\t\t\t\tvec4 x4 = x0 + C.wwww;\n\n\t\t\t\t\t// Permutations\n\t\t\t\t\ti = mod289( i );\n\t\t\t\t\tfloat j0 = permute( permute( permute( permute( i.w ) + i.z ) + i.y ) + i.x );\n\t\t\t\t\tvec4 j1 = permute( permute( permute( permute(\n\t\t\t\t\ti.w + vec4( i1.w, i2.w, i3.w, 1.0 ) )\n\t\t\t\t\t+ i.z + vec4( i1.z, i2.z, i3.z, 1.0 ) )\n\t\t\t\t\t+ i.y + vec4( i1.y, i2.y, i3.y, 1.0 ) )\n\t\t\t\t\t+ i.x + vec4( i1.x, i2.x, i3.x, 1.0 ) );\n\n\t\t\t\t\t// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n\t\t\t\t\t// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\t\t\t\t\tvec4 ip = vec4( 1.0 / 294.0, 1.0 / 49.0, 1.0 / 7.0, 0.0 );\n\n\t\t\t\t\tvec4 p0 = grad4( j0, ip );\n\t\t\t\t\tvec4 p1 = grad4( j1.x, ip );\n\t\t\t\t\tvec4 p2 = grad4( j1.y, ip );\n\t\t\t\t\tvec4 p3 = grad4( j1.z, ip );\n\t\t\t\t\tvec4 p4 = grad4( j1.w, ip );\n\n\t\t\t\t\t// Normalise gradients\n\t\t\t\t\tvec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\n\t\t\t\t\tp0 *= norm.x;\n\t\t\t\t\tp1 *= norm.y;\n\t\t\t\t\tp2 *= norm.z;\n\t\t\t\t\tp3 *= norm.w;\n\t\t\t\t\tp4 *= taylorInvSqrt( dot( p4, p4 ) );\n\n\n\t\t\t\t\t// Mix contributions from the five corners\n\t\t\t\t\tvec3 m0 = max( 0.6 - vec3( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ) ), 0.0 );\n\t\t\t\t\tvec2 m1 = max( 0.6 - vec2( dot( x3, x3 ), dot( x4, x4 ) ), 0.0 );\n\t\t\t\t\tm0 = m0 * m0;\n\t\t\t\t\tm1 = m1 * m1;\n\t\t\t\t\treturn 49.0 * ( dot( m0 * m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 ) ) )\n\t\t\t\t\t+ dot( m1 * m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) );\n\t\t\t\t}\n\t\t\t";
            };
            NoiseFunctions.simplex2D = function () {
                return "\n\t\t\t\tvec3 mod289( vec3 x )\n\t\t\t\t{\n\t\t\t\t\treturn x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\t\t\t\t}\n\n\t\t\t\tvec2 mod289( vec2 x )\n\t\t\t\t{\n\t\t\t\t\treturn x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\t\t\t\t}\n\n\t\t\t\tvec3 permute( vec3 x )\n\t\t\t\t{\n\t\t\t\t\treturn mod289( ( ( x * 34.0 ) + 1.0 ) * x);\n\t\t\t\t}\n\n\t\t\t\tfloat snoise( vec2 v )\n\t\t\t\t{\n\t\t\t\t\tconst vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n\t\t\t\t\t0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n\t\t\t\t\t-0.577350269189626,  // -1.0 + 2.0 * C.x\n\t\t\t\t\t0.024390243902439); // 1.0 / 41.0\n\n\t\t\t\t\t// First corner\n\t\t\t\t\tvec2 i = floor( v + dot( v, C.yy ) );\n\t\t\t\t\tvec2 x0 = v - i + dot(i, C.xx);\n\n\t\t\t\t\t// Other corners\n\t\t\t\t\tvec2 i1;\n\t\t\t\t\ti1 = ( x0.x > x0.y ) ? vec2( 1.0, 0.0 ) : vec2(0.0, 1.0);\n\t\t\t\t\tvec4 x12 = x0.xyxy + C.xxzz;\n\t\t\t\t\tx12.xy -= i1;\n\n\t\t\t\t\t// Permutations\n\t\t\t\t\ti = mod289(i); // Avoid truncation effects in permutation\n\t\t\t\t\tvec3 p = permute( permute( i.y + vec3( 0.0, i1.y, 1.0 ) )\n\t\t\t\t\t+ i.x + vec3( 0.0, i1.x, 1.0 ));\n\n\t\t\t\t\tvec3 m = max( 0.5 - vec3( dot( x0, x0 ), dot( x12.xy, x12.xy ), dot( x12.zw, x12.zw ) ), 0.0);\n\t\t\t\t\tm = m*m ;\n\t\t\t\t\tm = m*m ;\n\n\t\t\t\t\t// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n\t\t\t\t\t// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\t\t\t\t\tvec3 x = 2.0 * fract( p * C.www ) - 1.0;\n\t\t\t\t\tvec3 h = abs( x ) - 0.5;\n\t\t\t\t\tvec3 ox = floor( x + 0.5);\n\t\t\t\t\tvec3 a0 = x - ox;\n\n\t\t\t\t\t// Normalise gradients implicitly by scaling m\n\t\t\t\t\t// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n\t\t\t\t\tm *= 1.79284291400159 - 0.85373472095314 * ( a0 * a0 + h * h );\n\n\t\t\t\t\t// Compute final noise value at P\n\t\t\t\t\tvec3 g;\n\t\t\t\t\tg.x = a0.x * x0.x + h.x * x0.y;\n\t\t\t\t\tg.yz = a0.yz * x12.xz + h.yz * x12.yw;\n\t\t\t\t\treturn 130.0 * dot( m, g );\n\t\t\t\t}\n\t\t\t";
            };
            NoiseFunctions.simplex3D = function () {
                return "\n\t\t\t\tvec3 mod289( vec3 x )\n\t\t\t\t{\n\t\t\t\t\treturn x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\t\t\t\t}\n\n\t\t\t\tvec4 mod289( vec4 x )\n\t\t\t\t{\n\t\t\t\t\treturn x - floor( x * ( 1.0 / 289.0 ) ) * 289.0;\n\t\t\t\t}\n\n\t\t\t\tvec4 permute( vec4 x )\n\t\t\t\t{\n\t\t\t\t\treturn mod289( ( ( x * 34.0 ) + 1.0 ) * x);\n\t\t\t\t}\n\n\t\t\t\tvec4 taylorInvSqrt( vec4 r )\n\t\t\t\t{\n\t\t\t\t\treturn 1.79284291400159 - 0.85373472095314 * r;\n\t\t\t\t}\n\n\t\t\t\tfloat snoise( vec3 v )\n\t\t\t\t{\n\t\t\t\t\tconst vec2  C = vec2( 1.0 / 6.0, 1.0 / 3.0) ;\n\t\t\t\t\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t\t\t\t\t// First corner\n\t\t\t\t\tvec3 i = floor( v + dot( v, C.yyy ) );\n\t\t\t\t\tvec3 x0 = v - i + dot(i, C.xxx) ;\n\n\t\t\t\t\t// Other corners\n\t\t\t\t\tvec3 g = step( x0.yzx, x0.xyz);\n\t\t\t\t\tvec3 l = 1.0 - g;\n\t\t\t\t\tvec3 i1 = min( g.xyz, l.zxy );\n\t\t\t\t\tvec3 i2 = max( g.xyz, l.zxy );\n\n\t\t\t\t\tvec3 x1 = x0 - i1 + C.xxx;\n\t\t\t\t\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\t\t\t\t\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\t\t\t\t\t// Permutations\n\t\t\t\t\ti = mod289(i);\n\t\t\t\t\tvec4 p = permute( permute( permute(\n\t\t\t\t\t\ti.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )\n\t\t\t\t\t\t+ i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )\n\t\t\t\t\t\t+ i.x + vec4( 0.0, i1.x, i2.x, 1.0 ));\n\n\t\t\t\t\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t\t\t\t\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\t\t\t\t\tfloat n_ = 0.142857142857; // 1.0/7.0\n\t\t\t\t\tvec3  ns = n_ * D.wyz - D.xzx;\n\n\t\t\t\t\tvec4 j = p - 49.0 * floor( p * ns.z * ns.z);  //  mod(p,7*7)\n\n\t\t\t\t\tvec4 x_ = floor( j * ns.z);\n\t\t\t\t\tvec4 y_ = floor( j - 7.0 * x_ );    // mod(j,N)\n\n\t\t\t\t\tvec4 x = x_ * ns.x + ns.yyyy;\n\t\t\t\t\tvec4 y = y_ * ns.x + ns.yyyy;\n\t\t\t\t\tvec4 h = 1.0 - abs( x ) - abs(y);\n\n\t\t\t\t\tvec4 b0 = vec4( x.xy, y.xy );\n\t\t\t\t\tvec4 b1 = vec4( x.zw, y.zw );\n\n\t\t\t\t\tvec4 s0 = floor( b0 ) * 2.0 + 1.0;\n\t\t\t\t\tvec4 s1 = floor( b1 ) * 2.0 + 1.0;\n\t\t\t\t\tvec4 sh = -step(h, vec4( 0.0 ));\n\n\t\t\t\t\tvec4 a0 = b0.xzyw + s0.xzyw *sh.xxyy ;\n\t\t\t\t\tvec4 a1 = b1.xzyw + s1.xzyw *sh.zzww ;\n\n\t\t\t\t\tvec3 p0 = vec3( a0.xy, h.x);\n\t\t\t\t\tvec3 p1 = vec3( a0.zw, h.y);\n\t\t\t\t\tvec3 p2 = vec3( a1.xy, h.z);\n\t\t\t\t\tvec3 p3 = vec3( a1.zw, h.w);\n\n\t\t\t\t\t// Normalise gradients\n\t\t\t\t\tvec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ));\n\t\t\t\t\tp0 *= norm.x;\n\t\t\t\t\tp1 *= norm.y;\n\t\t\t\t\tp2 *= norm.z;\n\t\t\t\t\tp3 *= norm.w;\n\n\t\t\t\t\t// Mix final noise value\n\t\t\t\t\tvec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0);\n\t\t\t\t\tm = m * m;\n\t\t\t\t\treturn 42.0 * dot( m * m, vec4( dot( p0, x0 ), dot( p1, x1 ),\n\t\t\t\t\tdot( p2, x2 ), dot( p3, x3 ) ) );\n\t\t\t\t}\n\t\t\t";
            };
            return NoiseFunctions;
        }());
        ShaderFragments.NoiseFunctions = NoiseFunctions;
        /**
        * Shader code snippets for render passes
        */
        var Passes = (function () {
            function Passes() {
            }
            Passes.fragShadowMain = function () {
                return "\n\t\t\t\t#if defined(PASS_SHADOW)\n\n                \t#ifndef POINT_VERTS\n\t\t\t\t\t\t" + FragMain.alphaTest() + "\n                \t#endif\n\n                \t#if !defined(SHADOW_TYPE_VSM)\n\t\t\t\t\t\tgl_FragColor = pack_depth( gl_FragCoord.z );\n                \t#else\n\n\t\t\t\t\t\t// http://gamedev.stackexchange.com/questions/66030/exponential-variance-shadow-mapping-implementation\n                \t\tfloat positiveExponent = 40.0;\n\t\t\t\t\t\tfloat negativeExponent = 5.0;\n\t\t\t\t\t\tfloat irbisDepth = gl_FragCoord.z;\n\t\t\t\t\t\tvec2 exponents = vec2(positiveExponent, negativeExponent);\n\t\t\t\t\t\tirbisDepth = 2.0 * irbisDepth - 1.0;\n\t\t\t\t\t\tfloat pos = exp(exponents.x * irbisDepth);\n\t\t\t\t\t\tfloat neg = -exp(-exponents.y * irbisDepth);\n\t\t\t\t\t\tvec2 warpDepth = vec2(pos, neg);\n\t\t\t\t\t\tgl_FragColor = vec4(warpDepth, warpDepth * warpDepth);\n\n                \t#endif\n                #endif\n\t\t\t\t";
            };
            Passes.vertNormDepthMain = function () {
                return "\n\t\t\t\t\t#ifdef ATTR_NORMAL\n                \t\tnormalView = normalize( normalMatrix * objectNormal );\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef PASS_GBUFFER2\n\t\t\t\t\t\t#ifdef FORWARD_NORMAL\n\t\t\t\t\t\t\tnormalView = vec3(0.0,0.0,1.0);\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\tvDepth = mvPosition.z / -cameraFar;\n\t\t\t\t\t#endif\n\t\t\t\t";
            };
            Passes.fragNormDepthMain = function () {
                return "\n\t\t\t\t#ifdef PASS_GBUFFER2\n\n\t\t\t\t\tfloat opacityStrength = opacity;\n\t\t\t\t\t#ifdef ATTR_ALPHA\n\t\t\t\t\t\t#ifndef SCREEN_UVS\n\t\t\t\t\t\t\topacityStrength *= vAlpha;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t#endif\n\n\t\t\t\t\tgl_FragColor.w = opacityStrength;\n\n\t\t\t\t\t#ifndef POINT_VERTS\n\t\t\t\t\t\t" + ShaderFragments.FragMain.alphaTest() + "\n\t\t\t\t\t\t" + ShaderFragments.FragMain.dashes() + "\n\t\t\t\t\t#endif\n\n                \t#ifndef CUSTOM_NORMAL\n\t\t\t\t\t\t#ifndef FORWARD_NORMAL\n\t\t\t\t\t\t\tvec3 normal = normalize( normalView );\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#ifdef FORWARD_NORMAL\n\t\t\t\t\t\t\t#ifdef POINT_VERTS\n\t\t\t\t\t\t\t\t#ifdef SCREEN_UVS\n\t\t\t\t\t\t\t\t\tvec3 normal = texture2D( normalMap, vUv ).xyz;\n\t\t\t\t\t\t\t\t\tnormal = normal.xyz * 2.0 - 1.0;\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\tvec3 normal = vec3( gl_PointCoord.x * 4.0 - 2.0, 2.0 - gl_PointCoord.y * 4.0, 1.0 );\n\t\t\t\t\t\t\t\t\tnormal = normalize( normal );\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t#ifdef ATTR_UV\n\t\t\t\t\t\t\t\t\tvec2 uvTemp;\n\t\t\t\t\t\t\t\t\tif ( flipUV == 1.0 )\n\t\t\t\t\t\t\t\t\t\tuvTemp = vec2( 1.0, 1.0 ) - vUv;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tuvTemp = vUv;\n\t\t\t\t\t\t\t\t\tvec3 normal = vec3( uvTemp.x * 4.0 - 2.0, uvTemp.y * 4.0 - 2.0, 1.0 );\n\t\t\t\t\t\t\t\t\tnormal = normalize( normal );\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\tvec3 normal = vec3( 0.0, 0.0, 1.0 );\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#ifdef USE_BUMPMAP\n\t\t\t\t\t\t\t// When we use particles there are no verts. So we need to calculate the vViewPosition\n\t\t\t\t\t\t\t// We do this by getting the vViewPosition and subtracting the point size\n\t\t\t\t\t\t\t#if defined(POINT_VERTS) && defined(USE_MAP)\n\t\t\t\t\t\t\t\tvec2 pointUv = vec2( 1.0 - gl_PointCoord.x, gl_PointCoord.y );\n\t\t\t\t\t\t\t\tvec2 pointFragDelta = ( pointUv * particleScale ) - ( pointUv * ( particleScale * 0.5 ) );\n\t\t\t\t\t\t\t\tvec3 pointFragPosition = vViewPosition +  vec3( pointFragDelta, 0.0 );\n\t\t\t\t\t\t\t\tnormal = perturbNormalArb( -pointFragPosition, normalize( normal ), dHdxy_fwd( vUv, map, bumpScale ) );\n\t\t\t\t\t\t\t\tgl_FragColor.x = vec3_to_float( normal * 0.5 + 0.5 );\n\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd( vUv, bumpMap, bumpScale ) );\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// Normal in X (Must be between 0 and 1, hence the * 0.5 + 0.5, but remember to convert back on the other end )\n\t\t\t\t\t\tgl_FragColor.x = vec3_to_float( normal * 0.5 + 0.5 );\n                \t#endif\n\n\t\t\t\t\t// Translucency in Y\n\t\t\t\t\t" + ShaderFragments.FragMain.packTranslucency() + "\n\n\t\t\t\t\t// Depth in Z\n\t\t\t\t\t#ifdef POINT_VERTS\n                \t\t#ifdef USE_MAP\n                \t\t\t#ifdef SCREEN_UVS\n                \t\t\t\tgl_FragColor.z = uniformDepth - texelColor.a * normalizedRadius;\n                \t\t\t#else\n                \t\t\t\tgl_FragColor.z = vDepth;\n                \t\t\t#endif\n                \t\t#else\n                \t\t\tgl_FragColor.z = vDepth;\n                \t\t#endif\n\t\t\t\t\t#else\n\t\t\t\t\t\tgl_FragColor.z = vDepth;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// FREE, Opacity, shininess\n\t\t\t\t\t#ifdef POINT_VERTS\n\t\t\t\t\t\t#ifdef USE_MAP\n\t\t\t\t\t\t\t#ifdef SCREEN_UVS\n\t\t\t\t\t\t\t\tgl_FragColor.w = vec3_to_float( vec3( 0.0, opacityStrength * texelColor.a, shininess ) );\n\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\tgl_FragColor.w = vec3_to_float( vec3( 0.0, opacityStrength, shininess ) );\n\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tgl_FragColor.w = vec3_to_float( vec3( 0.0, opacityStrength, shininess ) );\n\t\t\t\t\t\t#endif\n\t\t\t\t\t#else\n\t\t\t\t\t\t#ifdef USE_MAP\n\t\t\t\t\t\t\tgl_FragColor.w = vec3_to_float( vec3( 0.0, opacityStrength * texelColor.a, shininess ) );\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tgl_FragColor.w = vec3_to_float( vec3( 0.0, opacityStrength, shininess ) );\n\t\t\t\t\t\t#endif\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\t";
            };
            return Passes;
        }());
        ShaderFragments.Passes = Passes;
    })(ShaderFragments = Trike.ShaderFragments || (Trike.ShaderFragments = {}));
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A very simple material
    */
    var MaterialBasic = (function (_super) {
        __extends(MaterialBasic, _super);
        function MaterialBasic() {
            // Call the material base
            _super.call(this);
            this._map = null;
            this._alphaTest = 0;
            this._uvScale = new Trike.Vec2(1, 1);
            // Reflection
            this._mirrorReflection = false;
            this._reflectionMap = null;
            this._mirrorDistortion = 0.5;
            this._mirrorReflectivity = 1.0;
            this._mirrorMethod = Trike.MirrorMethod.Multiply;
            // Refraction
            this._refractionDistortion = 0.1;
            this._refractionEnabled = false;
            this._refractionReflectivity = 1.0;
            this._refractionMethod = Trike.RefractionMethod.Multiply;
            // Define the commopn uniforms of the material
            this.addUniform(new Trike.UniformVar('modelViewMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('projectionMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('customClipping', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('customClipPlane', Trike.UniformType.FLOAT4), true);
            // GBuffer specific
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('emissive', Trike.UniformType.COLOR3, new Trike.Color(0xffffff)));
            // Add the camera far uniform to the normal depth material
            this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('cameraFar', Trike.UniformType.FLOAT, 1000));
            this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('opacity', Trike.UniformType.FLOAT, 1));
            // Define the default attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            // Create the shaders
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialBasic.prototype.getVertexShader = function () {
            return "\n\n\t\t\t\t" + Trike.ShaderFragments.VertParams.defaults() + "\n\t\t\t\t" + Trike.ShaderFragments.VertParams.clippingParameters() + "\n\t\t\t\t" + Trike.ShaderFragments.VertParams.skinDeclarations() + "\n\n                #ifdef PASS_GBUFFER\n\t\t\t\t\t" + Trike.ShaderFragments.VertParams.reflectionParams() + "\n\t\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.vertParams() + "\n                #endif\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.skin() + "\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.skinTransform() + "\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.skinTransformNormals() + "\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.defaults() + "\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.clipping() + "\n\n\t\t\t\t\t#ifdef PASS_GBUFFER\n\t\t\t\t\t\t" + Trike.ShaderFragments.VertMain.reflection() + "\n\t\t\t\t\t\t" + Trike.ShaderFragments.VertMain.refraction() + "\n\t\t\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.vertMain() + "\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// We need to add the pass data\n\t\t\t\t\t" + Trike.ShaderFragments.Passes.vertNormDepthMain() + "\n\t\t\t\t}\n\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialBasic.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\t" + Trike.ShaderFragments.FragParams.defaults() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.clippingParams() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.encodeNormal() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.map() + "\n\n\t\t\t\t#ifdef PASS_GBUFFER\n\t\t\t\t    uniform vec3 emissive;\n\t\t\t\t\t" + Trike.ShaderFragments.FragParams.reflectionParams() + "\n\t\t\t\t\t" + Trike.ShaderFragments.FragParams.refractionParams() + "\n                    " + Trike.ShaderFragments.ShadowMapping.fragParams() + "\n\t\t\t\t#endif\n\n\t\t\t\t" + Trike.ShaderFragments.FragParams.vecToFloat() + "\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.clippingTest() + "\n\n\t\t\t\t\t#ifdef PASS_GBUFFER\n\n\t\t\t\t\t\t// If the GBuffer pass needs normals\n                \t\t#if defined(ATTR_NORMAL)\n                \t\t\tvec3 normal = normalize( normalView );\n                \t\t\t#if defined(USE_BUMPMAP)\n                \t\t\t\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd( vUv, bumpMap, bumpScale ) );\n                \t\t\t#endif\n                \t\t#endif\n\n\t\t\t\t\t\t// Checks the alpha test\n\t\t\t\t\t\t" + Trike.ShaderFragments.FragMain.alphaTest() + "\n\n                \t\t#ifndef USE_MAP\n                \t\t\tvec4 texelColor = vec4(1.0, 1.0, 1.0, 1.0);\n                \t\t#endif\n\n\t\t\t\t\t\t" + Trike.ShaderFragments.FragMain.reflection() + "\n\t\t\t\t\t\t" + Trike.ShaderFragments.FragMain.refraction() + "\n                        " + Trike.ShaderFragments.ShadowMapping.fragMain() + "\n\n\t\t\t\t\t\t#ifndef SHADOW_MAPPING\n\t\t\t\t\t\t\tfloat shadowAmount = 1.0;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// diffuse in x, specular in y, map in z, emmsive in w\n                \t\tgl_FragColor = vec4( 0.0, 0.0,\n                \t\t\tvec3_to_float( texelColor.xyz ),\n                \t\t\tvec3_to_float( emissive * shadowAmount ));\n\n\t\t\t\t\t#else\n\t\t\t\t\t\tfloat shininess = 0.0;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t" + Trike.ShaderFragments.Passes.fragNormDepthMain() + "\n\t\t\t\t\t" + Trike.ShaderFragments.Passes.fragShadowMain() + "\n\t\t\t\t}\n\t\t\t";
        };
        /*
        * Gets or sets the UV scale of the texture coordinates. Higher values mean higher UV tesselation
        * @param {Vec2} val
        * @returns {Vec2}
        */
        MaterialBasic.prototype.uvScale = function (val) {
            if (val === undefined)
                return this._uvScale;
            this._uvScale = val;
            if (this._uniforms['uvScale']) {
                this.setUniform('uvScale', this._uvScale, true);
                return this._uvScale;
            }
            return this._uvScale;
        };
        /*
        * Checks the uniforms or attributes of the material after a potentially breaking change
        */
        MaterialBasic.prototype._validate = function () {
            var gBuffer = this.materials[Trike.PassType.GBuffer];
            // Check for view width and height params
            if (this._refractionEnabled) {
                if (!gBuffer._uniforms['viewHeight']) {
                    gBuffer.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 512));
                    gBuffer.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 512));
                }
            }
            else {
                if (gBuffer._uniforms['viewHeight']) {
                    gBuffer.removeUniform('viewHeight');
                    gBuffer.removeUniform('viewWidth');
                }
            }
            // Check for model matrix
            if (this._mirrorReflection || this.maxNumShadows() > 0) {
                if (!gBuffer._uniforms['modelMatrix'])
                    gBuffer.addUniform(new Trike.UniformVar('modelMatrix', Trike.UniformType.MAT4));
            }
            else {
                if (gBuffer._uniforms['modelMatrix'])
                    gBuffer.removeUniform('modelMatrix');
            }
            if (this._refractionEnabled || this._mirrorReflection) {
                // Dont add it if there is already one there
                if (!gBuffer._attributes[Trike.AttributeType.NORMAL]) {
                    gBuffer.addUniform(new Trike.UniformVar('normalMatrix', Trike.UniformType.MAT3, new Trike.Matrix3()));
                    gBuffer.addAttribute(new Trike.AttributeVar('normal', Trike.AttributeType.NORMAL));
                    gBuffer.addDefine(Trike.ShaderDefines.ATTR_NORMAL);
                }
            }
            else {
                // Do nothing if there nothing there
                if (gBuffer._attributes[Trike.AttributeType.NORMAL]) {
                    gBuffer.removeUniform('normalMatrix');
                    gBuffer.removeAttribute(Trike.AttributeType.NORMAL);
                    gBuffer.removeDefine(Trike.ShaderDefines.ATTR_NORMAL);
                }
            }
        };
        /**
        * Gets or sets if refraction is enabled. The material must be transparent for this to work.
        * @param {boolean} val [Optional]
        * @returns {boolean}
        */
        MaterialBasic.prototype.refractionEnabled = function (val) {
            if (val === undefined)
                return this._refractionEnabled;
            this._refractionEnabled = val;
            var material = this.materials[Trike.PassType.GBuffer];
            if (val) {
                material.addDefine(Trike.ShaderDefines.REFRACTION_MAP);
                material.addUniform(new Trike.UniformVar('gBuffer2', Trike.UniformType.TEXTURE, null));
                material.addUniform(new Trike.UniformVar('compositionPass', Trike.UniformType.TEXTURE, null));
                material.addUniform(new Trike.UniformVar('refractionDistortion', Trike.UniformType.FLOAT, this._refractionDistortion));
                material.addUniform(new Trike.UniformVar('cameraFar', Trike.UniformType.FLOAT, 0));
                material.addUniform(new Trike.UniformVar('refractionReflectivity', Trike.UniformType.FLOAT, this._refractionReflectivity));
            }
            else {
                material.removeDefine(Trike.ShaderDefines.REFRACTION_MAP);
                material.removeUniform('gBuffer2');
                material.removeUniform('compositionPass');
                material.removeUniform('refractionDistortion');
                material.removeUniform('cameraFar');
                material.removeUniform('refractionReflectivity');
            }
            this._validate();
            return this._refractionEnabled;
        };
        /*
        * Gets or sets the refraction combination method
        * @param {RefractionMethod} val [Optional]
        * @returns {RefractionMethod}
        */
        MaterialBasic.prototype.refractionMethod = function (val) {
            if (val === undefined)
                return this._refractionMethod;
            this.materials[Trike.PassType.GBuffer].removeDefine('#define REFRACTION_METHOD ' + this._refractionMethod.toFixed(1));
            this._refractionMethod = val;
            this.materials[Trike.PassType.GBuffer].addDefine('#define REFRACTION_METHOD ' + this._refractionMethod.toFixed(1));
            return this._refractionMethod;
        };
        /*
        * Gets or sets the refractive distortion
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialBasic.prototype.refractionDistortion = function (val) {
            if (val === undefined)
                return this._refractionDistortion;
            this._refractionDistortion = val;
            if (this._refractionEnabled)
                this.materials[Trike.PassType.GBuffer].setUniform('refractionDistortion', val, false);
            return this._refractionDistortion;
        };
        /*
        * Gets or sets the refraction reflectivity
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialBasic.prototype.refractionReflectivity = function (val) {
            if (val === undefined)
                return this._refractionReflectivity;
            this._refractionReflectivity = val;
            if (this._refractionEnabled)
                this.materials[Trike.PassType.GBuffer].setUniform('refractionReflectivity', val, false);
            return this._refractionReflectivity;
        };
        /**
        * Gets or sets the texture matrix of this material for reflective textures
        * @param {Matrix4} val [Optional]
        * @returns {Matrix4}
        */
        MaterialBasic.prototype.textureMatrix = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['textureMatrix'].value;
            return this.materials[Trike.PassType.GBuffer].setUniform('textureMatrix', val, false).value;
        };
        /**
        * Adds or removes the properties for reflection
        * @param {boolean} val [Optional]
        * @returns {boolean}
        */
        MaterialBasic.prototype.mirrorReflection = function (val) {
            if (val === undefined)
                return this._mirrorReflection;
            var material = this.materials[Trike.PassType.GBuffer];
            this._mirrorReflection = val;
            if (val) {
                material.addUniform(new Trike.UniformVar('reflectionSampler', Trike.UniformType.TEXTURE));
                material.addUniform(new Trike.UniformVar('textureMatrix', Trike.UniformType.MAT4));
                material.addUniform(new Trike.UniformVar('mirrorDistortion', Trike.UniformType.FLOAT, this._mirrorDistortion));
                material.addUniform(new Trike.UniformVar('mirrorReflectivity', Trike.UniformType.FLOAT, this._mirrorReflectivity));
                material.addDefine(Trike.ShaderDefines.REFLECTION_MAP);
            }
            else {
                material.removeUniform('reflectionSampler');
                material.removeUniform('textureMatrix');
                material.removeUniform('mirrorDistortion');
                material.removeUniform('mirrorReflectivity');
                material.removeDefine(Trike.ShaderDefines.REFLECTION_MAP);
            }
            this._validate();
            return val;
        };
        /*
        * Gets or sets the texture map of this material
        * @param {RenderTarget} val [Optional]
        * @return {RenderTarget}
        */
        MaterialBasic.prototype.reflectionMap = function (val) {
            if (val === undefined)
                return this._reflectionMap;
            this._reflectionMap = val;
            if (this._mirrorReflection)
                this.materials[Trike.PassType.GBuffer].setUniform('reflectionSampler', val, true);
            return this._reflectionMap;
        };
        /*
        * Gets or sets the mirror distortion
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialBasic.prototype.mirrorDistortion = function (val) {
            if (val === undefined)
                return this._mirrorDistortion;
            this._mirrorDistortion = val;
            if (this._mirrorReflection)
                this.materials[Trike.PassType.GBuffer].setUniform('mirrorDistortion', val, false);
            return this._mirrorDistortion;
        };
        /*
        * Gets or sets the mirror reflectivity
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialBasic.prototype.mirrorReflectivity = function (val) {
            if (val === undefined)
                return this._mirrorReflectivity;
            this._mirrorReflectivity = val;
            if (this._mirrorReflection)
                this.materials[Trike.PassType.GBuffer].setUniform('mirrorReflectivity', val, false);
            return this._mirrorReflectivity;
        };
        /*
        * Gets or sets the mirror combination method
        * @param {MirrorMethod} val [Optional]
        * @returns {MirrorMethod}
        */
        MaterialBasic.prototype.mirrorMethod = function (val) {
            if (val === undefined)
                return this._mirrorMethod;
            this.materials[Trike.PassType.GBuffer].removeDefine('#define MIRROR_METHOD ' + this._mirrorMethod.toFixed(1));
            this._mirrorMethod = val;
            this.materials[Trike.PassType.GBuffer].addDefine('#define MIRROR_METHOD ' + this._mirrorMethod.toFixed(1));
            return this._mirrorMethod;
        };
        /**
        * Creates UV data for this material if desired. This can be overwritten in sub functions, to determine the
        * conditions in which UVs exist.
        * @param {boolean} desired
        */
        MaterialBasic.prototype._setUV = function (desired) {
            if (desired) {
                this.addAttribute(new Trike.AttributeVar('uv', Trike.AttributeType.UV));
                this.addUniform(new Trike.UniformVar('uvScale', Trike.UniformType.FLOAT2, this._uvScale));
                this.addDefine(Trike.ShaderDefines.ATTR_UV);
            }
            else {
                this.removeAttribute(Trike.AttributeType.UV);
                this.removeUniform('uvScale');
                this.removeDefine(Trike.ShaderDefines.ATTR_UV);
            }
        };
        /**
        * Gets or sets the texture map of this material
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialBasic.prototype.map = function (val) {
            if (val === undefined)
                return this._map;
            if (this._map && val) {
                this._map = val;
                this.setUniform('map', val, true);
                return val;
            }
            else if (!this._map && val) {
                this._map = val;
                this._setUV(true);
                this.addUniform(new Trike.UniformVar('map', Trike.UniformType.TEXTURE, val));
                this.addDefine(Trike.ShaderDefines.USE_MAP);
            }
            else {
                this._map = null;
                this._setUV(false);
                this.removeUniform('map');
                this.removeDefine(Trike.ShaderDefines.USE_MAP);
            }
            return val;
        };
        /**
        * Gets or sets the alpha test value. Alpha tests are used to discard pixels with alpha less than
        * the value set as the test. I.e. if the alpha test is 0.5, then any pixels with an
        * alpha value of less than 0.5 are discarded from the render process.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialBasic.prototype.alphaTest = function (val) {
            if (val === undefined)
                return this._alphaTest;
            this.removeDefine('#define ALPHATEST ' + this._alphaTest.toFixed(3));
            this._alphaTest = val;
            if (val !== 0)
                this.addDefine('#define ALPHATEST ' + this._alphaTest.toFixed(3));
            return this._alphaTest;
        };
        /*
        * Gets or sets emissive light colour
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialBasic.prototype.emissive = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['emissive'].value;
            this.materials[Trike.PassType.GBuffer].setUniform('emissive', val, false);
            return val;
        };
        /*
        * Gets or sets the opacity of this material. The values are from 0 to 1.
        * @param {number} val
        */
        MaterialBasic.prototype.opacity = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer2]._uniforms['opacity'].value;
            this.materials[Trike.PassType.GBuffer2].setUniform('opacity', val, false);
            return val;
        };
        return MaterialBasic;
    }(Trike.MaterialMulti));
    Trike.MaterialBasic = MaterialBasic;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A simple material used to draw lines
    */
    var MaterialLine = (function (_super) {
        __extends(MaterialLine, _super);
        function MaterialLine(color, dashAmount, lineWidth) {
            if (color === void 0) { color = new Trike.Color(0xffffff); }
            if (dashAmount === void 0) { dashAmount = 0; }
            if (lineWidth === void 0) { lineWidth = 1; }
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.CreateDefaults);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('modelViewMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('projectionMatrix', Trike.UniformType.MAT4), true);
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('emissive', Trike.UniformType.COLOR3, color));
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('cameraFar', Trike.UniformType.FLOAT, 1000));
            this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('opacity', Trike.UniformType.FLOAT, 1));
            this.lineWidth = lineWidth;
            this._dash = 0;
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            // Must be called after defines as it adds a dash amount define
            this.dashCount(dashAmount);
            // Create the shaders
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialLine.prototype.getVertexShader = function () {
            return "\n\n\t\t\t\t" + Trike.ShaderFragments.VertParams.defaults() + "\n\t\t\t\t" + Trike.ShaderFragments.VertParams.dash() + "\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.defaults() + "\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.dash() + "\n\n\t\t\t\t\t// We need to add the pass data\n\t\t\t\t\t" + Trike.ShaderFragments.Passes.vertNormDepthMain() + "\n\t\t\t\t}\n\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialLine.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\t" + Trike.ShaderFragments.FragParams.defaults() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.dashes() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.vecToFloat() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.encodeNormal() + "\n\t\t\t\t#ifdef PASS_GBUFFER\n\t\t\t\t    uniform vec3  emissive;\n\t\t\t\t#endif\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\n\t\t\t\t    #ifdef PASS_GBUFFER\n\t\t\t\t\t\t" + Trike.ShaderFragments.FragMain.dashes() + "\n\n\t\t\t\t\t\t// We store the emmsive in w\n\t\t\t\t\t\tgl_FragColor.w = vec3_to_float( vec3( emissive.r, emissive.g, emissive.b ) );\n\t\t\t\t\t\tgl_FragColor.x = 0.0;\n\t\t\t\t\t\tgl_FragColor.y = 0.0;\n\t\t\t\t\t\tgl_FragColor.z = vec3_to_float( vec3( 1.0, 1.0, 1.0 ) );\n\t\t\t\t    #endif\n\n\t\t\t\t\t#ifdef PASS_GBUFFER2\n\t\t\t\t\t\tfloat shininess = 0.0;\n\t\t\t\t\t#endif\n\t\t\t\t\t" + Trike.ShaderFragments.Passes.fragNormDepthMain() + "\n\t\t\t\t}\n\t\t\t";
        };
        /*
        * Gets or sets the dash count
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialLine.prototype.dashCount = function (val) {
            if (val === undefined)
                return this._dash;
            if (this._dash > 0 && val > 0) {
                this._dash = val;
                this.setUniform('dashAmount', val, true);
                return val;
            }
            if (this._dash === 0 && val > 0) {
                this._dash = val;
                this.addUniform(new Trike.UniformVar('dashAmount', Trike.UniformType.FLOAT, val));
                this.addAttribute(new Trike.AttributeVar('distance', Trike.AttributeType.CUSTOM_1));
                this.addDefine(Trike.ShaderDefines.DASHED);
            }
            else {
                this._dash = 0;
                this.removeUniform('dashAmount');
                this.removeAttribute(Trike.AttributeType.CUSTOM_1);
                this.removeDefine(Trike.ShaderDefines.DASHED);
            }
            return val;
        };
        /*
        * Gets or sets emissive light colour
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialLine.prototype.emissive = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['emissive'].value;
            this.materials[Trike.PassType.GBuffer].setUniform('emissive', val, false);
            return val;
        };
        /*
        * Gets or sets the opacity of this material. The values are from 0 to 1.
        * @param {number} val
        */
        MaterialLine.prototype.opacity = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer2]._uniforms['opacity'].value;
            this.materials[Trike.PassType.GBuffer2].setUniform('opacity', val, false);
            return val;
        };
        return MaterialLine;
    }(Trike.MaterialMulti));
    Trike.MaterialLine = MaterialLine;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A phong material shader that draws the material attributes into the RGBA channels
    */
    var MaterialPhong = (function (_super) {
        __extends(MaterialPhong, _super);
        function MaterialPhong() {
            // Call the material base
            _super.call(this);
            this._bump = null;
            this._bumpScale = 1;
            this._specular = null;
            this._chrome = null;
            // Chrome
            this._chromeReflectivity = 1;
            this._chromeCombination = 1;
            this._refractionRatio = 0.98;
            this._chromeDirection = Trike.ChromeDirection.Refractive;
            this._flipChrome = -1;
            // Translucency
            this._translucencyEnabled = false;
            this._translucencyMap = null;
            this._translucencyScale = 1;
            this._translucencyDistortion = 0.185;
            this._translucencyPower = 0.04;
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            // GBuffer
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('diffuse', Trike.UniformType.COLOR3, new Trike.Color(0xffffff)));
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('emissive', Trike.UniformType.COLOR3, new Trike.Color(0x000000)));
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('specular', Trike.UniformType.COLOR3, new Trike.Color(0xffffff)));
            // GBuffer 2
            this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('cameraFar', Trike.UniformType.FLOAT, 1000));
            this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('opacity', Trike.UniformType.FLOAT, 1));
            this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('shininess', Trike.UniformType.FLOAT, 0.05));
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialPhong.prototype.getVertexShader = function () {
            return "\n\n\t\t\t// Declarations\n\t\t\t" + Trike.ShaderFragments.VertParams.defaults() + "\n\t\t\t" + Trike.ShaderFragments.VertParams.clippingParameters() + "\n\t\t\t" + Trike.ShaderFragments.VertParams.skinDeclarations() + "\n\n\t\t\t#ifdef PASS_GBUFFER\n\t\t\t\t" + Trike.ShaderFragments.VertParams.envMap() + "\n\t\t\t\t" + Trike.ShaderFragments.VertParams.reflectionParams() + "\n\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.vertParams() + "\n\t\t\t#endif\n\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\t" + Trike.ShaderFragments.VertMain.skin() + "\n\t\t\t\t" + Trike.ShaderFragments.VertMain.skinTransform() + "\n\t\t\t\t" + Trike.ShaderFragments.VertMain.skinTransformNormals() + "\n\t\t\t\t" + Trike.ShaderFragments.VertMain.defaults() + "\n\t\t\t\t" + Trike.ShaderFragments.VertMain.clipping() + "\n\n\t\t\t\t#ifdef PASS_GBUFFER\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.environmentMapping() + "\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.reflection() + "\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.refraction() + "\n\t\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.vertMain() + "\n\t\t\t\t#endif\n\n\t\t\t\t// We need to add the pass data\n\t\t\t\t" + Trike.ShaderFragments.Passes.vertNormDepthMain() + "\n\t\t\t}\n\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialPhong.prototype.getFragmentShader = function () {
            return "\n\t\t\t// Declarations\n\t\t\t" + Trike.ShaderFragments.FragParams.defaults() + "\n\t\t\t" + Trike.ShaderFragments.FragParams.clippingParams() + "\n\t\t\t" + Trike.ShaderFragments.FragParams.encodeNormal() + "\n\t\t\t" + Trike.ShaderFragments.FragParams.map() + "\n\t\t\t" + Trike.ShaderFragments.FragParams.bumpmapUniforms() + "\n\t\t\t" + Trike.ShaderFragments.FragParams.bumpmapFunctions() + "\n\t\t\t" + Trike.ShaderFragments.FragParams.vecToFloat() + "\n\t\t\t" + Trike.ShaderFragments.FragParams.floatToVec() + "\n\n\t\t\t#if defined(PASS_GBUFFER)\n\t\t\t\t" + Trike.ShaderFragments.FragParams.reflectionParams() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.environmentMapping() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.refractionParams() + "\n\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.fragParams() + "\n\n\t\t\t\t#ifdef USE_SPECULARMAP\n\t\t\t\t\tuniform sampler2D specularMap;\n\t\t\t\t#endif\n\t\t\t\tuniform vec3 diffuse;\n\t\t\t\tuniform vec3 specular;\n\t\t\t\tuniform vec3 emissive;\n\n\t\t\t#elif defined(PASS_GBUFFER2)\n\t\t\t\tuniform float shininess;\n\t\t\t#endif\n\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\t" + Trike.ShaderFragments.FragMain.clippingTest() + "\n\n\t\t\t\t#ifdef PASS_GBUFFER\n\n\t\t\t\t\t// If the GBuffer pass needs normals\n\t\t\t\t\t#if defined(ATTR_NORMAL)\n\t\t\t\t\t\tvec3 normal = normalize( normalView );\n\t\t\t\t\t\t#if defined(USE_BUMPMAP)\n\t\t\t\t\t\t\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd( vUv, bumpMap, bumpScale ) );\n\t\t\t\t\t\t#endif\n\t\t\t\t\t#endif\n\n\t\t\t\t\tgl_FragColor = vec4( diffuse, 1.0 );\n\t\t\t\t\tfloat specularStrength = 1.0;\n\n\t\t\t\t\t// Get the color from the map\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.alphaTest() + "\n\n\t\t\t\t\t#ifndef USE_MAP\n\t\t\t\t\t\tvec4 texelColor = vec4(1.0, 1.0, 1.0, 1.0);\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef USE_SPECULARMAP\n\t\t\t\t\t\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\t\t\t\t\t\tspecularStrength = texelSpecular.r;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.environmentMapping() + "\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.reflection() + "\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.refraction() + "\n\t\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.fragMain() + "\n\n\t\t\t\t\t#ifndef SHADOW_MAPPING\n\t\t\t\t\t\tfloat shadowAmount = 1.0;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// diffuse color in x\n\t\t\t\t\tgl_FragColor.x = vec3_to_float( diffuse * shadowAmount );\n\n\t\t\t\t\t// specular color in y\n\t\t\t\t\tgl_FragColor.y = vec3_to_float( specular * specularStrength * shadowAmount );\n\n\t\t\t\t\t// Albedo in Z\n\t\t\t\t\tgl_FragColor.z = vec3_to_float(texelColor.xyz );\n\n\t\t\t\t\t// We store the emmsive in w\n\t\t\t\t\tgl_FragColor.w = vec3_to_float( emissive * shadowAmount );\n\n\t\t\t\t#endif\n\t\t\t\t" + Trike.ShaderFragments.Passes.fragNormDepthMain() + "\n\t\t\t\t" + Trike.ShaderFragments.Passes.fragShadowMain() + "\n\t\t\t}\n\t\t\t";
        };
        /**
        * Only remove the UV attributes if we dont have any maps
        */
        MaterialPhong.prototype._setUV = function (desired) {
            if (desired)
                _super.prototype._setUV.call(this, true);
            else if (!this._bump && !this._specular && !this._translucencyMap && !this.map()) {
                this.removeAttribute(Trike.AttributeType.UV);
                this.removeUniform('uvScale');
                this.removeDefine(Trike.ShaderDefines.ATTR_UV);
            }
        };
        /*
        * Gets or sets the specular highlight map of this material
        * @param {Texture} val [Optional]
        * @returns {Texture}
        */
        MaterialPhong.prototype.specularMap = function (val) {
            if (val === undefined)
                return this._specular;
            if (this._specular && val) {
                this._specular = val;
                this.materials[Trike.PassType.GBuffer].setUniform('specularMap', val, false);
            }
            else if (!this._specular && val) {
                this._specular = val;
                this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('specularMap', Trike.UniformType.TEXTURE, val), false);
                this._setUV(true);
                this.addDefine(Trike.ShaderDefines.SPECULAR_MAP);
            }
            else {
                this._specular = null;
                this.materials[Trike.PassType.GBuffer].removeUniform('specularMap', false);
                this._setUV(false);
                this.removeDefine(Trike.ShaderDefines.SPECULAR_MAP);
            }
            return val;
        };
        /*
        * Gets or sets the bump map of this material
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialPhong.prototype.bumpMap = function (val) {
            if (val === undefined)
                return this._bump;
            var gBuffer = this.materials[Trike.PassType.GBuffer];
            var gBuffer2 = this.materials[Trike.PassType.GBuffer2];
            var passes = [gBuffer, gBuffer2];
            if (this._bump && val) {
                this._bump = val;
                // Sometimes the GBuffer has a bump map for refraction / reflection
                if (gBuffer._uniforms['bumpMap'])
                    gBuffer.setUniform('bumpMap', val, false);
                gBuffer2.setUniform('bumpMap', val, false);
                gBuffer2.setUniform('bumpScale', this._bumpScale, false);
            }
            else if (!this._bump && val) {
                this._bump = val;
                this._setUV(true);
                gBuffer2.addUniform(new Trike.UniformVar('bumpMap', Trike.UniformType.TEXTURE, val));
                gBuffer2.addUniform(new Trike.UniformVar('bumpScale', Trike.UniformType.FLOAT, this._bumpScale));
                gBuffer2.addDefine(Trike.ShaderDefines.STANDARD_DERIVATIVES);
                gBuffer2.addDefine(Trike.ShaderDefines.BUMP_MAP);
            }
            else {
                this._bump = null;
                this._setUV(false);
                for (var i = 0, l = passes.length; i < l; i++) {
                    passes[i].removeUniform('bumpMap');
                    passes[i].removeUniform('bumpScale');
                    passes[i].removeDefine(Trike.ShaderDefines.STANDARD_DERIVATIVES);
                    passes[i].removeDefine(Trike.ShaderDefines.BUMP_MAP);
                }
            }
            this._validate();
            return val;
        };
        /*
        * Gets or sets the environment map of this material
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialPhong.prototype.chromeMap = function (val) {
            if (val === undefined)
                return this._chrome;
            var gBuffer = this.materials[Trike.PassType.GBuffer];
            if (this._chrome && val) {
                this._chrome = val;
                gBuffer.setUniform('envMap', val, false);
            }
            else if (!this._chrome && val) {
                this._chrome = val;
                gBuffer.addUniform(new Trike.UniformVar('chromeReflectivity', Trike.UniformType.FLOAT, this._chromeReflectivity), false);
                gBuffer.addUniform(new Trike.UniformVar('envMap', Trike.UniformType.TEXTURE_CUBE, val), false);
                gBuffer.addUniform(new Trike.UniformVar('useRefract', Trike.UniformType.FLOAT, this._chromeDirection), false);
                gBuffer.addUniform(new Trike.UniformVar('refractionRatio', Trike.UniformType.FLOAT, this._refractionRatio), false);
                gBuffer.addUniform(new Trike.UniformVar('cameraPosition', Trike.UniformType.FLOAT3), false);
                gBuffer.addUniform(new Trike.UniformVar('flipEnvMap', Trike.UniformType.FLOAT, this._flipChrome), false);
                gBuffer.addUniform(new Trike.UniformVar('viewMatrix', Trike.UniformType.MAT4));
                gBuffer.addDefine(Trike.ShaderDefines.USE_ENV_MAP);
            }
            else {
                this._chrome = null;
                gBuffer.removeUniform('chromeReflectivity', false);
                gBuffer.removeUniform('envMap', false);
                gBuffer.removeUniform('useRefract', false);
                gBuffer.removeUniform('refractionRatio', false);
                gBuffer.removeUniform('flipEnvMap', false);
                gBuffer.removeUniform('cameraPosition');
                gBuffer.removeUniform('viewMatrix');
                gBuffer.removeDefine(Trike.ShaderDefines.USE_ENV_MAP);
            }
            this._validate();
            return val;
        };
        /*
        * Checks the uniforms or attributes of the material after a potentially breaking change
        */
        MaterialPhong.prototype._validate = function () {
            var gBuffer = this.materials[Trike.PassType.GBuffer];
            // Check for view width and height params
            if (this.refractionEnabled()) {
                if (!gBuffer._uniforms['viewHeight']) {
                    gBuffer.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 512));
                    gBuffer.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 512));
                }
            }
            else {
                if (gBuffer._uniforms['viewHeight']) {
                    gBuffer.removeUniform('viewHeight');
                    gBuffer.removeUniform('viewWidth');
                }
            }
            if (this.refractionEnabled() || this.mirrorReflection() || this._chrome || this.maxNumShadows() > 0) {
                // Check for model matrix
                if (this.mirrorReflection() || this._chrome || this.maxNumShadows() > 0) {
                    if (!gBuffer._uniforms['modelMatrix'])
                        gBuffer.addUniform(new Trike.UniformVar('modelMatrix', Trike.UniformType.MAT4));
                }
                else {
                    if (gBuffer._uniforms['modelMatrix'])
                        gBuffer.removeUniform('modelMatrix');
                }
                // Dont add it if there is already one there
                if (!gBuffer._attributes[Trike.AttributeType.NORMAL]) {
                    gBuffer.addUniform(new Trike.UniformVar('normalMatrix', Trike.UniformType.MAT3, new Trike.Matrix3()));
                    gBuffer.addAttribute(new Trike.AttributeVar('normal', Trike.AttributeType.NORMAL));
                    gBuffer.addDefine(Trike.ShaderDefines.ATTR_NORMAL);
                }
                if (this._bump && !gBuffer.hasDefine(Trike.ShaderDefines.BUMP_MAP)) {
                    gBuffer.addDefine(Trike.ShaderDefines.STANDARD_DERIVATIVES);
                    gBuffer.addDefine(Trike.ShaderDefines.BUMP_MAP);
                    gBuffer.addUniform(new Trike.UniformVar('bumpScale', Trike.UniformType.FLOAT, this._bumpScale));
                    gBuffer.addUniform(new Trike.UniformVar('bumpMap', Trike.UniformType.TEXTURE, this._bump));
                }
                else if (!this._bump && gBuffer.hasDefine(Trike.ShaderDefines.BUMP_MAP)) {
                    gBuffer.removeDefine(Trike.ShaderDefines.STANDARD_DERIVATIVES);
                    gBuffer.removeDefine(Trike.ShaderDefines.BUMP_MAP);
                    gBuffer.removeUniform('bumpScale');
                    gBuffer.removeUniform('bumpMap');
                }
            }
            else {
                if (gBuffer._uniforms['modelMatrix'])
                    gBuffer.removeUniform('modelMatrix');
                // Do nothing if there nothing there
                if (gBuffer._attributes[Trike.AttributeType.NORMAL]) {
                    gBuffer.removeUniform('normalMatrix');
                    gBuffer.removeAttribute(Trike.AttributeType.NORMAL);
                    gBuffer.removeDefine(Trike.ShaderDefines.ATTR_NORMAL);
                }
                if (gBuffer.hasDefine(Trike.ShaderDefines.BUMP_MAP)) {
                    gBuffer.removeDefine(Trike.ShaderDefines.STANDARD_DERIVATIVES);
                    gBuffer.removeDefine(Trike.ShaderDefines.BUMP_MAP);
                    gBuffer.removeUniform('bumpScale');
                    gBuffer.removeUniform('bumpMap');
                }
            }
        };
        /*
        * Gets or sets if the normal that samples the environment map should be flipped or not
        * @param {boolean} val
        */
        MaterialPhong.prototype.flipChrome = function (val) {
            if (val === undefined)
                return (this._flipChrome === -1 ? true : false);
            this._flipChrome = (val ? -1 : 1);
            if (this._chrome)
                this.materials[Trike.PassType.GBuffer].setUniform('flipEnvMap', this._flipChrome, false);
            return val;
        };
        /*
        * Gets or sets the chrome sampling direction
        * @param {ChromeDirection} val
        * @returns {ChromeDirection}
        */
        MaterialPhong.prototype.chromeDirection = function (val) {
            if (val === undefined)
                return this._chromeDirection;
            this._chromeDirection = val;
            if (this._chrome)
                this.materials[Trike.PassType.GBuffer].setUniform('useRefract', this._chromeDirection, false);
            return val;
        };
        /*
        * Gets or sets the bumpiness scale of the bump map.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialPhong.prototype.bumpScale = function (val) {
            if (val === undefined)
                return this._bumpScale;
            this._bumpScale = val;
            if (this._bump) {
                var gBuffer = this.materials[Trike.PassType.GBuffer];
                var gBuffer2 = this.materials[Trike.PassType.GBuffer2];
                gBuffer2.setUniform('bumpScale', val, false);
                if (gBuffer._uniforms['bumpScale'])
                    gBuffer.setUniform('bumpScale', val, false);
            }
            return this._bumpScale;
        };
        /*
        * Gets or sets the refraction ratio
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialPhong.prototype.refractionRatio = function (val) {
            if (val === undefined)
                return this._refractionRatio;
            this._refractionRatio = val;
            if (this._chrome)
                this.materials[Trike.PassType.GBuffer].setUniform('refractionRatio', val, false);
            return this._refractionRatio;
        };
        /*
        * Gets or sets the chrome combination method of the environment map
        * @param {ChromeCombination} val [Optional]
        * @returns {ChromeCombination}
        */
        MaterialPhong.prototype.chromeCombination = function (val) {
            if (val === undefined)
                return this._chromeCombination;
            this.materials[Trike.PassType.GBuffer].removeDefine('#define CHROME_METHOD ' + this._chromeCombination.toFixed(1));
            this._chromeCombination = val;
            this.materials[Trike.PassType.GBuffer].addDefine('#define CHROME_METHOD ' + this._chromeCombination.toFixed(1));
            return this._chromeCombination;
        };
        /*
        * Gets or sets the scale of the chrome reflectivity of the material. Values are from 0, being non reflective, to 1 being fully reflective.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialPhong.prototype.chromeReflectivity = function (val) {
            if (val === undefined)
                return this._chromeReflectivity;
            this._chromeReflectivity = val;
            if (this._chrome)
                this.materials[Trike.PassType.GBuffer].setUniform('chromeReflectivity', val, false);
            return this._chromeReflectivity;
        };
        /*
        * Gets or sets the scale of the reflectivity of the material. Values are from 0, being non reflective, to 1 being fully reflective.
        * @param {Color} val [Optional]
        * @returns {Color}
        */
        MaterialPhong.prototype.diffuse = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['diffuse'].value;
            this.materials[Trike.PassType.GBuffer].setUniform('diffuse', val, false);
            return val;
        };
        /*
        * Gets or sets specular light colour
        * @param {Color} val [Optional]
        * @returns {Color}
        */
        MaterialPhong.prototype.specular = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['specular'].value;
            this.materials[Trike.PassType.GBuffer].setUniform('specular', val, false);
            return val;
        };
        /*
        * Gets or sets the shininess of the specular component
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialPhong.prototype.shininess = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer2]._uniforms['shininess'].value;
            this.materials[Trike.PassType.GBuffer2].setUniform('shininess', val, false);
            return val;
        };
        /*
        * Gets or sets the texture that defines material translucency
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialPhong.prototype.translucencyMap = function (val) {
            if (val === undefined)
                return this._translucencyMap;
            if (this._translucencyMap && val) {
                this._translucencyMap = val;
                if (this._translucencyEnabled)
                    this.materials[Trike.PassType.GBuffer2].setUniform('translucencyMap', val, false);
                return val;
            }
            if (!this._translucencyMap && val) {
                this._translucencyMap = val;
                if (this._translucencyEnabled) {
                    this._setUV(true);
                    this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('translucencyMap', Trike.UniformType.TEXTURE, val), false);
                    this.materials[Trike.PassType.GBuffer2].addDefine(Trike.ShaderDefines.TRANSLUCENCY_MAP);
                }
            }
            else {
                this._translucencyMap = null;
                if (this._translucencyEnabled) {
                    this._setUV(false);
                    this.materials[Trike.PassType.GBuffer2].removeUniform('translucencyMap', false);
                    this.materials[Trike.PassType.GBuffer2].removeDefine(Trike.ShaderDefines.TRANSLUCENCY_MAP);
                }
            }
            return val;
        };
        /*
        * Gets or sets if translucency is enabled
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialPhong.prototype.translucencyEnabled = function (val) {
            if (val === undefined)
                return this._translucencyEnabled;
            if (this._translucencyEnabled === val)
                return val;
            if (val) {
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('translucencyScale', Trike.UniformType.FLOAT, this._translucencyScale), false);
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('translucencyDistortion', Trike.UniformType.FLOAT, this._translucencyDistortion), false);
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('translucencyPower', Trike.UniformType.FLOAT, this._translucencyPower), false);
                this.materials[Trike.PassType.GBuffer2].addDefine(Trike.ShaderDefines.TRANSLUCENCY_ENABLED);
            }
            else {
                this.materials[Trike.PassType.GBuffer2].removeUniform('translucencyScale', false);
                this.materials[Trike.PassType.GBuffer2].removeUniform('translucencyDistortion', false);
                this.materials[Trike.PassType.GBuffer2].removeUniform('translucencyPower', false);
                this.materials[Trike.PassType.GBuffer2].removeDefine(Trike.ShaderDefines.TRANSLUCENCY_ENABLED);
            }
            this._translucencyEnabled = val;
            return val;
        };
        /*
        * Gets or sets the translucency scale of the material. This is a uniform multiplier of the effect.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialPhong.prototype.translucencyScale = function (val) {
            if (val === undefined)
                return this._translucencyScale;
            this._translucencyScale = val;
            if (this._translucencyEnabled)
                this.materials[Trike.PassType.GBuffer2].setUniform('translucencyScale', val, false);
            return val;
        };
        /*
        * Gets or sets the translucency distortion of the material.
        * Modifies the light angle as it enters the material
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialPhong.prototype.translucencyDistortion = function (val) {
            if (val === undefined)
                return this._translucencyDistortion;
            this._translucencyDistortion = val;
            if (this._translucencyEnabled)
                this.materials[Trike.PassType.GBuffer2].setUniform('translucencyDistortion', val, false);
            return val;
        };
        /*
        * Gets or sets the translucency power of the material.
        * Increasing this has the effect of narrowing the area of the effect
        * @param {number} val [Optional]
        */
        MaterialPhong.prototype.translucencyPower = function (val) {
            if (val === undefined)
                return this._translucencyPower;
            this._translucencyPower = val;
            if (this._translucencyEnabled)
                this.materials[Trike.PassType.GBuffer2].setUniform('translucencyPower', val, false);
            return val;
        };
        return MaterialPhong;
    }(Trike.MaterialBasic));
    Trike.MaterialPhong = MaterialPhong;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A phong material shader that adds support for water functions
    */
    var MaterialWater = (function (_super) {
        __extends(MaterialWater, _super);
        function MaterialWater() {
            // Call the phong constructor
            _super.call(this);
            this._reflections = false;
            this._refractions = false;
            this._reflectionFresnelConstant = 1;
            this._reflectionFresnelPower = 5;
            this._siltiness = 0.1;
            // Noise
            this._noiseMap = null;
            this._noiseScale = 50;
            this._noisePeriod = 0.1;
            // Waves
            this._wavesMap = null;
            this._waveSpeedU = 1;
            this._waveSpeedV = 1;
            this._waveNoiseRatio = 0.5;
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('colorDeep', Trike.UniformType.COLOR3, new Trike.Color(0x164A7D)));
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('colorShallow', Trike.UniformType.COLOR3, new Trike.Color(0x51BDE8)));
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('deepness', Trike.UniformType.FLOAT, 50));
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('density', Trike.UniformType.FLOAT, 0.1));
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('normalMatrix', Trike.UniformType.MAT3, new Trike.Matrix3()));
            this.materials[Trike.PassType.GBuffer].addDefine(Trike.ShaderDefines.ATTR_NORMAL);
            this.materials[Trike.PassType.GBuffer].addAttribute(new Trike.AttributeVar('normal', Trike.AttributeType.NORMAL));
            // TODO: This wont entirely work if env maps are used (will be a duplicate)
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 0));
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 0));
            // TODO: Screenspace reflections? https://www.opengl.org/discussion_boards/showthread.php/181724-screen-space-reflections
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialWater.prototype.getVertexShader = function () {
            this._materialPassID = Trike.MaterialPass.getNewPassID();
            // Create the albedo pass
            this._noisePass = new Trike.MaterialPass(512, 512, this._materialPassID);
            this._noisePass.enabled = false;
            Trike.MaterialMulti.materialPasses.push(this._noisePass);
            // Create the noise material
            var noiseMaterial = new Trike.PassMaterial('Water Noise Pass', this);
            this.materials[this._materialPassID] = noiseMaterial;
            // Define the common uniforms of the material
            noiseMaterial.addUniform(new Trike.UniformVar('modelViewMatrix', Trike.UniformType.MAT4), true);
            noiseMaterial.addUniform(new Trike.UniformVar('projectionMatrix', Trike.UniformType.MAT4), true);
            noiseMaterial.addUniform(new Trike.UniformVar('customClipping', Trike.UniformType.FLOAT, 0), true);
            noiseMaterial.addUniform(new Trike.UniformVar('customClipPlane', Trike.UniformType.FLOAT4), true);
            noiseMaterial.addUniform(new Trike.UniformVar('time', Trike.UniformType.FLOAT, 0));
            noiseMaterial.addDefine('#define NOISE_PASS');
            noiseMaterial.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            noiseMaterial.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            if (this.hasDefine(Trike.ShaderDefines.ATTR_UV)) {
                noiseMaterial.addAttribute(new Trike.AttributeVar('uv', Trike.AttributeType.UV));
                noiseMaterial.addUniform(new Trike.UniformVar('uvScale', Trike.UniformType.FLOAT2, this.uvScale()));
                noiseMaterial.addDefine(Trike.ShaderDefines.ATTR_UV);
            }
            var material = this.materials[Trike.PassType.GBuffer];
            material.addUniform(new Trike.UniformVar('gBuffer2', Trike.UniformType.TEXTURE, null), false);
            material.addUniform(new Trike.UniformVar('cameraFar', Trike.UniformType.FLOAT, 0), false);
            return "\n\t\t\t\t// Declarations\n\t\t\t\t" + Trike.ShaderFragments.VertParams.defaults() + "\n\t\t\t\t" + Trike.ShaderFragments.VertParams.clippingParameters() + "\n\t\t\t\t" + Trike.ShaderFragments.VertParams.skinDeclarations() + "\n\n\t\t\t\t#if defined(NOISE_PASS) && defined(NOISE_MAP)\n\t\t\t\t\tuniform mat4 modelMatrix;\n\t\t\t\t\tvarying vec4 vWorldPosition;\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(PASS_GBUFFER)\n\n\t\t\t\t\t#if !defined(REFRACTION_MAP) && !defined(REFLECTION_MAP) && !(defined(PASS_SHADOW) && defined(SHADOW_TYPE_VSM))\n\t\t\t\t\t\tvarying vec4 clipPos;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t" + Trike.ShaderFragments.VertParams.envMap() + "\n\t\t\t\t\t" + Trike.ShaderFragments.VertParams.reflectionParams() + "\n\t\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.vertParams() + "\n\t\t\t\t#endif\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.skin() + "\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.skinTransform() + "\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.skinTransformNormals() + "\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.defaults() + "\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.clipping() + "\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.environmentMapping() + "\n\n\n\t\t\t\t\t#if defined(NOISE_PASS) && defined(NOISE_MAP)\n\t\t\t\t\t\tvWorldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if defined(PASS_GBUFFER)\n\n\t\t\t\t\t\t#if !defined(REFRACTION_MAP)\n\t\t\t\t\t\t\tclipPos = gl_Position;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t" + Trike.ShaderFragments.VertMain.environmentMapping() + "\n\t\t\t\t\t\t" + Trike.ShaderFragments.VertMain.reflection() + "\n\t\t\t\t\t\t" + Trike.ShaderFragments.VertMain.refraction() + "\n\t\t\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.vertMain() + "\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// We need to add the pass data\n\t\t\t\t\t" + Trike.ShaderFragments.Passes.vertNormDepthMain() + "\n\t\t\t\t}\n           ";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialWater.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t// Declarations\n\t\t\t" + Trike.ShaderFragments.FragParams.defaults() + "\n\t\t\t" + Trike.ShaderFragments.FragParams.clippingParams() + "\n\t\t\t" + Trike.ShaderFragments.FragParams.encodeNormal() + "\n\t\t\t" + Trike.ShaderFragments.FragParams.map() + "\n\t\t\t" + Trike.ShaderFragments.FragParams.bumpmapUniforms() + "\n\t\t\t" + Trike.ShaderFragments.FragParams.bumpmapFunctions() + "\n\t\t\t" + Trike.ShaderFragments.FragParams.vecToFloat() + "\n\t\t\t" + Trike.ShaderFragments.FragParams.floatToVec() + "\n\n\t\t\t#if defined(PASS_GBUFFER)\n\n\t\t\t\t" + Trike.ShaderFragments.FragParams.reflectionParams() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.environmentMapping() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.refractionParams() + "\n\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.fragParams() + "\n\n\t\t\t\t#if !defined(USE_ENV_MAP) && !defined(REFRACTION_MAP) && !defined(REFLECTION_MAP)\n\t\t\t\t\tuniform float viewHeight;\n\t\t\t\t\tuniform float viewWidth;\n\t\t\t\t#endif\n\n\t\t\t\t" + Trike.ShaderFragments.FragParams.environmentMapping() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.eyeRayVS() + "\n\n\t\t\t\t#ifdef USE_SPECULARMAP\n\t\t\t\t\tuniform sampler2D specularMap;\n\t\t\t\t#endif\n\n\t\t\t\tuniform vec3 diffuse;\n\t\t\t\tuniform vec3 specular;\n\t\t\t\tuniform vec3 emissive;\n\t\t\t\tuniform vec3 colorDeep;\n\t\t\t\tuniform vec3 colorShallow;\n\t\t\t\tuniform float deepness;\n\t\t\t\tuniform float density;\n\n\t\t\t\t#if !defined(REFRACTION_MAP)\n\t\t\t\t\tuniform float cameraFar;\n\t\t\t\t\tuniform sampler2D gBuffer2;\n\t\t\t\t#endif\n\n\t\t\t\t#if !defined(REFRACTION_MAP) && !defined(REFLECTION_MAP) && !(defined(PASS_SHADOW) && defined(SHADOW_TYPE_VSM))\n\t\t\t\t\tvarying vec4 clipPos;\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(NOISE_MAP)\n\t\t\t\t\tuniform sampler2D noiseMap;\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(REFLECTION_MAP)\n\t\t\t\t\tuniform float reflectionFresnelConstant;\n\t\t\t\t\tuniform float reflectionFresnelPower;\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(REFRACTION_MAP)\n\t\t\t\t\tuniform float siltiness;\n\t\t\t\t#endif\n\n\t\t\t\t" + Trike.ShaderFragments.LightingFunctions.fresnel() + "\n\n\t\t\t#elif defined(PASS_GBUFFER2)\n\t\t\t\tuniform float shininess;\n\t\t\t\tuniform float viewWidth;\n\t\t\t\tuniform float viewHeight;\n\n\t\t\t#elif defined(NOISE_PASS)\n\n\t\t\t\t#if defined(WAVES)\n\t\t\t\t\tuniform sampler2D waveSampler;\n\t\t\t\t\tuniform float waveSpeedU;\n\t\t\t\t\tuniform float waveSpeedV;\n\t\t\t\t\tuniform float waveNoiseRatio;\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(NOISE_MAP)\n\t\t\t\t\tuniform sampler2D noiseSampler;\n\t\t\t\t\tuniform float noiseScale;\n\t\t\t\t\tuniform float time;\n\t\t\t\t\tuniform float noisePeriod;\n\t\t\t\t\tvarying vec4 vWorldPosition;\n\n\t\t\t\t\tvec4 getNoise(vec2 uv, vec2 scale, float period )\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat t = time * period;\n\t\t\t\t\t\tvec2 uv0 = (uv / 103.0) + vec2(t / 17.0, t / 29.0);\n\t\t\t\t\t\tvec2 uv1 = uv / 107.0 - vec2(t / -19.0, t / 31.0);\n\t\t\t\t\t\tvec2 uv2 = uv / vec2(897.0, 983.0) + vec2(t / 101.0, t / 97.0);\n\t\t\t\t\t\tvec2 uv3 = uv / vec2(991.0, 877.0) - vec2(t / 109.0, t / -113.0);\n\n\t\t\t\t\t\tvec4 noise =\n\t\t\t\t\t\t(texture2D(noiseSampler, uv0 * scale * 0.01 )) +\n\t\t\t\t\t\t(texture2D(noiseSampler, uv1 * scale * 0.1 )) +\n\t\t\t\t\t\t(texture2D(noiseSampler, uv2 * scale * 0.3 )) +\n\t\t\t\t\t\t(texture2D(noiseSampler, uv3 * scale ));\n\n\t\t\t\t\t\treturn noise* 0.5 - 1.0;\n\t\t\t\t\t}\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\n\t\t\tvoid main()\n\t\t\t{\n\n\t\t\t\t" + Trike.ShaderFragments.FragMain.clippingTest() + "\n\n\t\t\t\t#if defined(NOISE_PASS)\n\n\t\t\t\t\t#if defined(NOISE_MAP)\n\t\t\t\t\t\tvec4 noise = getNoise(vWorldPosition.xz, vec2(noiseScale, noiseScale), noisePeriod );\n\t\t\t\t\t#else\n\t\t\t\t\t\tvec4 noise = vec4(0.0);\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if defined(WAVES)\n\t\t\t\t\t\tvec4 waveSample = texture2D( waveSampler, ( vUv + vec2(waveSpeedU * time, waveSpeedV * time ) ) );\n\t\t\t\t\t\tnoise = mix( noise, waveSample, waveNoiseRatio );\n\t\t\t\t\t#endif\n\n\t\t\t\t\tgl_FragColor = normalize( noise );\n\t\t\t\t\tgl_FragColor.w = 1.0;\n\t\t\t\t\treturn;\n\n\t\t\t\t#elif defined(PASS_GBUFFER)\n\n\t\t\t\t\tfloat specularStrength = 1.0;\n\n\t\t\t\t\t// Get the color from the map\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.alphaTest() + "\n\n\t\t\t\t\t#ifdef USE_SPECULARMAP\n\t\t\t\t\t\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\t\t\t\t\t\tspecularStrength = texelSpecular.r;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.environmentMapping() + "\n\n\t\t\t\t\tvec2 screenUV = ( gl_FragCoord.xy / vec2(viewWidth, viewHeight) );\n\t\t\t\t\tvec4 gBuffer2Sample = texture2D( gBuffer2, screenUV );\n\t\t\t\t\tfloat worldDepth = gBuffer2Sample.z;\n\t\t\t\t\tfloat currentDepth = clipPos.z / cameraFar;\n\t\t\t\t\tvec3 normal = normalize( normalView );\n\t\t\t\t\tvec3 eyeDirection = eyeRayVS( viewWidth, viewHeight );\n\n\t\t\t\t\t#if defined(NOISE_MAP)\n\t\t\t\t\t\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd( screenUV, noiseMap, bumpScale ) );\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if defined(REFLECTION_MAP)\n\t\t\t\t\t\tfloat reflectance = fresnel(eyeDirection, normal, reflectionFresnelPower, false) * reflectionFresnelConstant;\n\t\t\t\t\t#else\n\t\t\t\t\t\tfloat reflectance = 0.0;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// Trying to create a factor that is higher when viewed directly on\n\t\t\t\t\tfloat topDownBias = pow( 1.0 - reflectance, 10.0 ) * 0.3;\n\t\t\t\t\tfloat fogDensity = (1.0 - exp( -(worldDepth - currentDepth) * deepness ));\n\t\t\t\t\tfloat absorption = clamp( topDownBias + fogDensity, 0.0, 1.0 );\n\t\t\t\t\tabsorption = mix( absorption, 1.0, clamp(currentDepth * density, 0.0, 1.0) );\n\t\t\t\t\tvec3 waterColor = mix( colorShallow, colorDeep, absorption );\n\n\n\t\t\t\t\t// If refraction enabled\n\t\t\t\t\t#ifdef REFRACTION_MAP\n\t\t\t\t\t\tvec4 r1Distortion = vec4( normal.x * refractionDistortion, 0.0, 0.0, 0.0 );\n\t\t\t\t\t\tgBuffer2Sample = texture2D( gBuffer2, screenUV - r1Distortion.xz );\n\t\t\t\t\t\tfloat distortedDepth = gBuffer2Sample.z;\n\n\t\t\t\t\t\t// \tMakes sure the distortion of the refraction does not happen if the\n\t\t\t\t\t\t// \tobject is in front of the material being drawn\n\t\t\t\t\t\tif ( distortedDepth < currentDepth )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tr1Distortion.x = 0.0;\n\t\t\t\t\t\t\tr1Distortion.z = 0.0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvec3 refractionSample = vec3(texture2D(compositionPass, screenUV - r1Distortion.xz ));\n\t\t\t\t\t\trefractionSample = refractionSample * refractionSample;\n\t\t\t\t\t\tfloat opacity = clamp( mix( absorption, siltiness, ( 1.0 - absorption ) ), 0.0, 1.0 );\n\n\t\t\t\t\t\twaterColor = mix( refractionSample, waterColor, opacity );\n\t\t\t\t\t#endif\n\n\n\t\t\t\t\t// If reflection enabled\n\t\t\t\t\t#if defined(REFLECTION_MAP)\n\t\t\t\t\t\tvec4 r2Distortion = vec4( normal.x * mirrorDistortion, 0.0, normal.z * mirrorDistortion, 0.0 );\n\t\t\t\t\t\tvec3 mirrorSample = texture2DProj(reflectionSampler, mirrorCoord + r2Distortion ).xyz;\n\t\t\t\t\t\twaterColor = mix( waterColor, mirrorSample, clamp(reflectance, 0.0, 1.0) );\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if !defined(USE_MAP)\n\t\t\t\t\t\tvec4 texelColor = vec4(waterColor, 1.0);\n\t\t\t\t\t#else\n\t\t\t\t\t\ttexelColor.xyz = texelColor.xyz * waterColor;\n\t\t\t\t\t#endif\n\n\n\t\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.fragMain() + "\n\n\t\t\t\t\t#ifndef SHADOW_MAPPING\n\t\t\t\t\t\tfloat shadowAmount = 1.0;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// diffuse color in x\n\t\t\t\t\tgl_FragColor.x = vec3_to_float( diffuse * shadowAmount );\n\n\t\t\t\t\t// specular color in y\n\t\t\t\t\tgl_FragColor.y = vec3_to_float( specular * specularStrength * shadowAmount );\n\n\t\t\t\t\t// Albedo in Z\n\t\t\t\t\tgl_FragColor.z = vec3_to_float( texelColor.xyz );\n\n\t\t\t\t\t// We store the emmsive in w\n\t\t\t\t\tgl_FragColor.w = vec3_to_float( emissive * shadowAmount );\n\n\t\t\t\t//\tCustom normal handling\n\t\t\t\t#elif defined(PASS_GBUFFER2) && defined(CUSTOM_NORMAL)\n\n\t\t\t\t\tvec2 uvCoordinates = gl_FragCoord.xy / vec2( viewWidth, viewHeight );\n\t\t\t\t\tvec3 normal = normalize( normalView );\n\n\t\t\t\t\t#if defined(USE_BUMPMAP)\n\t\t\t\t\t\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd( uvCoordinates, bumpMap, bumpScale ) );\n\t\t\t\t\t#endif\n\n\t\t\t\t\tgl_FragColor.x = vec3_to_float( normal * 0.5 + 0.5 );\n\n\t\t\t\t#endif\n\n\n\t\t\t\t" + Trike.ShaderFragments.Passes.fragNormDepthMain() + "\n\t\t\t\t" + Trike.ShaderFragments.Passes.fragShadowMain() + "\n\t\t\t}\n            ";
        };
        /*
        * Adds or removes normal attributes to the Gbuffer pass material
        */
        MaterialWater.prototype._validate = function () {
            var gBuffer = this.materials[Trike.PassType.GBuffer];
            if (this.mirrorReflection()) {
                if (!gBuffer._uniforms['modelMatrix'])
                    gBuffer.addUniform(new Trike.UniformVar('modelMatrix', Trike.UniformType.MAT4));
            }
            else if (gBuffer._uniforms['modelMatrix'])
                gBuffer.removeUniform('modelMatrix');
            if (!gBuffer._uniforms['gBuffer2'])
                gBuffer.addUniform(new Trike.UniformVar('gBuffer2', Trike.UniformType.TEXTURE, null));
            if (!gBuffer._uniforms['cameraFar'])
                gBuffer.addUniform(new Trike.UniformVar('cameraFar', Trike.UniformType.FLOAT, 0), false);
        };
        /**
        * Gets or sets if refraction is enabled. The material must be transparent for this to work.
        * @param {boolean} val
        * @returns {boolean}
        */
        MaterialWater.prototype.refractionEnabled = function (val) {
            this.materials[Trike.PassType.GBuffer].removeUniform('cameraFar');
            var toRet = _super.prototype.refractionEnabled.call(this, val);
            if (val !== undefined) {
                this._refractions = val;
                if (val) {
                    this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('siltiness', Trike.UniformType.FLOAT, this._siltiness));
                    this.materials[Trike.PassType.GBuffer].removeUniform('refractionReflectivity');
                }
                else if (!val) {
                    this.materials[Trike.PassType.GBuffer].removeUniform('siltiness');
                    this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('cameraFar', Trike.UniformType.FLOAT, 0), false);
                }
            }
            return toRet;
        };
        /**
        * Adds or removes the properties for reflection
        * @param {boolean} val
        * @return {boolean}
        */
        MaterialWater.prototype.mirrorReflection = function (val) {
            var toRet = _super.prototype.mirrorReflection.call(this, val);
            if (val === undefined)
                return toRet;
            this._reflections = val;
            var gBuffer = this.materials[Trike.PassType.GBuffer];
            if (val) {
                gBuffer.addUniform(new Trike.UniformVar('reflectionFresnelConstant', Trike.UniformType.FLOAT, this._reflectionFresnelConstant));
                gBuffer.addUniform(new Trike.UniformVar('reflectionFresnelPower', Trike.UniformType.FLOAT, this._reflectionFresnelPower));
                gBuffer.addUniform(new Trike.UniformVar('invProjectionMatrix', Trike.UniformType.MAT4));
            }
            else {
                gBuffer.removeUniform('reflectionFresnelConstant');
                gBuffer.removeUniform('reflectionFresnelPower');
                gBuffer.removeUniform('invProjectionMatrix');
            }
            gBuffer.removeUniform('mirrorReflectivity');
            return toRet;
        };
        /*
        * Gets or sets the bumpiness scale of the bump map.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialWater.prototype.bumpScale = function (val) {
            if (val !== undefined && this.materials[Trike.PassType.GBuffer]._uniforms['bumpScale'])
                this.materials[Trike.PassType.GBuffer].setUniform('bumpScale', val, false);
            return _super.prototype.bumpScale.call(this, val);
        };
        /**
        * Gets or sets the waves map
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialWater.prototype.waveMap = function (val) {
            if (val === undefined)
                return this._wavesMap;
            var noisePass = this.materials[this._materialPassID];
            if (val && this._wavesMap) {
                this._wavesMap = val;
                noisePass.setUniform('waveSampler', val, true);
            }
            else if (val && !this._wavesMap) {
                this._wavesMap = val;
                noisePass.addDefine('#define WAVES');
                noisePass.addUniform(new Trike.UniformVar('waveSampler', Trike.UniformType.TEXTURE, val));
                noisePass.addUniform(new Trike.UniformVar('waveSpeedU', Trike.UniformType.FLOAT, this._waveSpeedU));
                noisePass.addUniform(new Trike.UniformVar('waveSpeedV', Trike.UniformType.FLOAT, this._waveSpeedV));
                noisePass.addUniform(new Trike.UniformVar('waveNoiseRatio', Trike.UniformType.FLOAT, this._waveNoiseRatio));
                this._enableNoiseMap(true);
            }
            else {
                this._wavesMap = null;
                noisePass.removeDefine('#define WAVES');
                noisePass.removeUniform('waveSampler');
                noisePass.removeUniform('waveSpeedU');
                noisePass.removeUniform('waveSpeedV');
                noisePass.removeUniform('waveNoiseRatio');
                this._enableNoiseMap(false);
            }
            return val;
        };
        /*
        * Gets or sets the U speed of the wave movement
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialWater.prototype.waveSpeedU = function (val) {
            if (val === undefined)
                return this._waveSpeedU;
            this._waveSpeedU = val;
            if (this._wavesMap)
                this.materials[this._materialPassID].setUniform('waveSpeedU', this._waveSpeedU, false);
            return val;
        };
        /*
        * Gets or sets the V speed of the wave movement
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialWater.prototype.waveSpeedV = function (val) {
            if (val === undefined)
                return this._waveSpeedV;
            this._waveSpeedV = val;
            if (this._wavesMap)
                this.materials[this._materialPassID].setUniform('waveSpeedV', this._waveSpeedV, false);
            return val;
        };
        /*
        * Gets or sets the wave to noise ratio. Values are from 0 to 1.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialWater.prototype.waveNoiseRatio = function (val) {
            if (val === undefined)
                return this._waveNoiseRatio;
            this._waveNoiseRatio = val;
            if (this._wavesMap)
                this.materials[this._materialPassID].setUniform('waveNoiseRatio', this._waveNoiseRatio, false);
            return val;
        };
        /**
        * Gets or sets the noise map
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialWater.prototype.noiseMap = function (val) {
            if (val === undefined)
                return this._noiseMap;
            var noisePass = this.materials[this._materialPassID];
            if (val && this._noiseMap) {
                this._noiseMap = val;
                noisePass.setUniform('noiseSampler', val, true);
            }
            else if (val && !this._noiseMap) {
                this._noiseMap = val;
                noisePass.addUniform(new Trike.UniformVar('noiseSampler', Trike.UniformType.TEXTURE, val), false);
                noisePass.addUniform(new Trike.UniformVar('modelMatrix', Trike.UniformType.MAT4), false);
                noisePass.addUniform(new Trike.UniformVar('noiseScale', Trike.UniformType.FLOAT, this._noiseScale));
                noisePass.addUniform(new Trike.UniformVar('noisePeriod', Trike.UniformType.FLOAT, this._noisePeriod));
                noisePass.addDefine('#define NOISE_MAP');
                this._enableNoiseMap(true);
            }
            else {
                this._noiseMap = null;
                noisePass.removeUniform('noiseSampler');
                noisePass.removeUniform('modelMatrix');
                noisePass.removeUniform('noiseScale');
                noisePass.removeUniform('noisePeriod');
                noisePass.addDefine('#define NOISE_MAP');
                this._enableNoiseMap(false);
            }
            return val;
        };
        /**
        * Enables or disables the noise map pass
        */
        MaterialWater.prototype._enableNoiseMap = function (val) {
            if (val) {
                this.bumpMap(this._noisePass.renderTarget);
                this.materials[Trike.PassType.GBuffer].addDefine('#define NOISE_MAP');
                this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('noiseMap', Trike.UniformType.TEXTURE, this._noisePass.renderTarget));
                this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('bumpScale', Trike.UniformType.FLOAT, this.bumpScale()));
                this.materials[Trike.PassType.GBuffer2].addDefine('#define CUSTOM_NORMAL');
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 0));
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 0));
                this.materials[Trike.PassType.GBuffer].addDefine(Trike.ShaderDefines.STANDARD_DERIVATIVES);
                this.materials[Trike.PassType.GBuffer].addDefine(Trike.ShaderDefines.BUMP_MAP);
                this._noisePass.enabled = true;
            }
            else if (!this._noiseMap && !this._wavesMap) {
                this._noisePass.enabled = false;
                this.materials[Trike.PassType.GBuffer].removeDefine('#define NOISE_MAP');
                this.materials[Trike.PassType.GBuffer].removeUniform('noiseMap');
                this.materials[Trike.PassType.GBuffer].removeUniform('bumpScale');
                this.materials[Trike.PassType.GBuffer2].removeDefine('#define CUSTOM_NORMAL');
                this.materials[Trike.PassType.GBuffer2].removeUniform('viewWidth');
                this.materials[Trike.PassType.GBuffer2].removeUniform('viewHeight');
                this.materials[Trike.PassType.GBuffer].removeDefine(Trike.ShaderDefines.STANDARD_DERIVATIVES);
                this.materials[Trike.PassType.GBuffer].removeDefine(Trike.ShaderDefines.BUMP_MAP);
                this.bumpMap(null);
            }
        };
        /*
        * Gets or sets the reflection fresnal of the water.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialWater.prototype.reflectionFresnelConstant = function (val) {
            if (val === undefined)
                return this._reflectionFresnelConstant;
            this._reflectionFresnelConstant = val;
            if (this._reflections === false)
                return this._reflectionFresnelConstant;
            this._reflectionFresnelConstant = val;
            this.materials[Trike.PassType.GBuffer].setUniform('reflectionFresnelConstant', val, false);
            return this._reflectionFresnelConstant;
        };
        /*
        * Gets or sets the fresnal power of the water.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialWater.prototype.reflectionFresnelPower = function (val) {
            if (val === undefined)
                return this._reflectionFresnelPower;
            this._reflectionFresnelPower = val;
            if (this._reflections === false)
                return this._reflectionFresnelPower;
            this._reflectionFresnelPower = val;
            this.materials[Trike.PassType.GBuffer].setUniform('reflectionFresnelPower', val, false);
            return this._reflectionFresnelPower;
        };
        /*
        * Gets or sets the deepness of the water. Higher values mean the water is deeper looking
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialWater.prototype.deepness = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['deepness'].value;
            this.materials[Trike.PassType.GBuffer].setUniform('deepness', val, false);
            return val;
        };
        /*
        * Gets or sets the siltiness of the water. Higher values mean more opaque water
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialWater.prototype.siltiness = function (val) {
            if (val === undefined)
                return this._siltiness;
            this._siltiness = val;
            if (this._refractions === false)
                return this._siltiness;
            this.materials[Trike.PassType.GBuffer].setUniform('siltiness', val, false);
            return this._siltiness;
        };
        /*
        * Gets or sets the density of the water. Higher values mean more absorptive water
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialWater.prototype.density = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['density'].value;
            this.materials[Trike.PassType.GBuffer].setUniform('density', val, false);
            return val;
        };
        /*
        * Gets or sets the shallow water color
        * @param {Color} val [Optional]
        * @returns {Color}
        */
        MaterialWater.prototype.colorShallow = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['colorShallow'].value;
            this.materials[Trike.PassType.GBuffer].setUniform('colorShallow', val, false);
            return val;
        };
        /*
        * Gets or sets the deep water color
        * @param {Color} val [Optional]
        * @returns {Color}
        */
        MaterialWater.prototype.colorDeep = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['colorDeep'].value;
            this.materials[Trike.PassType.GBuffer].setUniform('colorDeep', val, false);
            return val;
        };
        /**
        * Gets or sets the noise scale
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialWater.prototype.noiseScale = function (val) {
            if (val === undefined)
                return this._noiseScale;
            this._noiseScale = val;
            if (this._noiseMap)
                this.materials[this._materialPassID]._uniforms['noiseScale'].value = val;
            return val;
        };
        /**
        * Gets or sets the noise period
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialWater.prototype.noisePeriod = function (val) {
            if (val === undefined)
                return this._noisePeriod;
            this._noisePeriod = val;
            if (this._noiseMap)
                this.materials[this._materialPassID]._uniforms['noisePeriod'].value = val;
            return val;
        };
        return MaterialWater;
    }(Trike.MaterialPhong));
    Trike.MaterialWater = MaterialWater;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * An extremely basic material used for rendering a texture onto screen quads
    */
    var MaterialScreenQuad = (function (_super) {
        __extends(MaterialScreenQuad, _super);
        function MaterialScreenQuad() {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.CreateGBuffer);
            this._map = null;
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('modelViewMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('projectionMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('map', Trike.UniformType.TEXTURE), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            this.addAttribute(new Trike.AttributeVar('uv', Trike.AttributeType.UV));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.addDefine(Trike.ShaderDefines.ATTR_UV);
        }
        return MaterialScreenQuad;
    }(Trike.MaterialMulti));
    Trike.MaterialScreenQuad = MaterialScreenQuad;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * This is an advanced shader that programmatically draws a planet atmosphere and its interactions with
    * a sun. In Trike this shader is used in the SkyboxAtmospheric class. Because the shader is an expensive one
    * to use, the skybox uses it only when it needs to. The shader takes in camera information and draws the
    * atmosphefogColorre onto a plane. The skybox creates a cube texture and gets the shader to draw each of the sides.
    * This drawn texture can then be used on the skybox as a day time texture.
    */
    var MaterialSkyAtmospheric = (function (_super) {
        __extends(MaterialSkyAtmospheric, _super);
        function MaterialSkyAtmospheric(nightColor) {
            if (nightColor === void 0) { nightColor = new Trike.Color(0x3E4B61); }
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Albedo] = new Trike.PassMaterial('Atmospheric Pass', this);
            this.uniformUpdated = true;
            this.addUniform(new Trike.UniformVar('modelViewMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('projectionMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('modelMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('luminance', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('turbidity', Trike.UniformType.FLOAT, 2), true);
            this.addUniform(new Trike.UniformVar('reileigh', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('mieCoefficient', Trike.UniformType.FLOAT, 0.005), true);
            this.addUniform(new Trike.UniformVar('mieDirectionalG', Trike.UniformType.FLOAT, 0.98), true);
            this.addUniform(new Trike.UniformVar('alpha', Trike.UniformType.FLOAT, 50), true);
            this.addUniform(new Trike.UniformVar('sunPosition', Trike.UniformType.FLOAT3, new Trike.Vec3()), true);
            this.addUniform(new Trike.UniformVar('nightColor', Trike.UniformType.COLOR3, nightColor), true);
            this.addUniform(new Trike.UniformVar('earthAmbience', Trike.UniformType.COLOR3, new Trike.Color(0x241A11)), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.addDefine(Trike.ShaderDefines.GAMA_INPUT);
            // Create the shaders
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.cullMode = Trike.CullFormat.Front;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialSkyAtmospheric.prototype.getVertexShader = function () {
            return "\n\t\t\t\t" + Trike.ShaderFragments.VertParams.defaults() + "\n\t\t\t\tuniform mat4 modelMatrix;\n\t\t\t\tvarying vec3 vWorldPosition;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tvWorldPosition = worldPosition.xyz;\n\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.defaults() + "\n\t\t\t\t}\n\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialSkyAtmospheric.prototype.getFragmentShader = function () {
            return "\n\t\t\t\tuniform vec3 sunPosition;\n\t\t\t\tvarying vec3 vWorldPosition;\n\t\t\t\tvec3 cameraPos = vec3(0., 0., 0.);\n\n\t\t\t\tuniform float luminance;\n\t\t\t\tuniform float turbidity;\n\t\t\t\tuniform float reileigh;\n\t\t\t\tuniform float mieCoefficient;\n\t\t\t\tuniform float mieDirectionalG;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform vec3 earthAmbience;\n\n\t\t\t\tuniform vec3 nightColor;\n\t\t\t\t#ifdef NIGHT_MAP\n\t\t\t\t\tuniform samplerCube night;\n\t\t\t\t\tuniform vec4 quatNight;\n\t\t\t\t#endif\n\n\t\t\t\t// Horizon fog haze\n\t\t\t\t#ifdef FOG\n\t\t\t\t\tuniform float fogMin;\n\t\t\t\t\tuniform float fogMax;\n\t\t\t\t\tuniform vec3 fogColor;\n\t\t\t\t#endif\n\n\t\t\t\tvec3 sunDirection = normalize(sunPosition);\n\t\t\t\tfloat reileighCoefficient = reileigh;\n\n\t\t\t\t// constants for atmospheric scattering\n\t\t\t\tconst float e = 2.71828182845904523536028747135266249775724709369995957;\n\t\t\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\t\t\tconst float n = 1.0003; // refractive index of air\n\t\t\t\tconst float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n\t\t\t\tconst float pn = 0.035;\t// depolatization factor for standard air\n\n\t\t\t\t// wavelength of used primaries, according to preetham\n\t\t\t\tconst vec3 lambda = vec3(680E-9, 550E-9, 450E-9);\n\n\t\t\t\t// K coefficient for the primaries\n\t\t\t\tconst vec3 K = vec3(0.686, 0.678, 0.666);\n\t\t\t\tconst float v = 4.0;\n\n\t\t\t\t// optical length at zenith for molecules\n\t\t\t\tconst float rayleighZenithLength = 8.4E3;\n\t\t\t\tconst float mieZenithLength = 1.25E3;\n\t\t\t\tconst vec3 up = vec3(0.0, 1.0, 0.0);\n\n\t\t\t\tconst float EE = 1000.0;\n\t\t\t\tconst float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324; // 66 arc seconds -> degrees, and the cosine of that\n\n\t\t\t\t// Earth shadow hack\n\t\t\t\tconst float cutoffAngle = pi/1.95;\n\t\t\t\tconst float steepness = 1.5;\n\n\t\t\t\tvec3 totalRayleigh(vec3 lambda)\n\t\t\t\t{\n\t\t\t\t\treturn (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn));\n\t\t\t\t}\n\n\t\t\t\t// see http://blenderartists.org/forum/showthread.php?321110-Shaders-and-Skybox-madness\n\t\t\t\t// A simplied version of the total Reayleigh scattering to works on browsers that use ANGLE\n\t\t\t\tvec3 simplifiedRayleigh()\n\t\t\t\t{\n\t\t\t\t\treturn 0.0005 / vec3(94, 40, 18);\n\t\t\t\t}\n\n\t\t\t\tfloat rayleighPhase(float cosTheta)\n\t\t\t\t{\n\t\t\t\t\treturn (3.0 / (16.0*pi)) * (1.0 + pow(cosTheta, 2.0));\n\t\t\t\t}\n\n\t\t\t\tvec3 totalMie(vec3 lambda, vec3 K, float T)\n\t\t\t\t{\n\t\t\t\t\tfloat c = (0.2 * T ) * 10E-18;\n\t\t\t\t\treturn 0.434 * c * pi * pow((2.0 * pi) / lambda, vec3(v - 2.0)) * K;\n\t\t\t\t}\n\n\t\t\t\tfloat hgPhase(float cosTheta, float g)\n\t\t\t\t{\n\t\t\t\t\treturn (1.0 / (4.0*pi)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));\n\t\t\t\t}\n\n\t\t\t\tfloat sunIntensity(float zenithAngleCos)\n\t\t\t\t{\n\t\t\t\t\treturn EE * max(0.0, 1.0 - exp(-((cutoffAngle - acos(zenithAngleCos))/steepness)));\n\t\t\t\t}\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\t#if defined(NIGHT_MAP) || defined(FOG)\n\t\t\t\t\t\tfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// Used for fog calculations\n\t\t\t\t\tvec3 eyedir = normalize(vWorldPosition.xyz);\n\t\t\t\t\teyedir = ( eyedir + 1.0 ) * 0.5;\n\t\t\t\t\tfloat yPosition = eyedir.y;\n\n\t\t\t\t\tfloat sunfade = 1.0-clamp( 1.0 - exp( ( sunPosition.y / 450000.0 )), 0.0, 1.0);\n\t\t\t\t\treileighCoefficient = reileighCoefficient - ( 1.0 * ( 1.0 - sunfade ));\n\t\t\t\t\tfloat sunE = sunIntensity( dot(sunDirection, up) );\n\n\t\t\t\t\t// extinction (absorbtion + out scattering)\n\t\t\t\t\t// rayleigh coefficients\n\t\t\t\t\tvec3 betaR = simplifiedRayleigh() * reileighCoefficient;\n\n\t\t\t\t\t// mie coefficients\n\t\t\t\t\tvec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;\n\n\t\t\t\t\t// optical length\n\t\t\t\t\t// cutoff angle at 90 to avoid singularity in next formula.\n\t\t\t\t\tfloat zenithAngle = acos( max( 0.0, dot( up, normalize( vWorldPosition - cameraPos ))));\n\t\t\t\t\tfloat sR = rayleighZenithLength / (cos( zenithAngle ) + 0.15 * pow( 93.885 - (( zenithAngle * 180.0) / pi ), -1.253 ));\n\t\t\t\t\tfloat sM = mieZenithLength / (cos( zenithAngle ) + 0.15 * pow( 93.885 - (( zenithAngle * 180.0) / pi ), -1.253 ));\n\n\t\t\t\t\t// combined extinction factor\n\t\t\t\t\tvec3 Fex = exp(-( betaR * sR + betaM * sM ));\n\n\t\t\t\t\t// in scattering\n\t\t\t\t\tfloat cosTheta = dot( normalize( vWorldPosition - cameraPos ), sunDirection );\n\n\t\t\t\t\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n\t\t\t\t\tvec3 betaRTheta = betaR * rPhase;\n\n\t\t\t\t\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );\n\t\t\t\t\tvec3 betaMTheta = betaM * mPhase;\n\n\t\t\t\t\tvec3 Lin = pow( sunE * ( ( betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex), vec3(1.5) );\n\t\t\t\t\tLin *= mix(vec3( 1.0 ),pow( sunE * ( (betaRTheta + betaMTheta) / (betaR + betaM) ) * Fex,vec3(1.0/2.0)),clamp( pow( 1.0 - dot( up, sunDirection ), 5.0 ), 0.0, 1.0));\n\n\t\t\t\t\tvec3 direction = normalize(vWorldPosition - cameraPos);\n\t\t\t\t\tfloat theta = acos(direction.y); // elevation --> y-axis, [-pi/2, pi/2]\n\t\t\t\t\tfloat phi = atan(direction.z, direction.x); // azimuth --> x-axis [-pi/2, pi/2]\n\t\t\t\t\tvec2 uv = vec2(phi, theta) / vec2(2.0*pi, pi) + vec2(0.5, 0.0);\n\t\t\t\t\tvec3 L0 = vec3(0.1) * Fex;\n\n\t\t\t\t\t// composition + solar disc\n\t\t\t\t\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n\t\t\t\t\tL0 += ( sunE * 19000.0 * Fex ) * sundisk;\n\n\t\t\t\t\tvec3 texColor = ( Lin + L0 );\n\t\t\t\t\ttexColor *= 0.04 ;\n\t\t\t\t\ttexColor += vec3( 0.0, 0.001, 0.0025 ) * 0.3;\n\n\t\t\t\t\tfloat g_fMaxLuminance = 1.0;\n\t\t\t\t\tfloat fLumScaled = 0.1 / luminance;\n\t\t\t\t\tfloat fLumCompressed = ( fLumScaled * (1.0 + (fLumScaled / (g_fMaxLuminance * g_fMaxLuminance))) ) / (1.0 + fLumScaled);\n\n\t\t\t\t\tfloat ExposureBias = fLumCompressed;\n\n\t\t\t\t\tvec3 gamaColor = ( log2( 2.0 / pow( luminance, 4.0 ))) * texColor;\n\n\t\t\t\t\t#ifdef NIGHT_MAP\n\t\t\t\t\t\tvec3 cubeNormNight = vec3( flipNormal * vWorldPosition.x, vWorldPosition.yz );\n\n\t\t\t\t\t\t// Rotate the normal using a quaternian\n\t\t\t\t\t\tcubeNormNight = cubeNormNight + 2.0 * cross( cross( cubeNormNight, quatNight.xyz ) + quatNight.w * cubeNormNight, quatNight.xyz );\n\t\t\t\t\t\tvec4 finalNightColor = textureCube( night, cubeNormNight );\n\t\t\t\t\t\t#if defined(GAMA_INPUT)\n\t\t\t\t\t\t\tfinalNightColor.xyz = finalNightColor.xyz * finalNightColor.xyz;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\tfinalNightColor.xyz = finalNightColor.xyz * nightColor.xyz;\n\n\t\t\t\t\t#else\n\t\t\t\t\t\tvec4 finalNightColor = vec4( nightColor.xyz, 1.0 );\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// Night Fog\n\t\t\t\t\t#ifdef FOG\n\t\t\t\t\t\tvec3 fColor = fogColor * fogColor;\n\t\t\t\t\t\tfloat fogAmount = ( 1.0 - smoothstep( fogMin, fogMax, yPosition) );\n\t\t\t\t\t\tfinalNightColor.xyz = mix( finalNightColor.xyz, fColor, fogAmount );\n\t\t\t\t\t#endif\n\n\t\t\t\t\tvec3 color = gamaColor;\n\t\t\t\t\tvec4 finalDayColor = vec4(color, 1.0);\n\t\t\t\t\tfloat alphaMix = 1.0 - smoothstep( 0.0, 1.0, length(gamaColor) * alpha );\n\n\t\t\t\t\t// Defines the 'earth/horizon fog'\n\t\t\t\t\tfinalDayColor.xyz = mix( finalDayColor.xyz, earthAmbience, ( 1.0 - smoothstep( 0.1, 0.55, yPosition) ) );\n\n\t\t\t\t\t//\tBlend the day and night colors\n\t\t\t\t\tgl_FragColor.xyz = mix( finalDayColor, finalNightColor, alphaMix ).xyz;\n\t\t\t\t\tgl_FragColor.a = 1.0;\n\t\t\t\t}\n\t\t\t";
        };
        return MaterialSkyAtmospheric;
    }(Trike.MaterialMulti));
    Trike.MaterialSkyAtmospheric = MaterialSkyAtmospheric;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A material for rendering skyboxes. A skybox material can optionally represent both day and night cycles.
    * You can use cube textures for both day and night as well as colors and mix them using the ratio function.
    */
    var MaterialSkySimple = (function (_super) {
        __extends(MaterialSkySimple, _super);
        function MaterialSkySimple(dayColor, nightColor) {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Albedo] = new Trike.PassMaterial('Simple Skybox', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('modelViewMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('projectionMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('modelMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('ratio', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('dayColor', Trike.UniformType.COLOR3, dayColor), true);
            this.addUniform(new Trike.UniformVar('nightColor', Trike.UniformType.COLOR3, nightColor), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.addDefine(Trike.ShaderDefines.GAMA_INPUT);
            this.uniformUpdated = true;
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.cullMode = Trike.CullFormat.Front;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialSkySimple.prototype.getVertexShader = function () {
            return "\n\t\t\t" + Trike.ShaderFragments.VertParams.defaults() + "\n\n\t\t\tvarying vec3 vWorldPosition;\n\t\t\tuniform mat4 modelMatrix;\n\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\t\tvWorldPosition = worldPosition.xyz;\n\t\t\t\t" + Trike.ShaderFragments.VertMain.defaults() + "\n\t\t\t}\n\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialSkySimple.prototype.getFragmentShader = function () {
            return "\n\t\t\t// Custom declarations\n\t\t\tuniform float ratio;\n\n\t\t\t#ifdef DAY_MAP\n\t\t\t\tuniform samplerCube daySampler;\n\t\t\t\tuniform vec4 quatDay;\n\t\t\t#endif\n\n\t\t\t#ifdef NIGHT_MAP\n\t\t\t\tuniform samplerCube nightSampler;\n\t\t\t\tuniform vec4 quatNight;\n\t\t\t#endif\n\n\t\t\tvarying vec3 vWorldPosition;\n\n\t\t\t// Textures\n\t\t\tuniform vec3 nightColor;\n\t\t\tuniform vec3 dayColor;\n\n\t\t\t// Horizon fog haze\n\t\t\t#ifdef FOG\n\t\t\t\tuniform float fogMin;\n\t\t\t\tuniform float fogMax;\n\t\t\t\tuniform vec3 fogColor;\n\t\t\t#endif\n\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\t\t\t\tvec3 eyedir = normalize( vec3( flipNormal * vWorldPosition.x, vWorldPosition.yz ) );\n\t\t\t\teyedir = ( eyedir + 1.0 ) * 0.5;\n\n\t\t\t\t#ifdef DAY_MAP\n\t\t\t\t\tvec3 cubeNormDay = vec3( flipNormal * vWorldPosition.x, vWorldPosition.yz );\n\t\t\t\t\t// Rotatet the normal using a quaternian\n\t\t\t\t\tcubeNormDay = cubeNormDay + 2.0 * cross( cross( cubeNormDay, quatDay.xyz ) + quatDay.w * cubeNormDay, quatDay.xyz );\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef NIGHT_MAP\n\t\t\t\t\tvec3 cubeNormNight = vec3( flipNormal * vWorldPosition.x, vWorldPosition.yz );\n\t\t\t\t\t// Rotate the normal using a quaternian\n\t\t\t\t\tcubeNormNight = cubeNormNight + 2.0 * cross( cross( cubeNormNight, quatNight.xyz ) + quatNight.w * cubeNormNight, quatNight.xyz );\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef DAY_MAP\n\t\t\t\t\tvec4 finalDayColor = textureCube( daySampler, cubeNormDay );\n\t\t\t\t\t#if defined(GAMA_INPUT)\n\t\t\t\t\t\tfinalDayColor.xyz = finalDayColor.xyz * finalDayColor.xyz;\n\t\t\t\t\t#endif\n\t\t\t\t\tfinalDayColor.xyz = finalDayColor.xyz * dayColor.xyz;\n\t\t\t\t#else\n\t\t\t\t\tvec4 finalDayColor = vec4( dayColor.xyz, 1.0 );\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef NIGHT_MAP\n\t\t\t\t\tvec4 finalNightColor = textureCube( nightSampler, cubeNormNight );\n\t\t\t\t\t#if defined(GAMA_INPUT)\n\t\t\t\t\t\tfinalNightColor.xyz = finalNightColor.xyz * finalNightColor.xyz;\n\t\t\t\t\t#endif\n\t\t\t\t\tfinalNightColor.xyz = finalNightColor.xyz * nightColor.xyz;\n\t\t\t\t#else\n\t\t\t\t\tvec4 finalNightColor = vec4( nightColor.xyz, 1.0 );\n\t\t\t\t#endif\n\n\t\t\t\t//\tAdd the texture\n\t\t\t\t#if defined(ALPHA_MIX)\n\t\t\t\t\tgl_FragColor.xyz = mix( finalDayColor, finalNightColor, finalDayColor.a * ratio ).xyz;\n\t\t\t\t#else\n\t\t\t\t\tgl_FragColor.xyz = mix( finalDayColor, finalNightColor, ratio ).xyz;\n\t\t\t\t#endif\n\n\t\t\t\t//\tFog\n\t\t\t\t#ifdef FOG\n\n\t\t\t\t\tfloat yPosition = eyedir.y;\n\t\t\t\t\tvec3 fColor = fogColor * fogColor;\n\t\t\t\t\tfloat fogAmount = ( 1.0 - smoothstep( fogMin, fogMax, yPosition) );\n\t\t\t\t\tvec3 finalColour = mix( gl_FragColor.xyz, fColor, fogAmount );\n\n\t\t\t\t\tgl_FragColor.xyz = finalColour;\n\n\t\t\t\t#endif\n\t\t\t\tgl_FragColor.w = 1.0;\n\t\t\t}\n\t\t\t";
        };
        return MaterialSkySimple;
    }(Trike.MaterialMulti));
    Trike.MaterialSkySimple = MaterialSkySimple;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * This material draws a flat ambient light onto its light mesh
    */
    var MaterialLightAmbient = (function (_super) {
        __extends(MaterialLightAmbient, _super);
        function MaterialLightAmbient() {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Lights] = new Trike.PassMaterial('Ambient Light', this);
            // Define the commopn uniforms of the material
            this.addUniform(new Trike.UniformVar('gBuffer', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('lightColor', Trike.UniformType.COLOR3), true);
            this.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('limitScreenQuad', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('minMax', Trike.UniformType.FLOAT4, new Trike.Vec4(-1, -1, 1, 1)), true);
            this.addUniform(new Trike.UniformVar('lightIntensity', Trike.UniformType.FLOAT, 1), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.addDefine(Trike.ShaderDefines.QUAD_LIGHTING);
            this.addDefine(Trike.ShaderDefines.GAMA_INPUT);
            this.materials[Trike.PassType.Lights].blendMode = Trike.BlendMode.Additive;
            this.materials[Trike.PassType.Lights].depthWrite = false;
            // Create the shaders
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialLightAmbient.prototype.getVertexShader = function () {
            return "\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\t" + Trike.ShaderFragments.VertParams.screenQuadBoundaries() + "\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t    gl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.checkBoundaries() + "\n\t\t\t\t}\n\n\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialLightAmbient.prototype.getFragmentShader = function () {
            return "\n\t\t\t\tuniform sampler2D gBuffer;\n\t\t\t\tuniform vec3 lightColor;\n\t\t\t\tuniform float viewHeight;\n\t\t\t\tuniform float viewWidth;\n                uniform float lightIntensity;\n\n\t\t\t\t" + Trike.ShaderFragments.FragParams.vecToFloat() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.floatToVec() + "\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.quadTexCoord() + "\n\n\t\t\t\t\tvec4 gBufferSample = texture2D( gBuffer, texCoord );\n\t\t\t\t\tvec3 emissiveColor = float_to_vec3( abs( gBufferSample.w ) );\n\t\t\t\t\tvec3 textureMap = float_to_vec3( abs( gBufferSample.z ) );\n\n\t\t\t\t\t#ifdef GAMA_INPUT\n                \t\ttextureMap = textureMap * textureMap;\n\t\t\t\t\t#endif\n\n\t\t\t\t\tgl_FragColor.xyz = lightIntensity * lightColor * emissiveColor * textureMap;\n\t\t\t\t\tgl_FragColor.w = 1.0;\n\t\t\t\t}\n\n\t\t\t";
        };
        return MaterialLightAmbient;
    }(Trike.MaterialMulti));
    Trike.MaterialLightAmbient = MaterialLightAmbient;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * This material draws an ambient light from a generated irradience map from an atmospheric environment
    */
    var MaterialLightAtmospheric = (function (_super) {
        __extends(MaterialLightAtmospheric, _super);
        function MaterialLightAtmospheric() {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this._flipNormal = -1;
            this.materials[Trike.PassType.Lights] = new Trike.PassMaterial('Atmospheric Light', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('gBuffer', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('gBuffer2', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('lightColor', Trike.UniformType.COLOR3), true);
            this.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('limitScreenQuad', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('minMax', Trike.UniformType.FLOAT4, new Trike.Vec4(-1, -1, 1, 1)), true);
            this.addUniform(new Trike.UniformVar('lightIntensity', Trike.UniformType.FLOAT, 1), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.addDefine(Trike.ShaderDefines.QUAD_LIGHTING);
            this.addDefine(Trike.ShaderDefines.GAMA_INPUT);
            this.materials[Trike.PassType.Lights].blendMode = Trike.BlendMode.Additive;
            this.materials[Trike.PassType.Lights].depthWrite = false;
            // Create the shaders
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialLightAtmospheric.prototype.getVertexShader = function () {
            return "\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\t" + Trike.ShaderFragments.VertParams.screenQuadBoundaries() + "\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t    gl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.checkBoundaries() + "\n\t\t\t\t}\n\n\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialLightAtmospheric.prototype.getFragmentShader = function () {
            return "\n\t\t\t\t#if defined(SKY_TEXTURE)\n\t\t\t\t\tuniform samplerCube sampler;\n\t\t\t\t\tuniform float flipNormal;\n\t\t\t\t\tuniform mat4 viewMat;\n\t\t\t\t#endif\n\t\t\t\tuniform sampler2D gBuffer2;\n\t\t\t\tuniform sampler2D gBuffer;\n\t\t\t\tuniform vec3 lightColor;\n\t\t\t\tuniform float viewHeight;\n\t\t\t\tuniform float viewWidth;\n                uniform float lightIntensity;\n\n\n\n\n\t\t\t\t" + Trike.ShaderFragments.FragParams.vecToFloat() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.floatToVec() + "\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.quadTexCoord() + "\n\t\t\t\t\tvec4 gBuffer2Sample = texture2D( gBuffer2, texCoord );\n\t\t\t\t\tvec3 normal = normalize( float_to_vec3( abs( gBuffer2Sample.x ) ) * 2.0 - 1.0 );\n\n\t\t\t\t\tvec4 gBufferSample = texture2D( gBuffer, texCoord );\n\t\t\t\t\tvec3 emissiveColor = float_to_vec3( abs( gBufferSample.w ) );\n\t\t\t\t\tvec3 textureMap = float_to_vec3( abs( gBufferSample.z ) );\n\n\t\t\t\t\t#ifdef GAMA_INPUT\n                \t\ttextureMap = textureMap * textureMap;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if defined(SKY_TEXTURE)\n\t\t\t\t\t\tvec3 worldNormal = normalize( vec3( vec4(normal, 0.0) * viewMat ) );\n\t\t\t\t\t\tvec3 worldCoords = vec3( flipNormal * worldNormal.x, worldNormal.yz );\n\t\t\t\t\t\tvec3 irradience =  textureCube(sampler, worldCoords).rgb;\n\t\t\t\t\t\tgl_FragColor.xyz = lightIntensity * lightColor * emissiveColor * textureMap * irradience;\n\t\t\t\t\t#else\n\t\t\t\t\t\tgl_FragColor.xyz = lightIntensity * lightColor * emissiveColor * textureMap;\n\t\t\t\t\t#endif\n\n\t\t\t\t\tgl_FragColor.w = 1.0;\n\t\t\t\t}\n\t\t\t";
        };
        MaterialLightAtmospheric.prototype.flipNormal = function (val) {
            if (val === undefined)
                return (this._flipNormal === -1 ? false : true);
            this._flipNormal = (val ? 1 : -1);
            if (this._uniforms['flipNormal'])
                this.setUniform('flipNormal', this._flipNormal, true);
            return val;
        };
        MaterialLightAtmospheric.prototype.setSky = function (val) {
            if (val) {
                this.addUniform(new Trike.UniformVar('sampler', Trike.UniformType.TEXTURE_CUBE), true);
                this.addUniform(new Trike.UniformVar('viewMat', Trike.UniformType.MAT4), true);
                this.addUniform(new Trike.UniformVar('flipNormal', Trike.UniformType.FLOAT, this._flipNormal), true);
                this.addDefine('#define SKY_TEXTURE');
            }
            else {
                this.removeUniform('sampler', true);
                this.removeUniform('viewMat', true);
                this.removeUniform('flipNormal', true);
                this.removeDefine('#define SKY_TEXTURE');
            }
            return val;
        };
        return MaterialLightAtmospheric;
    }(Trike.MaterialMulti));
    Trike.MaterialLightAtmospheric = MaterialLightAtmospheric;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    *  This material draws the luminosity contributions of a directional light onto its light mesh
    */
    var MaterialLightDirectional = (function (_super) {
        __extends(MaterialLightDirectional, _super);
        function MaterialLightDirectional() {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Lights] = new Trike.PassMaterial('Directional Light', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('gBuffer2', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('gBuffer', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('lightDirectionVS', Trike.UniformType.FLOAT3), true);
            this.addUniform(new Trike.UniformVar('lightColor', Trike.UniformType.COLOR3), true);
            this.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('lightIntensity', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('frustumCorners', Trike.UniformType.FLOAT3_ARRAY), true);
            this.addUniform(new Trike.UniformVar('limitScreenQuad', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('minMax', Trike.UniformType.FLOAT4, new Trike.Vec4(-1, -1, 1, 1)), true);
            this.addUniform(new Trike.UniformVar('translucencyIntensity', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('translucencyColor', Trike.UniformType.COLOR3, new Trike.Color(0xffffff)), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            this.addAttribute(new Trike.AttributeVar('frustumCornerIndex', Trike.AttributeType.SCREEN_CORNER_INDEX));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.addDefine(Trike.ShaderDefines.QUAD_LIGHTING);
            this.addDefine(Trike.ShaderDefines.GAMA_INPUT);
            this.materials[Trike.PassType.Lights].blendMode = Trike.BlendMode.Additive;
            this.materials[Trike.PassType.Lights].depthWrite = false;
            // Create the shaders
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialLightDirectional.prototype.getVertexShader = function () {
            return "\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\t" + Trike.ShaderFragments.VertParams.frustumCorners() + "\n\t\t\t\t" + Trike.ShaderFragments.VertParams.screenQuadBoundaries() + "\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\t// sphere proxy needs real position\n\t\t\t\t    gl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.frustumCorners() + "\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.checkBoundaries() + "\n\t\t\t\t}\n\n\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialLightDirectional.prototype.getFragmentShader = function () {
            return "\n\t\t\t\tuniform sampler2D gBuffer2;\n\t\t\t\tuniform sampler2D gBuffer;\n\t\t\t\tuniform vec3 lightDirectionVS;\n\t\t\t\tuniform vec3 lightColor;\n\t\t\t\tuniform float viewHeight;\n\t\t\t\tuniform float viewWidth;\n\t\t\t\tuniform float lightIntensity;\n\t\t\t\tuniform mat4 projectionInverseMatrix;\n\t\t\t\tuniform float translucencyIntensity;\n\t\t\t\tuniform vec3 translucencyColor;\n\n\t\t\t\t" + Trike.ShaderFragments.FragParams.frustumCorners() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.floatToVec() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.vecToFloat() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.decodeNormal() + "\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.quadTexCoord() + "\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.computeVertexPositionVS() + "\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.computeNormal() + "\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.unpackColorMap() + "\n\n\t\t\t\t\t// compute light\n\t\t\t\t\tvec3 lightVector = lightDirectionVS;\n\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.computeDiffuse() + "\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.computeSpecular() + "\n\n\t\t\t\t\t// combine\n\t\t\t\t\tconst float attenuation = 1.0;\n\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.computeTranslucency() + "\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.combineLighting() + "\n\t\t\t\t}\n\t\t\t";
        };
        return MaterialLightDirectional;
    }(Trike.MaterialMulti));
    Trike.MaterialLightDirectional = MaterialLightDirectional;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * This material draws the luminosity contributions of a spot light onto its light mesh
    */
    var MaterialLightSpot = (function (_super) {
        __extends(MaterialLightSpot, _super);
        function MaterialLightSpot() {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Lights] = new Trike.PassMaterial('Spot Light', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('lightColor', Trike.UniformType.COLOR3), true);
            this.addUniform(new Trike.UniformVar('gBuffer2', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('gBuffer', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('lightIntensity', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('lightPositionVS', Trike.UniformType.FLOAT3), true);
            this.addUniform(new Trike.UniformVar('lightDirectionVS', Trike.UniformType.FLOAT3), true);
            this.addUniform(new Trike.UniformVar('lightAngle', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('frustumCorners', Trike.UniformType.FLOAT3_ARRAY), true);
            this.addUniform(new Trike.UniformVar('limitScreenQuad', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('minMax', Trike.UniformType.FLOAT4, new Trike.Vec4(-1, -1, 1, 1)), true);
            this.addUniform(new Trike.UniformVar('translucencyIntensity', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('translucencyColor', Trike.UniformType.COLOR3, new Trike.Color(0xffffff)), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            this.addAttribute(new Trike.AttributeVar('frustumCornerIndex', Trike.AttributeType.SCREEN_CORNER_INDEX));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.addDefine(Trike.ShaderDefines.QUAD_LIGHTING);
            this.addDefine(Trike.ShaderDefines.GAMA_INPUT);
            this.materials[Trike.PassType.Lights].blendMode = Trike.BlendMode.Additive;
            this.materials[Trike.PassType.Lights].depthWrite = false;
            // Create the shaders
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialLightSpot.prototype.getVertexShader = function () {
            return "\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\t" + Trike.ShaderFragments.VertParams.frustumCorners() + "\n\t\t\t\t" + Trike.ShaderFragments.VertParams.screenQuadBoundaries() + "\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t   gl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.frustumCorners() + "\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.checkBoundaries() + "\n\t\t\t\t}\n\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialLightSpot.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\tuniform float viewHeight;\n\t\t\t\tuniform float viewWidth;\n\t\t\t\tuniform float lightIntensity;\n\t\t\t\tuniform sampler2D gBuffer2;\n\t\t\t\tuniform sampler2D gBuffer;\n\n\t\t\t\tuniform vec3 lightPositionVS;\n\t\t\t\tuniform vec3 lightDirectionVS;\n\t\t\t\tuniform vec3 lightColor;\n\t\t\t\tuniform float lightAngle;\n\t\t\t\tuniform float translucencyIntensity;\n\t\t\t\tuniform vec3 translucencyColor;\n\n\t\t\t\t" + Trike.ShaderFragments.FragParams.frustumCorners() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.floatToVec() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.vecToFloat() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.decodeNormal() + "\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.quadTexCoord() + "\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.computeVertexPositionVS() + "\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.computeNormal() + "\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.unpackColorMap() + "\n\n\t\t\t\t\t// compute light\n\t\t\t\t    vec3 lightVector = normalize( lightPositionVS.xyz - vertexPositionVS.xyz );\n\n\t\t\t\t    float rho = dot( lightDirectionVS, lightVector );\n\t\t\t\t    float rhoMax = cos( lightAngle * 0.5 );\n\n\t\t\t\t    if ( rho <= rhoMax ) discard;\n\n\t\t\t\t    float theta = rhoMax + 0.0001;\n\t\t\t\t    float phi = rhoMax + 0.05;\n\t\t\t\t    float falloff = 4.0;\n\n\t\t\t\t    float spot = 0.0;\n\n\t\t\t\t    if ( rho >= phi )\n\t\t\t\t        spot = 1.0;\n\t\t\t\t    else if ( rho <= theta )\n\t\t\t\t        spot = 0.0;\n\t\t\t\t    else\n\t\t\t\t        spot = pow( ( rho - theta ) / ( phi - theta ), falloff );\n\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.computeDiffuse() + "\n\n\t\t\t\t    diffuse *= spot;\n\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.computeSpecular() + "\n\n\t\t\t\t\t // combine\n\t\t\t\t    const float attenuation = 1.0;\n\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.computeTranslucency() + "\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.combineLighting() + "\n\t\t\t\t}\n\t\t\t";
        };
        return MaterialLightSpot;
    }(Trike.MaterialMulti));
    Trike.MaterialLightSpot = MaterialLightSpot;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * An enum that describes the way we render point lights. You can either treat them as scene geometry spheres
    * that will get culled by the frustum - or as a screen quad.
    */
    (function (POINT_LIGHT_RENDER_TYPE) {
        POINT_LIGHT_RENDER_TYPE[POINT_LIGHT_RENDER_TYPE["Perspective"] = 0] = "Perspective";
        POINT_LIGHT_RENDER_TYPE[POINT_LIGHT_RENDER_TYPE["ScreenQuad"] = 1] = "ScreenQuad";
    })(Trike.POINT_LIGHT_RENDER_TYPE || (Trike.POINT_LIGHT_RENDER_TYPE = {}));
    var POINT_LIGHT_RENDER_TYPE = Trike.POINT_LIGHT_RENDER_TYPE;
    /**
    * This material draws the luminosity contributions of a point light onto its light mesh
    */
    var MaterialLightPoint = (function (_super) {
        __extends(MaterialLightPoint, _super);
        function MaterialLightPoint(renderType) {
            if (renderType === void 0) { renderType = POINT_LIGHT_RENDER_TYPE.Perspective; }
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Lights] = new Trike.PassMaterial('Point Light', this);
            this.renderType = renderType;
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('gBuffer2', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('gBuffer', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('lightColor', Trike.UniformType.COLOR3), true);
            this.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('lightIntensity', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('lightPositionVS', Trike.UniformType.FLOAT3), true);
            this.addUniform(new Trike.UniformVar('lightRadius', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('translucencyIntensity', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('translucencyColor', Trike.UniformType.COLOR3, new Trike.Color(0xffffff)), true);
            // Define the attribures and defines
            if (renderType === POINT_LIGHT_RENDER_TYPE.ScreenQuad) {
                this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
                this.addAttribute(new Trike.AttributeVar('frustumCornerIndex', Trike.AttributeType.SCREEN_CORNER_INDEX));
                this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
                this.addDefine(Trike.ShaderDefines.QUAD_LIGHTING);
                this.materials[Trike.PassType.Lights].addUniform(new Trike.UniformVar('frustumCorners', Trike.UniformType.FLOAT3_ARRAY));
            }
            else {
                this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
                this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
                this.addUniform(new Trike.UniformVar('cameraFar', Trike.UniformType.FLOAT, 1000));
                this.addUniform(new Trike.UniformVar('modelViewMatrix', Trike.UniformType.MAT4));
                this.addUniform(new Trike.UniformVar('projectionMatrix', Trike.UniformType.MAT4));
            }
            this.addDefine(Trike.ShaderDefines.GAMA_INPUT);
            this.materials[Trike.PassType.Lights].blendMode = Trike.BlendMode.Additive;
            this.materials[Trike.PassType.Lights].cullMode = Trike.CullFormat.Front;
            this.materials[Trike.PassType.Lights].depthWrite = false;
            // Create the shaders
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialLightPoint.prototype.getVertexShader = function () {
            return "\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\t// If we are rendering point lights as full screen quads\n\t\t\t\t#ifdef QUAD_LIGHTING\n\n\t\t\t\t\t" + Trike.ShaderFragments.VertParams.frustumCorners() + "\n\n\t\t\t\t\tvoid main()\n\t\t\t\t\t{\n\t\t\t\t\t\t// sphere proxy needs real position\n\t\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t\t\t" + Trike.ShaderFragments.VertMain.frustumCorners() + "\n\t\t\t\t\t}\n\n\t\t\t\t// Rendering the point lights as sphere geometry\n\t\t\t\t#else\n\n\t\t\t\t\tuniform mat4 modelViewMatrix;\n\t\t\t\t\tuniform mat4 projectionMatrix;\n\t\t\t\t\tvarying vec3 vertVS;\n\t\t\t\t\tvarying vec4 clipPos;\n\n\t\t\t\t\tvoid main()\n\t\t\t\t\t{\n\t\t\t\t\t\t// sphere proxy needs real position\n\t\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\t\tvertVS = mvPosition.xyz;\n\t\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\t\t\t\t\t\tclipPos = gl_Position;\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialLightPoint.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\tuniform float viewHeight;\n\t\t\t\tuniform float viewWidth;\n\t\t\t\tuniform float lightIntensity;\n\n\t\t\t\t// For getting the normalized z depth\n\t\t\t\tvarying vec4 clipPos;\n\t\t\t\tvarying vec3 vertVS;\n\t\t\t\tuniform float cameraFar;\n\n\t\t\t\tuniform sampler2D gBuffer2;\n\t\t\t\tuniform sampler2D gBuffer;\n\n\t\t\t\tuniform vec3 lightPositionVS;\n\t\t\t\tuniform vec3 lightColor;\n\t\t\t\tuniform float lightRadius;\n\n\t\t\t\tuniform float translucencyIntensity;\n\t\t\t\tuniform vec3 translucencyColor;\n\n\t\t\t\t#ifdef QUAD_LIGHTING\n\t\t\t\t\t" + Trike.ShaderFragments.FragParams.frustumCorners() + "\n\t\t\t\t#endif\n\n\t\t\t\t" + Trike.ShaderFragments.FragParams.floatToVec() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.vecToFloat() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.decodeNormal() + "\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.quadTexCoord() + "\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.computeVertexPositionVS() + "\n\n\t\t\t\t\t// bail out early when pixel outside of light sphere\n\t\t\t\t    vec3 lightVector = lightPositionVS - vertexPositionVS.xyz;\n\t\t\t\t    float distance = length( lightVector );\n\t\t\t\t    if ( distance > lightRadius ) discard;\n\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.computeNormal() + "\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.unpackColorMap() + "\n\n\t\t\t\t\t// compute light\n\t\t\t\t    lightVector = normalize( lightVector );\n\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.computeDiffuse() + "\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.computeSpecular() + "\n\n\t\t\t\t\t// combine\n\t\t\t\t    float cutoff = 0.25;\n\t\t\t\t    float denom = distance / lightRadius + 1.0;\n\t\t\t\t    float attenuation = 1.0 / ( denom * denom );\n\t\t\t\t    attenuation = ( attenuation - cutoff ) / ( 1.0 - cutoff );\n\t\t\t\t    attenuation = max( attenuation, 0.0 );\n\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.computeTranslucency() + "\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.combineLighting() + "\n\t\t\t\t}\n\n\t\t\t";
        };
        return MaterialLightPoint;
    }(Trike.MaterialMulti));
    Trike.MaterialLightPoint = MaterialLightPoint;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A material for the CameraPass composition. Adds screen space fog and other camera related
    * effects to the scene before sending it to the frame buffer.
    */
    var MaterialCamEffects = (function (_super) {
        __extends(MaterialCamEffects, _super);
        function MaterialCamEffects() {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.ScreenQuad] = new Trike.PassMaterial('Final Material', this);
            // Fog
            this._fogType = Trike.FogType.None;
            this._fogColor = new Trike.Color(0xffffff);
            this._fogDensity = 1;
            this._fogHeightMin = 0;
            this._fogHeightMax = 400;
            this._fogHeightDensity = 0.05;
            this._fogConvolver = null;
            this._fogFlipNormal = -1;
            // Define the commopn uniforms of the material
            this.addUniform(new Trike.UniformVar('composition', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('frustumCorners', Trike.UniformType.FLOAT3_ARRAY), true);
            this.addUniform(new Trike.UniformVar('brightness', Trike.UniformType.FLOAT, 1), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            this.addAttribute(new Trike.AttributeVar('frustumCornerIndex', Trike.AttributeType.SCREEN_CORNER_INDEX));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            // this._debugType = DebugType.None;
            this.depthRead = false;
            this.depthWrite = false;
            // Default tone mapping
            this._toneMapper = Trike.ToneMapper.None;
            this._whiteValue = 11.5;
            this.toneMapper(Trike.ToneMapper.Uncharted);
            // No fog by default
            this.fogType(Trike.FogType.None);
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialCamEffects.prototype.getVertexShader = function () {
            return "\n\n\t\t\t\t" + Trike.ShaderFragments.VertParams.frustumCorners() + "\n\n\t\t\t\t#if defined(FOG_HEIGHT) || defined(FOG_TEXTURE)\n\t\t\t\t\tvarying vec3 frustumCornerWorld;\n\t\t\t\t\tuniform mat4 cameraWorldRotMat;\n\t\t\t\t#endif\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.frustumCorners() + "\n\n\t\t\t\t\t#if defined(FOG_HEIGHT) || defined(FOG_TEXTURE)\n\t\t\t\t\t\t// To get the fragment world space we multiply it by the camera's world rotation matrix and then add the position in the frag shader\n\t\t\t\t\t\tfrustumCornerWorld = (cameraWorldRotMat * vec4( frustumCorner, 0.0 )).xyz;\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialCamEffects.prototype.getFragmentShader = function () {
            return "\n                uniform sampler2D composition;\n                uniform float viewHeight;\n                uniform float viewWidth;\n\n                " + Trike.ShaderFragments.FragParams.floatToVec() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.frustumCorners() + "\n\n\t\t\t\t// Fog uniforms\n\t\t\t\t#if defined(FOG)\n\t\t\t\t\tuniform sampler2D gBuffer2;\n\t\t\t\t\tuniform vec3 fogColor;\n\t\t\t\t\tuniform float fogDensity;\n\n\t\t\t\t\t#if defined(FOG_HEIGHT) || defined(FOG_TEXTURE)\n\t\t\t\t\t\tuniform vec3 cameraPosition;\n\t\t\t\t\t\tvarying vec3 frustumCornerWorld;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if defined(FOG_HEIGHT)\n\t\t\t\t\t\tuniform float fogHeightMin;\n\t\t\t\t\t\tuniform float fogHeightMax;\n\t\t\t\t\t\tuniform float fogHeightDensity;\n\t\t\t\t\t\tuniform float fogSunDistribution;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef FOG_TEXTURE\n\t\t\t\t\t\tuniform samplerCube fogConvolver;\n\t\t\t\t\t\tuniform float flipNormal;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\t" + Trike.ShaderFragments.FragParams.toneMapping() + "\n\n                void main()\n                {\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.quadTexCoord() + "\n                \tvec4 compositionSample = texture2D( composition, texCoord );\n                \tgl_FragColor = vec4( compositionSample.xyz, 1.0 );\n\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.toneMapping() + "\n\n\t\t\t\t\t#if defined(FOG)\n\n\t\t\t\t\t\tvec4 gBuffer2Sample = texture2D( gBuffer2, texCoord );\n                \t\tfloat normalizedDepth = gBuffer2Sample.z;\n\n                \t\tvec3 fColor = fogColor;\n                \t\tfloat fogAmount = 0.0;\n\n\t\t\t\t\t\t// Get fragment in WS\n\t\t\t\t\t\t#if defined(FOG_HEIGHT) || defined(FOG_TEXTURE)\n\n\t\t\t\t\t\t\t// Gets the fragment position in world space\n                \t\t\tvec3 fragPositionWS = normalizedDepth * frustumCornerWorld;\n\n\t\t\t\t\t\t\t// The vert shader multiplied the frustum by the rotation, and now\n\t\t\t\t\t\t\t// we add the camera position to get the world position\n                \t\t\tfragPositionWS += cameraPosition;\n\n\t\t\t\t\t\t#endif\n\n                \t\t#if defined(FOG_LOG)\n                \t\t\tfogAmount = 1.0 - exp( -normalizedDepth * fogDensity );\n\n\t\t\t\t\t\t#elif defined(FOG_HEIGHT)\n\n\t\t\t\t\t\t\t// Gets the world position based on the depth\n\t\t\t\t\t\t\t// http://www.iquilezles.org/www/articles/fog/fog.htm\n\t\t\t\t\t\t\t// http://www.terathon.com/lengyel/Lengyel-UnifiedFog.pdf\n\t\t\t\t\t\t\t// http://cluelesscocoacoder.ajbhost.k-hosting.co.uk/?p=225\n\t\t\t\t\t\t\t// http://isnippets.blogspot.ie/2010/10/real-time-fog-using-post-processing-in.html\n                \t\t\tfogAmount = 1.0 - exp( -normalizedDepth * fogDensity );\n                \t\t\tfogAmount += ( 1.0 - smoothstep( fogHeightMin, fogHeightMax, fragPositionWS.y )) * smoothstep( fogHeightDensity, 1.0, normalizedDepth);\n                \t\t\tfogAmount = min( fogAmount, 1.0 );\n\n\t\t\t\t\t\t// TODO\n                \t\t#elif defined(FOG_LINEAR)\n                \t\t\tconst float LOG2 = 1.442695;\n                \t\t\tfloat fogAmount = exp2( - fogDensity * fogDensity * normalizedDepth * normalizedDepth * LOG2 );\n                \t\t#endif\n\n\t\t\t\t\t\t#ifdef FOG_TEXTURE\n\t\t\t\t\t\t\tvec3 skyCoord = normalize(fragPositionWS - cameraPosition);\n\t\t\t\t\t\t\tskyCoord = vec3( flipNormal * skyCoord.x, skyCoord.yz );\n\t\t\t\t\t\t\tfColor = fColor * textureCube( fogConvolver, skyCoord ).xyz;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// Mixed the fog color with the fog factor\n                \t\tgl_FragColor.xyz = mix( gl_FragColor.xyz, fColor, fogAmount );\n\n                \t#endif\n\n\n\t\t\t\t\tgl_FragColor.w = 1.0;\n                }\n            ";
        };
        /**
        * Gets or sets if the fog normal should be flipped
        * @param {boolean} val [Optional]
        * @returns {boolean}
        */
        MaterialCamEffects.prototype.fogFlipNormal = function (val) {
            if (val === undefined)
                return (this._fogFlipNormal === -1 ? false : true);
            this._fogFlipNormal = (val ? 1 : -1);
            if (this._uniforms['flipNormal'])
                this.setUniform('flipNormal', this._fogFlipNormal, true);
            return val;
        };
        MaterialCamEffects.prototype._validateUniforms = function () {
            if ((this._fogType === Trike.FogType.HeightBased || this._fogConvolver) && this._fogType !== Trike.FogType.None) {
                if (!this._uniforms['cameraWorldRotMat']) {
                    this.addUniform(new Trike.UniformVar('cameraWorldRotMat', Trike.UniformType.MAT4), true);
                    this.addUniform(new Trike.UniformVar('cameraPosition', Trike.UniformType.FLOAT3), true);
                }
            }
            else {
                this.removeUniform('cameraWorldRotMat');
                this.removeUniform('cameraPosition');
            }
        };
        /**
        * Gets or sets the fog type
        * @param {FogType} val [Optional]
        * @returns {FogType}
        */
        MaterialCamEffects.prototype.fogType = function (val) {
            if (val === undefined)
                return this._fogType;
            if (this._fogType === val)
                return val;
            this._fogType = val;
            this.removeDefine('#define FOG');
            this.removeDefine('#define FOG_LINEAR');
            this.removeDefine('#define FOG_HEIGHT');
            this.removeDefine('#define FOG_LOG');
            this.removeUniform('fogColor');
            this.removeUniform('fogDensity');
            this.removeUniform('fogHeightMin');
            this.removeUniform('fogHeightMax');
            this.removeUniform('fogHeightDensity');
            this.removeUniform('gBuffer2');
            if (val === Trike.FogType.Linear)
                this.addDefine('#define FOG_LINEAR');
            else if (val === Trike.FogType.HeightBased) {
                this.addDefine('#define FOG_HEIGHT');
                // only height properties
                this.addUniform(new Trike.UniformVar('fogHeightMin', Trike.UniformType.FLOAT, this._fogHeightMin), true);
                this.addUniform(new Trike.UniformVar('fogHeightMax', Trike.UniformType.FLOAT, this._fogHeightMax), true);
                this.addUniform(new Trike.UniformVar('fogHeightDensity', Trike.UniformType.FLOAT, this._fogHeightDensity), true);
            }
            else if (val !== Trike.FogType.None)
                this.addDefine('#define FOG_LOG');
            // All common fog properties
            if (val !== Trike.FogType.None) {
                this.addDefine('#define FOG');
                this.addUniform(new Trike.UniformVar('fogColor', Trike.UniformType.COLOR3, this._fogColor), true);
                this.addUniform(new Trike.UniformVar('fogDensity', Trike.UniformType.FLOAT, this._fogDensity), true);
                this.addUniform(new Trike.UniformVar('gBuffer2', Trike.UniformType.TEXTURE), true);
            }
            this._validateUniforms();
            return val;
        };
        /**
        * Gets or sets the fog color
        * @param {Color} val [Optional]
        * @returns {Color}
        */
        MaterialCamEffects.prototype.fogColor = function (val) {
            if (val === undefined)
                return this._fogColor;
            this._fogColor = val;
            if (this._fogType !== Trike.FogType.None)
                this.setUniform('fogColor', val, true);
            return val;
        };
        /**
        * Gets or sets the fog density
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialCamEffects.prototype.fogDensity = function (val) {
            if (val === undefined)
                return this._fogDensity;
            this._fogDensity = val;
            if (this._fogType !== Trike.FogType.None)
                this.setUniform('fogDensity', val, true);
            return val;
        };
        /**
        * Gets or sets the fog min height (only applicable if fog algorithm uses height base contributions)
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialCamEffects.prototype.fogHeightMin = function (val) {
            if (val === undefined)
                return this._fogHeightMin;
            this._fogHeightMin = val;
            if (this._fogType === Trike.FogType.HeightBased)
                this.setUniform('fogHeightMin', val, true);
            return val;
        };
        /**
        * Gets or sets the fog max height (only applicable if fog algorithm uses height base contributions)
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialCamEffects.prototype.fogHeightMax = function (val) {
            if (val === undefined)
                return this._fogHeightMax;
            this._fogHeightMax = val;
            if (this._fogType === Trike.FogType.HeightBased)
                this.setUniform('fogHeightMax', val, true);
            return val;
        };
        /**
        * Gets or sets the fog height density (only applicable if fog algorithm uses height base contributions)
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialCamEffects.prototype.fogHeightDensity = function (val) {
            if (val === undefined)
                return this._fogHeightDensity;
            this._fogHeightDensity = val;
            if (this._fogType === Trike.FogType.HeightBased)
                this.setUniform('fogHeightDensity', val, true);
            return val;
        };
        MaterialCamEffects.prototype.fogConvolver = function (val) {
            if (val === undefined)
                return this._fogConvolver;
            if (this._fogConvolver && val) {
                this._fogConvolver = val;
                this.setUniform('fogConvolver', val.cubeTexture(), true);
                return val;
            }
            else if (!this._fogConvolver && val) {
                this._fogConvolver = val;
                this.addUniform(new Trike.UniformVar('fogConvolver', Trike.UniformType.TEXTURE_CUBE, val.cubeTexture()), true);
                this.addUniform(new Trike.UniformVar('flipNormal', Trike.UniformType.FLOAT, this._fogFlipNormal), true);
                this.addDefine('#define FOG_TEXTURE');
                this._validateUniforms();
            }
            else {
                this._fogConvolver = null;
                this.removeUniform('fogConvolver', true);
                this.removeUniform('flipNormal', true);
                this.removeDefine('#define FOG_TEXTURE');
                this._validateUniforms();
            }
            return val;
        };
        /**
        * Gets or sets the tone mapping algorithm to use on the camera
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialCamEffects.prototype.brightness = function (val) {
            if (val === undefined)
                return this._uniforms['brightness'].value;
            this.setUniform('brightness', val, true);
            return val;
        };
        /**
        * Gets or sets the white value (only applicable to uncharted style tone mapping)
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialCamEffects.prototype.whiteValue = function (val) {
            if (val === undefined)
                return this._whiteValue;
            if (this._whiteValue === val)
                return val;
            this._whiteValue = val;
            if (this._uniforms['whiteValue'])
                this.setUniform('whiteValue', val, true);
            return val;
        };
        /**
        * Gets or sets the tone mapping algorithm to use on the camera
        * @param {ToneMapper} val [Optional]
        * @returns {ToneMapper}
        */
        MaterialCamEffects.prototype.toneMapper = function (val) {
            if (val === undefined)
                return this._toneMapper;
            if (this._toneMapper === val)
                return val;
            this.removeDefine('#define TONEMAP_SIMPLE');
            this.removeDefine('#define TONEMAP_LINEAR');
            this.removeDefine('#define TONEMAP_REINHARD');
            this.removeDefine('#define TONEMAP_FILMIC');
            this.removeDefine('#define TONEMAP_UNCHARTED');
            this.removeUniform('whiteValue');
            this._toneMapper = val;
            switch (val) {
                case Trike.ToneMapper.Simple:
                    this.addDefine('#define TONEMAP_SIMPLE');
                    break;
                case Trike.ToneMapper.Linear:
                    this.addDefine('#define TONEMAP_LINEAR');
                    break;
                case Trike.ToneMapper.Reinhard:
                    this.addDefine('#define TONEMAP_REINHARD');
                    break;
                case Trike.ToneMapper.Filmic:
                    this.addDefine('#define TONEMAP_FILMIC');
                    break;
                case Trike.ToneMapper.Uncharted:
                    this.addDefine('#define TONEMAP_UNCHARTED');
                    this.addUniform(new Trike.UniformVar('whiteValue', Trike.UniformType.FLOAT, this._whiteValue), true);
                    break;
            }
            return val;
        };
        return MaterialCamEffects;
    }(Trike.MaterialMulti));
    Trike.MaterialCamEffects = MaterialCamEffects;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A very simple material that samples a sky cube texture
    */
    var MaterialSkybox = (function (_super) {
        __extends(MaterialSkybox, _super);
        function MaterialSkybox() {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Skybox] = new Trike.PassMaterial('Skybox', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('modelViewMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('projectionMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('brightness', Trike.UniformType.FLOAT, 0), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.cullMode = Trike.CullFormat.Front;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialSkybox.prototype.getVertexShader = function () {
            return "\n\t\t\t" + Trike.ShaderFragments.VertParams.defaults() + "\n\n\t\t\t#ifdef USE_TEXTURE\n\t\t\t\tvarying vec3 vWorldPosition;\n\t\t\t\tuniform mat4 modelMatrix;\n\t\t\t#endif\n\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\t#ifdef USE_TEXTURE\n\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tvWorldPosition = worldPosition.xyz;\n\t\t\t\t#endif\n\t\t\t\t" + Trike.ShaderFragments.VertMain.defaults() + "\n\t\t\t}\n\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialSkybox.prototype.getFragmentShader = function () {
            return "\n\t\t\t#ifdef USE_TEXTURE\n\t\t\t\tuniform samplerCube skybox;\n\t\t\t\tvarying vec3 vWorldPosition;\n\t\t\t#endif\n\n\t\t\tuniform float brightness;\n\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\t#ifdef USE_TEXTURE\n\t\t\t\t\tfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\t\t\t\t\tvec3 skyCoords = vec3( flipNormal * vWorldPosition.x, vWorldPosition.yz );\n\t\t\t\t\tgl_FragColor = textureCube( skybox, skyCoords );\n\t\t\t\t\tgl_FragColor.rgb *= brightness;\n\t\t\t\t#else\n\t\t\t\t\tgl_FragColor = vec4( 1.0, 1.0, 1.0, 1.0 );\n\t\t\t\t#endif\n\t\t\t}\n\t\t\t";
        };
        return MaterialSkybox;
    }(Trike.MaterialMulti));
    Trike.MaterialSkybox = MaterialSkybox;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A very simple shader that draws a texture to a screen aligned quad
    */
    var MaterialScreenTexture = (function (_super) {
        __extends(MaterialScreenTexture, _super);
        function MaterialScreenTexture(opacityFromGBuffer) {
            if (opacityFromGBuffer === void 0) { opacityFromGBuffer = false; }
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.ScreenQuad] = new Trike.PassMaterial('Screen Texture', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('map', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 500), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            if (opacityFromGBuffer) {
                this.addDefine('#define OPAC_MAP');
                this.addUniform(new Trike.UniformVar('gBuffer2', Trike.UniformType.TEXTURE));
            }
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialScreenTexture.prototype.getVertexShader = function () {
            return "\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialScreenTexture.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\tuniform sampler2D map;\n\t\t\t\t#ifdef OPAC_MAP\n\t\t\t\t\tuniform sampler2D gBuffer2;\n\t\t\t\t\t" + Trike.ShaderFragments.FragParams.floatToVec() + "\n\t\t\t\t#endif\n\n\t\t\t\tuniform float viewHeight;\n\t\t\t\tuniform float viewWidth;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.quadTexCoord() + "\n\n\t\t\t\t\t// Get the depth material - do nothing if there is no Z value\n\t\t\t\t\t#ifdef PREMULTIPLIED_ALPHA\n\n\t\t\t\t\t\t#ifdef OPAC_MAP\n\t\t\t\t\t\t\tvec4 gBuffer2Sample = texture2D( gBuffer2, texCoord );\n\t\t\t\t\t\t\tvec3 freeOpacShininess = float_to_vec3( abs( gBuffer2Sample.w ) );\n\t\t\t\t\t\t\tfloat opacity = freeOpacShininess.y;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tfloat opacity = map.w;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\tvec4 mapSample = texture2D( map, texCoord );\n\t\t\t\t\t\tgl_FragColor.xyz = mapSample.xyz * opacity;\n\t\t\t\t\t\tgl_FragColor.w = opacity;\n\n\t\t\t\t\t#else\n\t\t\t\t\t\tgl_FragColor = texture2D( map, texCoord );\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t";
        };
        /**
        * Gets or sets the texture we are blurring
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialScreenTexture.prototype.map = function (val) {
            if (val === undefined)
                return this._uniforms['map'].value;
            this.setUniform('map', val, true);
            return val;
        };
        return MaterialScreenTexture;
    }(Trike.MaterialMulti));
    Trike.MaterialScreenTexture = MaterialScreenTexture;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A very simple shader that takes 2 textures and blends them to a final one
    */
    var MaterialBlendTextures = (function (_super) {
        __extends(MaterialBlendTextures, _super);
        function MaterialBlendTextures(opacityFromGBuffer) {
            if (opacityFromGBuffer === void 0) { opacityFromGBuffer = false; }
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.ScreenQuad] = new Trike.PassMaterial('Blend Textures', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('map1', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('map2', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 500), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.addDefine('#define MULTIPLY');
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialBlendTextures.prototype.getVertexShader = function () {
            return "\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialBlendTextures.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\tuniform sampler2D map1;\n\t\t\t\tuniform sampler2D map2;\n\t\t\t\tuniform float viewHeight;\n\t\t\t\tuniform float viewWidth;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.quadTexCoord() + "\n\n\n\t\t\t\t\t#if defined(ADD)\n\t\t\t\t\t\tgl_FragColor = texture2D( map1, texCoord ) + texture2D( map2, texCoord );\n\t\t\t\t\t#elif defined(MULTIPLY)\n\t\t\t\t\t\tgl_FragColor = texture2D( map1, texCoord ) * texture2D( map2, texCoord );\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t";
        };
        /**
        * Gets or sets the first texture we are blurring
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialBlendTextures.prototype.map1 = function (val) {
            if (val === undefined)
                return this._uniforms['map1'].value;
            this.setUniform('map1', val, true);
            return val;
        };
        /**
        * Gets or sets the second texture we are blurring
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialBlendTextures.prototype.map2 = function (val) {
            if (val === undefined)
                return this._uniforms['map2'].value;
            this.setUniform('map2', val, true);
            return val;
        };
        return MaterialBlendTextures;
    }(Trike.MaterialMulti));
    Trike.MaterialBlendTextures = MaterialBlendTextures;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A material for rendering sprite or billboard type geometry
    */
    var MaterialSprite = (function (_super) {
        __extends(MaterialSprite, _super);
        function MaterialSprite() {
            //Call the material base
            _super.call(this, Trike.MultiMaterialOptions.CreateDefaults);
            this._map = null;
            this._alphaTest = 0;
            this._highlightBorder = false;
            this._highlighted = false;
            this._uvScale = new Trike.Vec2(1, 1);
            this._bump = null;
            this._bumpScale = 1;
            this._highlightColor = new Trike.Color(0xF6FA7D);
            this._diffuse = new Trike.Color(0xffffff);
            this._specular = new Trike.Color(0xffffff);
            this._shininess = 0.05;
            this._translucencyEnabled = false;
            this._translucencyScale = 1;
            this._translucencyDistortion = 0.185;
            this._translucencyPower = 0.04;
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('modelMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('modelViewMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('projectionMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('rotation', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('customClipping', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('customClipPlane', Trike.UniformType.FLOAT4), true);
            // GBuffer only
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('emissive', Trike.UniformType.COLOR3, new Trike.Color(0xffffff)));
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('diffuse', Trike.UniformType.COLOR3, this._diffuse), false);
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('specular', Trike.UniformType.COLOR3, this._specular), false);
            // Add the camera far uniform to the normal depth material
            this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('cameraFar', Trike.UniformType.FLOAT, 1000));
            this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('opacity', Trike.UniformType.FLOAT, 1));
            this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('shininess', Trike.UniformType.FLOAT, this._shininess));
            //Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            //Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            // We dont use traditional normals for screen quads
            this.materials[Trike.PassType.GBuffer2].removeDefine(Trike.ShaderDefines.ATTR_NORMAL);
            this.materials[Trike.PassType.GBuffer2].removeAttribute(Trike.AttributeType.NORMAL);
            this.materials[Trike.PassType.GBuffer2].removeUniform('normalMatrix');
            this.materials[Trike.PassType.GBuffer2].addDefine(Trike.ShaderDefines.FORWARD_NORMAL);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialSprite.prototype.getVertexShader = function () {
            return "\n\n\t\t\t\t" + Trike.ShaderFragments.VertParams.defaults() + "\n\t\t\t\t" + Trike.ShaderFragments.VertParams.clippingParameters() + "\n\t\t\t\tuniform float rotation;\n\n\t\t\t\t#if !defined(SHADOW_MAPPING)\n\t\t\t\t\tuniform mat4 modelMatrix;\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(ATTR_UV)\n\t\t\t\t\tuniform float flipUV;\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(ATTR_UV)\n\t\t\t\t\tuniform vec2 uvOffset;\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(PASS_GBUFFER)\n\t\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.vertParams() + "\n\t\t\t\t#endif\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\t#ifdef ATTR_UV\n\t\t\t\t\t\tvUv = uvOffset + uv * uvScale;\n\t\t\t\t\t\tif ( flipUV === 1.0 )\n\t\t\t\t\t\tvUv = vec2( 1.0, 1.0 ) - vUv;\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat sx = length( vec3( modelMatrix[0][0], modelMatrix[1][0], modelMatrix[2][0] ) );\n\t\t\t\t\tfloat sy = length( vec3( modelMatrix[0][1], modelMatrix[1][1], modelMatrix[2][1] ) );\n\t\t\t\t\tfloat sz = length( vec3( modelMatrix[0][2], modelMatrix[1][2], modelMatrix[2][2] ) );\n\n\t\t\t\t\tvec2 alignedPosition = position.xy * vec2(sx, sy);\n\n\t\t\t\t\tvec2 rotatedPosition;\n\t\t\t\t\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\t\t\t\t\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\n\t\t\t\t\tvec4 mvPosition;\n\t\t\t\t\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\t\tmvPosition.xy += rotatedPosition;\n\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.clipping() + "\n\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\t//\tShadows\n\t\t\t\t\t#if defined(PASS_GBUFFER)\n\t\t\t\t\t\t#if defined(SHADOW_MAPPING)\n\t\t\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.vertMain() + "\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// We need to add the pass data\n\t\t\t\t\t" + Trike.ShaderFragments.Passes.vertNormDepthMain() + "\n\t\t\t\t}\n\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialSprite.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t" + Trike.ShaderFragments.FragParams.defaults() + "\n\t\t\t" + Trike.ShaderFragments.FragParams.clippingParams() + "\n\t\t\t" + Trike.ShaderFragments.FragParams.encodeNormal() + "\n\t\t\t" + Trike.ShaderFragments.FragParams.map() + "\n\t\t\t" + Trike.ShaderFragments.FragParams.bumpmapUniforms() + "\n\t\t\t" + Trike.ShaderFragments.FragParams.bumpmapFunctions() + "\n\t\t\t" + Trike.ShaderFragments.FragParams.vecToFloat() + "\n\n\t\t\t// GBUFFER PASS\n\t\t\t// ************************\n\t\t\t#if defined(PASS_GBUFFER)\n\t\t\t\tuniform vec3 emissive;\n\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.fragParams() + "\n\n\t\t\t\t#if defined(HIGHTLIGHT_BORDER)\n\t\t\t\t\tuniform float highlighted;\n\t\t\t\t\tuniform vec3 highlightColor;\n\t\t\t\t#endif\n\n\t\t\t\tuniform vec3 diffuse;\n\t\t\t\tuniform vec3 specular;\n\t\t\t#endif\n\n\t\t\t// GBUFFER2 PASS\n\t\t\t// ************************\n\t\t\t#if defined(PASS_GBUFFER2)\n\t\t\t\tuniform float shininess;\n\t\t\t#endif\n\n\t\t\tuniform float flipUV;\n\n\t\t\tvoid main()\n\t\t\t{\n\n\t\t\t\t" + Trike.ShaderFragments.FragMain.clippingTest() + "\n\n\t\t\t\t#if defined(PASS_GBUFFER)\n\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.alphaTest() + "\n\n\t\t\t\t\tgl_FragColor = vec4( emissive.x, emissive.y, emissive.z, 1.0 );\n\n\t\t\t\t\t// Highlights the sprite with the highlight color\n\t\t\t\t\t#if defined(HIGHTLIGHT_BORDER)\n\t\t\t\t\t\tif ( highlighted === 1.0 )\n\t\t\t\t\t\t\tgl_FragColor.xyz = gl_FragColor.xyz * highlightColor;\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat specularStrength = 1.0;\n\n\t\t\t\t\t#ifndef USE_MAP\n\t\t\t\t\t\tvec4 texelColor = vec4(1.0, 1.0, 1.0, 1.0);\n\t\t\t\t\t#endif\n\n\t\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.fragMain() + "\n\n\t\t\t\t\t#ifndef SHADOW_MAPPING\n\t\t\t\t\t\tfloat shadowAmount = 1.0;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// Emmsive in w\n\t\t\t\t\tgl_FragColor.w = vec3_to_float( gl_FragColor.xyz * shadowAmount );\n\n\t\t\t\t\t// Diffuse in x\n\t\t\t\t\tgl_FragColor.x = vec3_to_float( diffuse * shadowAmount );\n\n\t\t\t\t\t// Specular in y\n\t\t\t\t\tgl_FragColor.y = vec3_to_float( specular * specularStrength * shadowAmount );\n\n\t\t\t\t\t// Albedo in Z\n\t\t\t\t\tgl_FragColor.z = vec3_to_float( texelColor.xyz );\n\n\t\t\t\t#endif\n\n\t\t\t\t" + Trike.ShaderFragments.Passes.fragNormDepthMain() + "\n\t\t\t\t" + Trike.ShaderFragments.Passes.fragShadowMain() + "\n\t\t\t}\n\t\t\t";
        };
        /**
        * Only remove the UV attributes if we dont have any maps
        */
        MaterialSprite.prototype._setUV = function (desired) {
            if (desired) {
                this.addAttribute(new Trike.AttributeVar('uv', Trike.AttributeType.UV));
                this.addUniform(new Trike.UniformVar('uvOffset', Trike.UniformType.FLOAT2, new Trike.Vec2(0, 0)));
                this.addUniform(new Trike.UniformVar('uvScale', Trike.UniformType.FLOAT2, new Trike.Vec2(1, 1)));
                this.addUniform(new Trike.UniformVar('flipUV', Trike.UniformType.FLOAT, 0), true);
                this.addDefine(Trike.ShaderDefines.ATTR_UV);
            }
            else if (!this._map && !this._bump) {
                this.removeUniform('uvOffset');
                this.removeUniform('uvScale');
                this.removeUniform('flipUV');
                this.removeAttribute(Trike.AttributeType.UV);
                this.removeDefine(Trike.ShaderDefines.ATTR_UV);
            }
        };
        /*
        * Gets or sets the texture map of this material
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialSprite.prototype.map = function (val) {
            if (val === undefined)
                return this._map;
            if (this._map && val) {
                this._map = val;
                this.setUniform('map', val, true);
            }
            else if (!this._map && val) {
                this._map = val;
                this.addUniform(new Trike.UniformVar('map', Trike.UniformType.TEXTURE, val));
                this._setUV(true);
                this.addDefine(Trike.ShaderDefines.USE_MAP);
            }
            else {
                this._map = null;
                this.removeUniform('map');
                this.removeDefine(Trike.ShaderDefines.USE_MAP);
                this._setUV(false);
            }
            return val;
        };
        /*
        * Gets or sets the bump map of this material
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialSprite.prototype.bumpMap = function (val) {
            if (val === undefined)
                this._bump;
            var gBuffer2 = this.materials[Trike.PassType.GBuffer2];
            if (this._bump && val) {
                this._bump = val;
                gBuffer2.setUniform('bumpMap', val, false);
                gBuffer2.setUniform('bumpScale', this._bumpScale, false);
                return val;
            }
            if (!this._bump && val) {
                this._bump = val;
                this._setUV(true);
                gBuffer2.addUniform(new Trike.UniformVar('bumpMap', Trike.UniformType.TEXTURE, val));
                gBuffer2.addUniform(new Trike.UniformVar('bumpScale', Trike.UniformType.FLOAT, this._bumpScale));
                gBuffer2.addDefine(Trike.ShaderDefines.STANDARD_DERIVATIVES);
                gBuffer2.addDefine(Trike.ShaderDefines.BUMP_MAP);
            }
            else {
                this._bump = null;
                this._setUV(false);
                gBuffer2.removeUniform('bumpMap');
                gBuffer2.removeUniform('bumpScale');
                gBuffer2.removeDefine(Trike.ShaderDefines.STANDARD_DERIVATIVES);
                gBuffer2.removeDefine(Trike.ShaderDefines.BUMP_MAP);
            }
            return val;
        };
        /*
        * Gets or sets the bumpiness scale of the bump map.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialSprite.prototype.bumpScale = function (val) {
            if (val === undefined)
                return this._bumpScale;
            this._bumpScale = val;
            if (this._bump)
                this.materials[Trike.PassType.GBuffer2].setUniform('bumpScale', val, false);
            return val;
        };
        /**
        * Gets or sets the alpha test value. Alpha tests are used to discard pixels with alpha less than
        * the value set as the test. I.e. if the alpha test is 0.5, then any pixels with an
        * alpha value of less than 0.5 are discarded from the render process.
        * @param {number} val
        */
        MaterialSprite.prototype.alphaTest = function (val) {
            if (val === undefined)
                return this._alphaTest;
            this.removeDefine('#define ALPHATEST ' + this._alphaTest.toFixed(3));
            this._alphaTest = val;
            if (val !== 0)
                this.addDefine('#define ALPHATEST ' + this._alphaTest.toFixed(3));
            return this._alphaTest;
        };
        /*
        * Gets or sets if the sprite highliting should be on or off. Useful for showing if a sprite is selected for example.
        * @param {boolean} val [Optional]
        * @returns {boolean}
        */
        MaterialSprite.prototype.highlightBorder = function (val) {
            if (val === undefined)
                return this._highlightBorder;
            this.removeDefine('#define HIGHTLIGHT_BORDER');
            this.materials[Trike.PassType.GBuffer].removeUniform('highlighted', false);
            this.materials[Trike.PassType.GBuffer].removeUniform('highlightColor', false);
            this._highlightBorder = val;
            if (val) {
                this.addDefine('#define HIGHTLIGHT_BORDER');
                this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('highlighted', Trike.UniformType.FLOAT, 0), false);
                this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('highlightColor', Trike.UniformType.COLOR3, this._highlightColor), false);
                this._setUV(true);
            }
            else
                this._setUV(false);
            return val;
        };
        /*
        * Gets or sets if the sprite is highlighted or not.  Only works if highlightBorder is true
        * @param {boolean} val [Optional]
        * @returns {boolean}
        */
        MaterialSprite.prototype.highlighted = function (val) {
            if (val === undefined)
                return this._highlighted;
            var update = (this._highlighted !== val ? true : false);
            this._highlighted = val;
            if (update)
                this.materials[Trike.PassType.GBuffer].setUniform('highlighted', (val ? 1 : 0), false);
            return val;
        };
        /*
        * Gets or sets the color multiplier of the sprite when its 'highlighted'. Only works if highlightBorder is true
        * @param {Color} val [Optional]
        * @returns {Color}
        */
        MaterialSprite.prototype.highlightColor = function (val) {
            if (val === undefined)
                return this._highlightColor;
            this._highlightColor = val;
            if (this._highlighted)
                this.materials[Trike.PassType.GBuffer].setUniform('highlightColor', val, false);
            return val;
        };
        /*
        * Gets or sets the rotation amount of the sprite in radians
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialSprite.prototype.rotation = function (val) {
            if (val === undefined)
                return this._uniforms['rotation'].value;
            this.setUniform('rotation', val, true);
            return val;
        };
        /*
        * Gets or sets the UV scale of the texture coordinates. Higher values mean higher UV tesselation
        * @param {Vec2} val
        * @returns {Vec2}
        */
        MaterialSprite.prototype.uvScale = function (val) {
            if (val === undefined)
                return this._uvScale;
            this._uvScale = val;
            if (this._map) {
                this.setUniform('uvScale', this._uvScale, true);
                return this._uvScale;
            }
            return this._uvScale;
        };
        /*
        * Gets or sets the diffuse lighting color of the material
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialSprite.prototype.diffuse = function (val) {
            if (val === undefined)
                return this._diffuse;
            this._diffuse = val;
            this.materials[Trike.PassType.GBuffer].setUniform('diffuse', val, false);
            return this._diffuse;
        };
        /*
        * Gets or sets specular light colour
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialSprite.prototype.specular = function (val) {
            if (val === undefined)
                return this._specular;
            this._specular = val;
            this.materials[Trike.PassType.GBuffer].setUniform('specular', val, false);
            return val;
        };
        /*
        * Gets or sets emissive light colour
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialSprite.prototype.emissive = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['emissive'].value;
            this.materials[Trike.PassType.GBuffer].setUniform('emissive', val, false);
            return val;
        };
        /*
        * Gets or sets the shininess of the specular component
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialSprite.prototype.shininess = function (val) {
            if (val === undefined)
                return this._shininess;
            this._shininess = val;
            this.materials[Trike.PassType.GBuffer2].setUniform('shininess', val, false);
            return val;
        };
        /*
        * Gets or sets the opacity of this material. The values are from 0 to 1.
        * @param {number} val
        */
        MaterialSprite.prototype.opacity = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer2]._uniforms['opacity'].value;
            this.materials[Trike.PassType.GBuffer2].setUniform('opacity', val, false);
            return val;
        };
        /*
        * Gets or sets if translucency is enabled
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialSprite.prototype.translucencyEnabled = function (val) {
            if (val === undefined)
                return this._translucencyEnabled;
            if (this._translucencyEnabled === val)
                return;
            if (val) {
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('translucencyScale', Trike.UniformType.FLOAT, this._translucencyScale), false);
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('translucencyDistortion', Trike.UniformType.FLOAT, this._translucencyDistortion), false);
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('translucencyPower', Trike.UniformType.FLOAT, this._translucencyPower), false);
                this.materials[Trike.PassType.GBuffer2].addDefine(Trike.ShaderDefines.TRANSLUCENCY_ENABLED);
            }
            else {
                this.materials[Trike.PassType.GBuffer2].removeUniform('translucencyScale', false);
                this.materials[Trike.PassType.GBuffer2].removeUniform('translucencyDistortion', false);
                this.materials[Trike.PassType.GBuffer2].removeUniform('translucencyPower', false);
                this.materials[Trike.PassType.GBuffer2].removeDefine(Trike.ShaderDefines.TRANSLUCENCY_ENABLED);
            }
            this._translucencyEnabled = val;
        };
        /*
        * Gets or sets the translucency scale of the material. This is a uniform multiplier of the effect.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialSprite.prototype.translucencyScale = function (val) {
            if (val === undefined)
                return this._translucencyScale;
            this._translucencyScale = val;
            if (this._translucencyEnabled)
                this.materials[Trike.PassType.GBuffer2].setUniform('translucencyScale', val, false);
        };
        /*
        * Gets or sets the translucency distortion of the material.
        * Modifies the light angle as it enters the material
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialSprite.prototype.translucencyDistortion = function (val) {
            if (val === undefined)
                return this._translucencyDistortion;
            this._translucencyDistortion = val;
            if (this._translucencyEnabled)
                this.materials[Trike.PassType.GBuffer2].setUniform('translucencyDistortion', val, false);
        };
        /*
        * Gets or sets the translucency power of the material.
        * Increasing this has the effect of narrowing the area of the effect
        * @param {number} val [Optional]
        */
        MaterialSprite.prototype.translucencyPower = function (val) {
            if (val === undefined)
                return this._translucencyPower;
            this._translucencyPower = val;
            if (this._translucencyEnabled)
                this.materials[Trike.PassType.GBuffer2].setUniform('translucencyPower', val, false);
        };
        /*
        * Checks the uniforms or attributes of the material after a potentially breaking change
        */
        MaterialSprite.prototype._validate = function () {
            if (!this.materials[Trike.PassType.GBuffer]._uniforms['modelMatrix'])
                this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('modelMatrix', Trike.UniformType.MAT4), false);
        };
        return MaterialSprite;
    }(Trike.MaterialMulti));
    Trike.MaterialSprite = MaterialSprite;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    (function (UVCoordinates) {
        UVCoordinates[UVCoordinates["PerPoint"] = 0] = "PerPoint";
        UVCoordinates[UVCoordinates["ScreenBased"] = 1] = "ScreenBased";
    })(Trike.UVCoordinates || (Trike.UVCoordinates = {}));
    var UVCoordinates = Trike.UVCoordinates;
    /**
    * A material for rendering point clouds
    */
    var MaterialPointCloud = (function (_super) {
        __extends(MaterialPointCloud, _super);
        function MaterialPointCloud() {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.CreateDefaults);
            // Create the material for rendering the texture map
            this.materials[Trike.PassType.PointsTextureMap] = new Trike.PassMaterial('PointsTextureMap', this);
            this.materials[Trike.PassType.PointsTextureMap].addDefine(Trike.ShaderDefines.PASS_POINT_MAP);
            this.materials[Trike.PassType.PointsNormalMap] = new Trike.PassMaterial('PointsNormalMap', this);
            this.materials[Trike.PassType.PointsNormalMap].addDefine(Trike.ShaderDefines.PASS_POINT_NORMAL);
            this._map = null;
            this._alphaTest = 0;
            this._uvScale = new Trike.Vec2(1, 1);
            this._bump = false;
            this._bumpScale = 1;
            // Translucency
            this._translucencyEnabled = false;
            this._translucencyScale = 1;
            this._translucencyDistortion = 0.185;
            this._translucencyPower = 0.04;
            this._uniformDepth = 0.5;
            this._normalizedRadius = 0.5;
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('viewHeightHalf', Trike.UniformType.FLOAT, 512), true);
            this.addUniform(new Trike.UniformVar('particleScale', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('modelViewMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('projectionMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('flipUV', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('customClipping', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('customClipPlane', Trike.UniformType.FLOAT4), true);
            // GBuffer only
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('emissive', Trike.UniformType.COLOR3, new Trike.Color(0xffffff)));
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('diffuse', Trike.UniformType.COLOR3, new Trike.Color(0xffffff)), false);
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('specular', Trike.UniformType.COLOR3, new Trike.Color(0xffffff)), false);
            // Add the GBugger2 uniforms
            this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('opacity', Trike.UniformType.FLOAT, 1));
            this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('shininess', Trike.UniformType.FLOAT, 0.05));
            // Set the properties for the map and normal passes
            var commonMaterials = [this.materials[Trike.PassType.PointsTextureMap], this.materials[Trike.PassType.PointsNormalMap]];
            var commonMat;
            for (var i = 0, l = commonMaterials.length; i < l; i++) {
                commonMat = commonMaterials[i];
                commonMat.addUniform(new Trike.UniformVar('map', Trike.UniformType.TEXTURE, null));
                commonMat.addUniform(new Trike.UniformVar('opacity', Trike.UniformType.FLOAT, 1));
                commonMat.addUniform(new Trike.UniformVar('gBuffer2', Trike.UniformType.TEXTURE, null));
                commonMat.addUniform(new Trike.UniformVar('cameraFar', Trike.UniformType.FLOAT));
                commonMat.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 500));
                commonMat.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 500));
                commonMat.addUniform(new Trike.UniformVar('softnessScale', Trike.UniformType.FLOAT, 40));
                commonMat.addUniform(new Trike.UniformVar('uvScale', Trike.UniformType.FLOAT2, this._uvScale, false));
                commonMat.addDefine(Trike.ShaderDefines.USE_MAP);
                commonMat.blendMode = Trike.BlendMode.PremultipliedAlpha;
            }
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.addDefine(Trike.ShaderDefines.POINT_VERTS);
            // We dont use traditional normals for screen quads
            this.materials[Trike.PassType.GBuffer2].removeDefine(Trike.ShaderDefines.ATTR_NORMAL);
            this.materials[Trike.PassType.GBuffer2].removeAttribute(Trike.AttributeType.NORMAL);
            this.materials[Trike.PassType.GBuffer2].removeUniform('normalMatrix');
            this.materials[Trike.PassType.GBuffer2].addDefine(Trike.ShaderDefines.FORWARD_NORMAL);
            this.addDefine('#define GENERATE_UVS');
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.uvCoordinates(UVCoordinates.PerPoint);
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialPointCloud.prototype.getVertexShader = function () {
            return "\n\n\t\t\t\t" + Trike.ShaderFragments.VertParams.defaults() + "\n\t\t\t\t" + Trike.ShaderFragments.VertParams.clippingParameters() + "\n\n\t\t\t\t// Half the height of the canvas\n\t\t\t\tuniform float viewHeightHalf;\n\t\t\t\tuniform float particleScale;\n\n\t\t\t\t#if defined(ATTR_ROTATION)\n\t\t\t\t\tattribute float rotation;\n\t\t\t\t\tvarying float vRotation;\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(ATTR_ALPHA)\n\t\t\t\t\tattribute float alpha;\n\t\t\t\t\tvarying float vAlpha;\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(ATTR_SIZE)\n\t\t\t\t\tattribute float size;\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(PASS_POINT_NORMAL) || defined(PASS_POINT_MAP)\n\t\t\t\t\tvarying float vDepth;\n\t\t\t\t\tuniform float cameraFar;\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(PASS_GBUFFER)\n\t\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.vertParams() + "\n\t\t\t\t#endif\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tvec4 mvPosition;\n\t\t\t\t\tmvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.clipping() + "\n\t\t\t\t\tvec4 pmvPosition = projectionMatrix * mvPosition;\n\n\t\t\t\t\t#if defined(SHADOW_MAPPING)\n\t\t\t\t\t\tvec4 worldPosition = modelMatrix *  vec4( position, 1.0 );\n\t\t\t\t\t#endif\n\n\t\t\t\t\tgl_Position = pmvPosition;\n\n\t\t\t\t\t#if defined(PASS_POINT_NORMAL) || defined(PASS_POINT_MAP)\n\t\t\t\t\t\tvDepth = pmvPosition.z / -cameraFar;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef ATTR_ROTATION\n\t\t\t\t\t\tvRotation = rotation;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef ATTR_ALPHA\n\t\t\t\t\t\tvAlpha = alpha;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef ATTR_SIZE\n\t\t\t\t\t\tgl_PointSize = 1.0 * particleScale * size * ( viewHeightHalf / length( pmvPosition.xyz ) );\n\n\t\t\t\t\t\t#ifdef PASS_SHADOW\n\t\t\t\t\t\t\tgl_PointSize = 1.0 * particleScale * size;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t#else\n\t\t\t\t\t\tgl_PointSize = 1.0 * particleScale * ( viewHeightHalf / length( pmvPosition.xyz ) );\n\n\t\t\t\t\t\t#ifdef PASS_SHADOW\n\t\t\t\t\t\t\tgl_PointSize = 1.0 * particleScale;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// Shadows\n\t\t\t\t\t#if defined(PASS_GBUFFER)\n\t\t\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.vertMain() + "\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// We need to add the pass data\n\t\t\t\t\t" + Trike.ShaderFragments.Passes.vertNormDepthMain() + "\n\n\t\t\t\t\t#if defined(PASS_POINT_NORMAL) && defined(USE_BUMPMAP)\n\t\t\t\t\t\tvViewPosition = -pmvPosition.xyz;\n\t\t\t\t\t#endif\n\t\t\t\t}\n\n\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialPointCloud.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\t" + Trike.ShaderFragments.FragParams.defaults() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.clippingParams() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.map() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.encodeNormal() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.bumpmapFunctions() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.vecToFloat() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.floatToVec() + "\n\t\t\t\tuniform float flipUV;\n\n\t\t\t\t#if !defined(SCREEN_UVS)\n\t\t\t\t\tuniform vec2 uvScale;\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(ATTR_ROTATION)\n\t\t\t\t\tvarying float vRotation;\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(ATTR_ALPHA)\n\t\t\t\t\tvarying float vAlpha;\n\t\t\t\t#endif\n\n\t\t\t\t#if defined(PASS_POINT_NORMAL) || defined(PASS_POINT_MAP) || defined(SCREEN_UVS)\n\t\t\t\t\tuniform float viewHeight;\n\t\t\t\t\tuniform float viewWidth;\n\t\t\t\t#endif\n\n\t\t\t\t// GBUFFER PASS\n\t\t\t\t// ************************\n\t\t\t\t#if defined(PASS_GBUFFER)\n\n\t\t\t\t\tuniform vec3 emissive;\n\t\t\t\t\tuniform vec3 diffuse;\n\t\t\t\t\tuniform vec3 specular;\n\n\t\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.fragParams() + "\n\n\t\t\t\t// GBUFFER2 PASS\n\t\t\t\t// ************************\n\t\t\t\t#elif defined(PASS_GBUFFER2)\n\n\t\t\t\t\t#ifdef SCREEN_UVS\n\t\t\t\t\t\tuniform sampler2D normalMap;\n\t\t\t\t\t#endif\n\n\t\t\t\t\tuniform float uniformDepth;\n\t\t\t\t\tuniform float normalizedRadius;\n\t\t\t\t\tuniform float shininess;\n\n\t\t\t\t\t#if defined(USE_MAP) && defined(USE_BUMPMAP)\n\t\t\t\t\t\tuniform float particleScale;\n\t\t\t\t\t\tuniform float bumpScale;\n\t\t\t\t\t#endif\n\n\t\t\t\t// MAP & NORMAL PASS\n\t\t\t\t// ************************\n\t\t\t\t#elif defined(PASS_POINT_NORMAL) || defined(PASS_POINT_MAP)\n\t\t\t\t\tvarying float vDepth;\n\t\t\t\t\tuniform float opacity;\n\t\t\t\t\tuniform sampler2D gBuffer2;\n\t\t\t\t\tuniform float softnessScale;\n\n\t\t\t\t\t#if defined(PASS_POINT_NORMAL) && defined(USE_BUMPMAP)\n\t\t\t\t\t\tuniform float particleScale;\n\t\t\t\t\t\tuniform float bumpScale;\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.clippingTest() + "\n\n\t\t\t\t\t// Generate the UV Coordinates\n\t\t\t\t\t#if defined(SCREEN_UVS)\n\t\t\t\t\t\tvec2 vUv = gl_FragCoord.xy / vec2( viewWidth, viewHeight );\n\t\t\t\t\t#else\n\t\t\t\t\t\t#ifdef ATTR_ROTATION\n\t\t\t\t\t\t\tfloat mid = 0.5;\n\t\t\t\t\t\t\tvec2 vUv = vec2( cos( vRotation ) * ( gl_PointCoord.x - mid ) + sin( vRotation ) * ( gl_PointCoord.y - mid ) + mid,\n\t\t\t\t\t\t\tcos( vRotation ) * ( gl_PointCoord.y - mid ) - sin( vRotation ) * ( gl_PointCoord.x - mid ) + mid);\n\t\t\t\t\t\t\tvUv = vUv * uvScale;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tvec2 vUv = (vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )) * uvScale;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t#endif\n\n\t\t\t\t\tif (flipUV === 1.0 )\n\t\t\t\t\tvUv = vec2( 1.0, 1.0 ) - vUv;\n\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.alphaTest() + "\n\n\t\t\t\t\t//\t************************************************************\n\t\t\t\t\t//\tGBUFFER PASS\n\t\t\t\t\t//\tDraws the GBuffer material information\n\t\t\t\t\t//\t************************************************************\n\t\t\t\t\t#if defined(PASS_GBUFFER)\n\n\t\t\t\t\t\t#ifndef USE_MAP\n\t\t\t\t\t\t\tvec4 texelColor = vec4(1.0, 1.0, 1.0, 1.0);\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.fragMain() + "\n\n\t\t\t\t\t\t#ifndef SHADOW_MAPPING\n\t\t\t\t\t\t\tfloat shadowAmount = 1.0;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// Diffuse color in x\n\t\t\t\t\t\tgl_FragColor.x = vec3_to_float( diffuse * shadowAmount );\n\n\t\t\t\t\t\t// Emmsive in w\n\t\t\t\t\t\tgl_FragColor.w = vec3_to_float( emissive * shadowAmount );\n\n\t\t\t\t\t\t// specular color in y\n\t\t\t\t\t\tgl_FragColor.y = vec3_to_float( specular * shadowAmount );\n\n\t\t\t\t\t\t// Albedo in Z\n\t\t\t\t\t\tgl_FragColor.z = vec3_to_float( texelColor.xyz );\n\n\t\t\t\t\t#endif\n\n\n\t\t\t\t\t// If the map or normal pass\n\t\t\t\t\t#if defined(PASS_POINT_MAP) || defined(PASS_POINT_NORMAL)\n\n\t\t\t\t\t\tfloat opacityStrength = opacity;\n\t\t\t\t\t\t#ifdef ATTR_ALPHA\n\t\t\t\t\t\t\topacityStrength *= vAlpha;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// Soft particles - check the current depth, and fade out if too close to it\n\t\t\t\t\t\t// http://www.informatik.uni-oldenburg.de/~trigger/page7.html\n\t\t\t\t\t\tvec2 screenUv = gl_FragCoord.xy / vec2( viewWidth, viewHeight );\n\t\t\t\t\t\tvec4 gBuffer2Sample = texture2D( gBuffer2, screenUv );\n\t\t\t\t\t\tfloat bbDepth = clamp(vDepth * -1.0, 0.0, 1.0);\n\t\t\t\t\t\tfloat softness = 0.0;\n\t\t\t\t\t\tfloat targetDepth = gBuffer2Sample.z; // clamp(gBuffer2Sample.z, 0.0, 1.0);\n\t\t\t\t\t\tif ( targetDepth === 0.0 )\n\t\t\t\t\t\t\tsoftness = 1.0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( targetDepth < bbDepth )\n\t\t\t\t\t\t\t\tsoftness = 0.0;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tsoftness = smoothstep(0.0, softnessScale, targetDepth - bbDepth );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsoftness = clamp( softness, 0.0, 1.0);\n\t\t\t\t\t\topacityStrength *= softness;\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t//\t************************************************************\n\t\t\t\t\t//\tPOINT MAP PASS\n\t\t\t\t\t//\tThe point map pass draws the texture to a screen quad\n\t\t\t\t\t//\t************************************************************\n\t\t\t\t\t#if defined(PASS_POINT_MAP)\n\n\t\t\t\t\t\t#ifdef PREMULTIPLIED_ALPHA\n\t\t\t\t\t\t\tgl_FragColor.rgb = texelColor.rgb * texelColor.w * opacityStrength;\n\t\t\t\t\t\t\tgl_FragColor.w = texelColor.w * opacityStrength;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tgl_FragColor = texelColor;\n\t\t\t\t\t\t\tgl_FragColor.w = texelColor.w * opacityStrength;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t//\t************************************************************\n\t\t\t\t\t//\tPOINT MAP PASS\n\t\t\t\t\t//\tThe normal map pass draws the normals to a screen quad\n\t\t\t\t\t//\t************************************************************\n\t\t\t\t\t#elif defined(PASS_POINT_NORMAL)\n\n\t\t\t\t\t\tvec3 normal = vec3( gl_PointCoord.x * 4.0 - 2.0, 2.0 - gl_PointCoord.y * 4.0, 1.0 );\n\t\t\t\t\t\tnormal = normalize( normal );\n\t\t\t\t\t\tnormal = normal * 0.5 + 0.5;\n\n\t\t\t\t\t\t#ifdef USE_BUMPMAP\n\t\t\t\t\t\t\tvec2 pointUv = vec2( 1.0 - gl_PointCoord.x, gl_PointCoord.y );\n\t\t\t\t\t\t\tvec2 pointFragDelta = ( pointUv * particleScale ) - ( pointUv * ( particleScale * 0.5 ) );\n\t\t\t\t\t\t\tvec3 pointFragPosition = vViewPosition +  vec3( pointFragDelta, 0.0 );\n\t\t\t\t\t\t\tnormal = perturbNormalArb( -pointFragPosition, normalize( normal ), dHdxy_fwd( vUv, map, bumpScale ) );\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#ifdef PREMULTIPLIED_ALPHA\n\t\t\t\t\t\t\tgl_FragColor.rgb = normal * texelColor.w * opacityStrength;\n\t\t\t\t\t\t\tgl_FragColor.w = texelColor.w * opacityStrength;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tgl_FragColor = vec4( normal, opacityStrength );\n\t\t\t\t\t\t\tgl_FragColor.w = texelColor.w * opacityStrength;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t" + Trike.ShaderFragments.Passes.fragNormDepthMain() + "\n\t\t\t\t\t" + Trike.ShaderFragments.Passes.fragShadowMain() + "\n\t\t\t\t}\n\t\t\t";
        };
        /**
        * Gets or sets the type of UV coordinates to generate for the material. They can either be created for each
        * point or from a screen quad ( used if blending is on )
        * @param {UVCoordinates} val [Optional]
        * @returns {UVCoordinates}
        */
        MaterialPointCloud.prototype.uvCoordinates = function (val) {
            if (val === undefined)
                return this._uvCoordinates;
            if (this._uvCoordinates === val)
                return;
            var subMaterials = [
                this.materials[Trike.PassType.GBuffer],
                this.materials[Trike.PassType.GBuffer2],
                this.materials[Trike.PassType.ShadowLightPass]
            ];
            var subMat;
            this._uvCoordinates = val;
            for (var i = 0, l = subMaterials.length; i < l; i++) {
                subMat = subMaterials[i];
                if (val === UVCoordinates.ScreenBased) {
                    subMat.addDefine('#define SCREEN_UVS');
                    subMat.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 500));
                    subMat.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 500));
                    subMat.removeUniform('uvScale');
                }
                else {
                    subMat.addUniform(new Trike.UniformVar('uvScale', Trike.UniformType.FLOAT2, this._uvScale, false));
                    subMat.removeDefine('#define SCREEN_UVS');
                    subMat.removeUniform('viewWidth');
                    subMat.removeUniform('viewHeight');
                }
            }
            if (val === UVCoordinates.ScreenBased) {
                this.depthRead = false;
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('uniformDepth', Trike.UniformType.FLOAT, this._uniformDepth));
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('normalizedRadius', Trike.UniformType.FLOAT, this._normalizedRadius));
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('normalMap', Trike.UniformType.TEXTURE, null));
                this.materials[Trike.PassType.GBuffer2].removeUniform('cameraFar');
            }
            else {
                this.materials[Trike.PassType.GBuffer2].removeUniform('normalMap');
                this.materials[Trike.PassType.GBuffer2].removeUniform('uniformDepth');
                this.materials[Trike.PassType.GBuffer2].removeUniform('normalizedRadius');
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('cameraFar', Trike.UniformType.FLOAT));
                this.depthRead = true;
            }
            this.bumpMap(this._bump);
            return val;
        };
        /*
        * Gets or sets the texture map of this material
        * @param {TextureBase} val
        * @returns {TextureBase}
        */
        MaterialPointCloud.prototype.map = function (val) {
            if (val === undefined)
                return this._map;
            var gBuffer = this.materials[Trike.PassType.GBuffer];
            var gBuffer2 = this.materials[Trike.PassType.GBuffer2];
            var mapPass = this.materials[Trike.PassType.PointsTextureMap];
            var normalPass = this.materials[Trike.PassType.PointsNormalMap];
            var shadowPass = this.materials[Trike.PassType.ShadowLightPass];
            if (this._map && val) {
                this._map = val;
                mapPass.setUniform('map', val, false);
                normalPass.setUniform('map', val, false);
                gBuffer.setUniform('map', val, false);
                gBuffer2.setUniform('map', val, false);
                shadowPass.setUniform('map', val, false);
            }
            else if (!this._map && val) {
                this._map = val;
                mapPass.setUniform('map', val, false);
                normalPass.setUniform('map', val, false);
                gBuffer.addUniform(new Trike.UniformVar('map', Trike.UniformType.TEXTURE, val));
                gBuffer.addDefine(Trike.ShaderDefines.USE_MAP);
                gBuffer2.addUniform(new Trike.UniformVar('map', Trike.UniformType.TEXTURE, val));
                gBuffer2.addDefine(Trike.ShaderDefines.USE_MAP);
                shadowPass.addUniform(new Trike.UniformVar('map', Trike.UniformType.TEXTURE, val));
                shadowPass.addDefine(Trike.ShaderDefines.USE_MAP);
            }
            else {
                this._map = null;
                gBuffer.removeUniform('map');
                gBuffer.removeDefine(Trike.ShaderDefines.USE_MAP);
                gBuffer2.removeUniform('map');
                gBuffer2.removeDefine(Trike.ShaderDefines.USE_MAP);
                shadowPass.removeUniform('map');
                shadowPass.removeDefine(Trike.ShaderDefines.USE_MAP);
            }
            return val;
        };
        /*
        * Gets or sets if we should apply bump mapping to the diffuse map
        * @param {boolean} val [Optional]
        * @returns {boolean}
        */
        MaterialPointCloud.prototype.bumpMap = function (val) {
            if (val === undefined)
                return this._bump;
            var gBuffer2 = this.materials[Trike.PassType.GBuffer2];
            var normalPass = this.materials[Trike.PassType.PointsNormalMap];
            gBuffer2.removeUniform('bumpScale');
            gBuffer2.removeDefine(Trike.ShaderDefines.STANDARD_DERIVATIVES);
            gBuffer2.removeDefine(Trike.ShaderDefines.BUMP_MAP);
            normalPass.removeUniform('bumpScale');
            normalPass.removeDefine(Trike.ShaderDefines.STANDARD_DERIVATIVES);
            normalPass.removeDefine(Trike.ShaderDefines.BUMP_MAP);
            if (val) {
                if (this._uvCoordinates === UVCoordinates.PerPoint) {
                    gBuffer2.addUniform(new Trike.UniformVar('bumpScale', Trike.UniformType.FLOAT, this._bumpScale));
                    gBuffer2.addDefine(Trike.ShaderDefines.STANDARD_DERIVATIVES);
                    gBuffer2.addDefine(Trike.ShaderDefines.BUMP_MAP);
                }
                normalPass.addUniform(new Trike.UniformVar('bumpScale', Trike.UniformType.FLOAT, this._bumpScale));
                normalPass.addDefine(Trike.ShaderDefines.STANDARD_DERIVATIVES);
                normalPass.addDefine(Trike.ShaderDefines.BUMP_MAP);
            }
            this._bump = val;
            return val;
        };
        /*
        * Gets or sets the bumpiness scale of the bump map.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialPointCloud.prototype.bumpScale = function (val) {
            if (val === undefined)
                return this._bumpScale;
            var gBuffer2 = this.materials[Trike.PassType.GBuffer2];
            var normalPass = this.materials[Trike.PassType.PointsNormalMap];
            this._bumpScale = val;
            if (this._bump) {
                if (this._uvCoordinates === UVCoordinates.PerPoint)
                    gBuffer2.setUniform('bumpScale', val, false);
                normalPass.setUniform('bumpScale', val, false);
            }
            return val;
        };
        /**
        * Gets or sets the alpha test value. Alpha tests are used to discard pixels with alpha less than
        * the value set as the test. I.e. if the alpha test is 0.5, then any pixels with an
        * alpha value of less than 0.5 are discarded from the render process.
        * @param {number} val
        */
        MaterialPointCloud.prototype.alphaTest = function (val) {
            if (val === undefined)
                return this._alphaTest;
            this.removeDefine('#define ALPHATEST ' + this._alphaTest.toFixed(3));
            this._alphaTest = val;
            if (val !== 0)
                this.addDefine('#define ALPHATEST ' + this._alphaTest.toFixed(3));
            return this._alphaTest;
        };
        /*
        * Gets or sets the view space world position of the particles
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialPointCloud.prototype.uniformDepth = function (val) {
            if (val === undefined)
                return this._uniformDepth;
            this._uniformDepth = val;
            if (this._uvCoordinates === UVCoordinates.ScreenBased)
                this.materials[Trike.PassType.GBuffer2].setUniform('uniformDepth', val, false);
            return val;
        };
        /*
        * Gets or sets the radius of the particles in normalized values (radius / (camera far - min)
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialPointCloud.prototype.normalizedRadius = function (val) {
            if (val === undefined)
                return this._normalizedRadius;
            this._normalizedRadius = val;
            if (this._uvCoordinates === UVCoordinates.ScreenBased)
                this.materials[Trike.PassType.GBuffer2].setUniform('normalizedRadius', val, false);
            return val;
        };
        /*
        * Gets or sets emissive light colour
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialPointCloud.prototype.emissive = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['emissive'].value;
            this.materials[Trike.PassType.GBuffer].setUniform('emissive', val, false);
            return val;
        };
        /*
        * Sets the rotation amount of the sprite in radians
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialPointCloud.prototype.rotation = function (val) {
            if (val === undefined)
                return this._uniforms['rotation'].value;
            this.setUniform('rotation', val, true);
            return val;
        };
        /*
        * Gets or sets the UV scale of the texture coordinates. Higher values mean higher UV tesselation
        * @param {Vec2} val
        * @returns {Vec2}
        */
        MaterialPointCloud.prototype.uvScale = function (val) {
            if (val === undefined)
                return this._uvScale;
            this._uvScale = val;
            if (this._uvCoordinates === UVCoordinates.PerPoint) {
                this.materials[Trike.PassType.GBuffer].setUniform('uvScale', this._uvScale, false);
                this.materials[Trike.PassType.GBuffer2].setUniform('uvScale', this._uvScale, false);
            }
            this.materials[Trike.PassType.PointsTextureMap].setUniform('uvScale', this._uvScale, false);
            this.materials[Trike.PassType.PointsNormalMap].setUniform('uvScale', this._uvScale, false);
            return this._uvScale;
        };
        /*
        * Gets or sets diffuse lighting color of the material
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialPointCloud.prototype.diffuse = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['diffuse'].value;
            this.materials[Trike.PassType.GBuffer].setUniform('diffuse', val, false);
            return val;
        };
        /*
        * Gets or sets specular light colour
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialPointCloud.prototype.specular = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['specular'].value;
            this.materials[Trike.PassType.GBuffer].setUniform('specular', val, false);
            return val;
        };
        /*
        * Gets or sets the shininess of the specular component
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialPointCloud.prototype.shininess = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer2]._uniforms['shininess'].value;
            this.materials[Trike.PassType.GBuffer2].setUniform('shininess', val, false);
            return val;
        };
        /*
        * Gets or sets the opacity of this material. The values are from 0 to 1.
        * @param {number} val
        */
        MaterialPointCloud.prototype.opacity = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer2]._uniforms['opacity'].value;
            this.materials[Trike.PassType.GBuffer2].setUniform('opacity', val, false);
            return val;
        };
        /*
        * Gets or sets if translucency is enabled
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialPointCloud.prototype.translucencyEnabled = function (val) {
            if (val === undefined)
                return this._translucencyEnabled;
            if (this._translucencyEnabled === val)
                return;
            if (val) {
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('translucencyScale', Trike.UniformType.FLOAT, this._translucencyScale), false);
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('translucencyDistortion', Trike.UniformType.FLOAT, this._translucencyDistortion), false);
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('translucencyPower', Trike.UniformType.FLOAT, this._translucencyPower), false);
                this.materials[Trike.PassType.GBuffer2].addDefine(Trike.ShaderDefines.TRANSLUCENCY_ENABLED);
            }
            else {
                this.materials[Trike.PassType.GBuffer2].removeUniform('translucencyScale', false);
                this.materials[Trike.PassType.GBuffer2].removeUniform('translucencyDistortion', false);
                this.materials[Trike.PassType.GBuffer2].removeUniform('translucencyPower', false);
                this.materials[Trike.PassType.GBuffer2].removeDefine(Trike.ShaderDefines.TRANSLUCENCY_ENABLED);
            }
            this._translucencyEnabled = val;
        };
        /*
        * Gets or sets the translucency scale of the material. This is a uniform multiplier of the effect.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialPointCloud.prototype.translucencyScale = function (val) {
            if (val === undefined)
                return this._translucencyScale;
            this._translucencyScale = val;
            if (this._translucencyEnabled)
                this.materials[Trike.PassType.GBuffer2].setUniform('translucencyScale', val, false);
        };
        /*
        * Gets or sets the translucency distortion of the material.
        * Modifies the light angle as it enters the material
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialPointCloud.prototype.translucencyDistortion = function (val) {
            if (val === undefined)
                return this._translucencyDistortion;
            this._translucencyDistortion = val;
            if (this._translucencyEnabled)
                this.materials[Trike.PassType.GBuffer2].setUniform('translucencyDistortion', val, false);
        };
        /*
        * Gets or sets the translucency power of the material.
        * Increasing this has the effect of narrowing the area of the effect
        * @param {number} val [Optional]
        */
        MaterialPointCloud.prototype.translucencyPower = function (val) {
            if (val === undefined)
                return this._translucencyPower;
            this._translucencyPower = val;
            if (this._translucencyEnabled)
                this.materials[Trike.PassType.GBuffer2].setUniform('translucencyPower', val, false);
        };
        Object.defineProperty(MaterialPointCloud.prototype, "particleSoftness", {
            get: function () { return this.materials[Trike.PassType.PointsTextureMap]._uniforms['softnessScale'].value; },
            set: function (val) {
                this.materials[Trike.PassType.PointsTextureMap].setUniform('softnessScale', val, false);
                this.materials[Trike.PassType.PointsNormalMap].setUniform('softnessScale', val, false);
            },
            enumerable: true,
            configurable: true
        });
        return MaterialPointCloud;
    }(Trike.MaterialMulti));
    Trike.MaterialPointCloud = MaterialPointCloud;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * The MaterialTerrain is a special material used exclusively on terrains. Its based on Geo Clipmapping, and was inspired by the links below
    * http://www.pheelicks.com/2014/03/rendering-large-terrains/
    * http://www.gamasutra.com/blogs/JasmineKent/20130904/199521/WebGL_Terrain_Rendering_in_Trigger_Rally__Part_1.php
    * https://github.com/CodeArtemis/TriggerRally/blob/unified/server/public/scripts/client/terrain.coffee
    */
    var MaterialTerrain = (function (_super) {
        __extends(MaterialTerrain, _super);
        /**
        * Creates an instance of the terrain material
        * @param {number} tileResolution The resolution of the planes used in the terrain
        * @param {number} altitude Specified how high/low the terrain will go. Default is 200.
        * @param {number} worldScale Defines how wide and deep the heightfield texture must be sampled. Higher values mean more vast terrain. Default is 1024.
        */
        function MaterialTerrain(tileResolution, altitude, worldScale, editorMode) {
            if (altitude === void 0) { altitude = 200; }
            if (worldScale === void 0) { worldScale = 1024; }
            if (editorMode === void 0) { editorMode = true; }
            // Call the material base
            _super.call(this);
            if (editorMode)
                this.materials[Trike.PassType.EditorPass] = new Trike.PassMaterial('Terrain Editor Pass', this);
            this.materials[Trike.PassType.TerrainAlbedo] = new Trike.PassMaterial('Terrain Albedo Pass', this);
            this._albedoPass = new Trike.MaterialPass(512, 512, Trike.PassType.TerrainAlbedo);
            this._albedoPass.enabled = false;
            Trike.MaterialMulti.materialPasses.push(this._albedoPass);
            this._bumpMap = null;
            this._heightfield = null;
            this._alphaTest = 0;
            this._tileScale = 0.2;
            this._rockScale = 50;
            this._altitude = altitude;
            this._heightOffset = 0;
            this._prevWidth = 0;
            this._prevHeight = 0;
            this._worldScale = worldScale;
            this._bumpMapping = false;
            this._numDiffuseTextures = 0;
            // Height based colours
            this._heightBasedColors = false;
            this._topColor = new Trike.Color(0xFFFFFF);
            this._midColor = new Trike.Color(0x7A7662);
            this._bottomColor = new Trike.Color(0x4F483B);
            this._heightColorsMinAltitude = 0;
            this._heightColorsMidAltitude = altitude / 2;
            this._heightColorsMaxAltitude = altitude;
            // Brush related
            this._brushMode = false;
            this._ring_border_width = 0.8;
            this._ring_color = new Trike.Color(0xFFFFFF);
            this._ring_center = new Trike.Vec3();
            this._ring_radius = 5.0;
            this._ring_falloff = 1.0;
            this._bumpDistance = 0.03;
            this._rockDistance = 0;
            // Terrain textures
            this._tileScaleRock = new Trike.Vec2(1, 1);
            this._tileScaleBase = new Trike.Vec2(1, 1);
            this._tileScaleDiff1 = new Trike.Vec2(1, 1);
            this._tileScaleDiff2 = new Trike.Vec2(1, 1);
            this._tileScaleDiff3 = new Trike.Vec2(1, 1);
            this._tileScaleDiff4 = new Trike.Vec2(1, 1);
            // Translucency
            this._translucencyEnabled = false;
            this._translucencyScale = 1;
            this._translucencyDistortion = 0.185;
            this._translucencyPower = 0.04;
            this._textureEvent = { type: Trike.TerrainTextureType.Colors };
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('modelViewMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('projectionMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('worldScale', Trike.UniformType.FLOAT, worldScale), true);
            this.addUniform(new Trike.UniformVar('uTileOffset', Trike.UniformType.FLOAT2, new Trike.Vec2()), true);
            this.addUniform(new Trike.UniformVar('camPosition', Trike.UniformType.FLOAT3, new Trike.Vec3()), true);
            this.addUniform(new Trike.UniformVar('uTileOffset', Trike.UniformType.FLOAT2, new Trike.Vec2()), true);
            this.addUniform(new Trike.UniformVar('uScale', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('uEdgeMorph', Trike.UniformType.INT, 0), true);
            this.addUniform(new Trike.UniformVar('customClipping', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('customClipPlane', Trike.UniformType.FLOAT4), true);
            // Albedo Pass
            this.materials[Trike.PassType.TerrainAlbedo].addDefine('#define ALBEDO_PASS');
            // GBufffer only
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('diffuse', Trike.UniformType.COLOR3, new Trike.Color(0x96762C)));
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('specular', Trike.UniformType.COLOR3, new Trike.Color(0xffffff)));
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('emissive', Trike.UniformType.COLOR3, new Trike.Color(0x000000)));
            // Add the camera far uniform to the normal depth material
            this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('cameraFar', Trike.UniformType.FLOAT, 1000));
            this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('shininess', Trike.UniformType.FLOAT, 0.05));
            this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('opacity', Trike.UniformType.FLOAT, 1));
            // Remove model matrix from shadow as its not used
            this.materials[Trike.PassType.ShadowLightPass].removeUniform('modelMatrix');
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            this.addAttribute(new Trike.AttributeVar('normal', Trike.AttributeType.NORMAL));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.addDefine(Trike.ShaderDefines.ATTR_NORMAL);
            this.addDefine(Trike.ShaderDefines.STANDARD_DERIVATIVES);
            this._tileResolution = tileResolution;
            this.tileResolution(tileResolution);
            this.addDefine('#define EGDE_MORPH_TOP 1');
            this.addDefine('#define EGDE_MORPH_LEFT 2');
            this.addDefine('#define EGDE_MORPH_BOTTOM 4');
            this.addDefine('#define EGDE_MORPH_RIGHT 8');
            this.addDefine('#define MORPH_REGION 0.3');
            if (editorMode)
                this.materials[Trike.PassType.EditorPass].addDefine(Trike.ShaderDefines.EDITOR_PASS);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.heightmap(null);
            this.heightColors(true);
            this.bumpMapping(true);
        }
        /**
        * Cleans up all references
        */
        MaterialTerrain.prototype.dispose = function () {
            Trike.MaterialMulti.materialPasses.splice(Trike.MaterialMulti.materialPasses.indexOf(this._albedoPass), 1);
            _super.prototype.dispose.call(this);
            this._heightfield = null;
            this._bumpMap = null;
            this._tileScaleBase = null;
            this._tileScaleDiff1 = null;
            this._tileScaleDiff2 = null;
            this._tileScaleDiff3 = null;
            this._tileScaleDiff4 = null;
            this._tileScaleRock = null;
            this._topColor = null;
            this._midColor = null;
            this._bottomColor = null;
            this._ring_color = null;
            this._ring_center = null;
            this._textureEvent = null;
            this._albedoPass = null;
        };
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialTerrain.prototype.getVertexShader = function () {
            return "\n\n\t\t\t\t" + Trike.ShaderFragments.VertParams.defaults() + "\n\t\t\t\t" + Trike.ShaderFragments.VertParams.clippingParameters() + "\n\n\t\t\t\t#ifdef USE_HEIGHTFIELD\n\t\t\t\t\tuniform sampler2D heightfield;\n\t\t\t\t#endif\n\n\t\t\t\t// Used when sampling the heightfield. Higher values mean vaster terrain\n\t\t\t\tuniform float worldScale;\n\n\t\t\t\t// Used to amplify the height\n\t\t\t\tuniform float altitude;\n\n\t\t\t\t// Used to offset the terrain vertically\n\t\t\t\tuniform float heightOffset;\n\n\t\t\t\t// Used for the tile positioning\n\t\t\t\tuniform vec3 camPosition;\n\t\t\t\tuniform vec2 uTileOffset;\n\t\t\t\tuniform float uScale;\n\t\t\t\tuniform int uEdgeMorph;\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#ifdef BRUSHMODE\n\t\t\t\t\tvarying vec4 vPosition;\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef PASS_GBUFFER\n\t\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.vertParams() + "\n\t\t\t\t\t#ifdef HEIGHT_COLORS\n\t\t\t\t\t\tvarying float height;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef USE_HEIGHTFIELD\n\n\t\t\t\t\t// catmull works by specifying 4 control points p0, p1, p2, p3 and a weight. The function is used to calculate a point n between p1 and p2 based\n\t\t\t\t\t// on the weight. The weight is normalized, so if it's a value of 0 then the return value will be p1 and if its 1 it will return p2.\n\t\t\t\t\tfloat catmullRom( float p0, float p1, float p2, float p3, float weight )\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat weight2 = weight * weight;\n\t\t\t\t\t\treturn 0.5 * (\n\t\t\t\t\t\tp0 * weight * ( ( 2.0 - weight ) * weight - 1.0 ) +\n\t\t\t\t\t\tp1 * ( weight2 * ( 3.0 * weight - 5.0 ) + 2.0 ) +\n\t\t\t\t\t\tp2 * weight * ( ( 4.0 - 3.0 * weight ) * weight + 1.0 ) +\n\t\t\t\t\t\tp3 * ( weight - 1.0 ) * weight2 );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Performs a horizontal catmulrom operation at a given V value.\n\t\t\t\t\tfloat textureCubicU( sampler2D samp, vec2 uv00, float texel, float offsetV, float frac )\n\t\t\t\t\t{\n\t\t\t\t\t\treturn catmullRom(\n\t\t\t\t\t\ttexture2DLod( samp, uv00 + vec2( -texel, offsetV ), 0.0 ).r,\n\t\t\t\t\t\ttexture2DLod( samp, uv00 + vec2( 0.0, offsetV ), 0.0 ).r,\n\t\t\t\t\t\ttexture2DLod( samp, uv00 + vec2( texel, offsetV ), 0.0 ).r,\n\t\t\t\t\t\ttexture2DLod( samp, uv00 + vec2( texel * 2.0, offsetV ), 0.0 ).r,\n\t\t\t\t\t\tfrac );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Samples a texture using a bicubic sampling algorithm. This essentially queries neighbouring\n\t\t\t\t\t// pixels to get an average value.\n\t\t\t\t\tfloat textureBicubic( sampler2D samp, vec2 uv00, vec2 texel, vec2 frac )\n\t\t\t\t\t{\n\t\t\t\t\t\treturn catmullRom(\n\t\t\t\t\t\ttextureCubicU( samp, uv00, texel.x, -texel.y, frac.x ),\n\t\t\t\t\t\ttextureCubicU( samp, uv00, texel.x, 0.0, frac.x ),\n\t\t\t\t\t\ttextureCubicU( samp, uv00, texel.x, texel.y, frac.x ),\n\t\t\t\t\t\ttextureCubicU( samp, uv00, texel.x, texel.y * 2.0, frac.x ),\n\t\t\t\t\t\tfrac.y );\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\t// Gets the  UV coordinates based on the world X Z position\n\t\t\t\tvec2 worldToMapSpace( vec2 worldPosition )\n\t\t\t\t{\n\t\t\t\t\treturn ( worldPosition / worldScale + 0.5 );\n\t\t\t\t}\n\n\n\t\t\t\t// Gets the height at a location p (world space)\n\t\t\t\tfloat getHeight( vec3 worldPosition )\n\t\t\t\t{\n\t\t\t\t\t#ifdef USE_HEIGHTFIELD\n\n\t\t\t\t\t\tvec2 heightUv = worldToMapSpace(worldPosition.xz);\n\t\t\t\t\t\tvec2 tHeightSize = vec2( HEIGHTFIELD_SIZE_X, HEIGHTFIELD_SIZE_Y );\n\n\t\t\t\t\t\t// If we increase the smoothness factor, the terrain becomes a lot smoother.\n\t\t\t\t\t\t// This is because it has the effect of shrinking the texture size and increaing\n\t\t\t\t\t\t// the texel size. Which means when we do sampling the samples are from farther away - making\n\t\t\t\t\t\t// it smoother. However this means the terrain looks less like the original heightmap and so\n\t\t\t\t\t\t// terrain picking goes a bit off.\n\t\t\t\t\t\tfloat smoothness = 1.1;\n\t\t\t\t\t\ttHeightSize /= smoothness;\n\n\t\t\t\t\t\t// The size of each texel\n\t\t\t\t\t\tvec2 texel = vec2( 1.0 / tHeightSize );\n\n\t\t\t\t\t\t// Find the top-left texel we need to sample.\n\t\t\t\t\t\tvec2 heightUv00 = ( floor( heightUv * tHeightSize ) ) / tHeightSize;\n\n\t\t\t\t\t\t// Determine the fraction across the 4-texel quad we need to compute.\n\t\t\t\t\t\tvec2 frac = vec2( heightUv - heightUv00 ) * tHeightSize;\n\n\t\t\t\t\t\tfloat coarseHeight = textureBicubic( heightfield, heightUv00, texel, frac );\n\t\t\t\t\t\t//'\t\tfloat coarseHeight = texture2D( heightfield, heightUv ).r;\n\t\t\t\t\t\treturn altitude * coarseHeight + heightOffset;\n\t\t\t\t\t#else\n\t\t\t\t\t\treturn 0.0;\n\t\t\t\t\t#endif\n\t\t\t\t}\n\n\t\t\t\t// Gets the normal at a location p\n\t\t\t\tvec3 getNormal( vec3 pos, float morphFactor )\n\t\t\t\t{\n\t\t\t\t\t// Get 2 vectors perpendicular to the unperturbed normal, and create at point at each (relative to position)\n\t\t\t\t\tfloat delta = ( morphFactor + 1.0 ) * uScale / TILE_RESOLUTION;\n\t\t\t\t\tvec3 dA = delta * normalize( cross( normal.yzx, normal ));\n\t\t\t\t\tvec3 dB = delta * normalize( cross( normal, dA ));\n\t\t\t\t\tvec3 p = pos;\n\t\t\t\t\tvec3 pA = pos + dA;\n\t\t\t\t\tvec3 pB = pos + dB;\n\n\t\t\t\t\t// Now get the height at those points\n\t\t\t\t\tfloat h = getHeight(pos);\n\t\t\t\t\tfloat hA = getHeight(pA);\n\t\t\t\t\tfloat hB = getHeight(pB);\n\n\t\t\t\t\t// Update the points with their correct heights and calculate true normal\n\t\t\t\t\tp += normal * h;\n\t\t\t\t\tpA += normal * hA;\n\t\t\t\t\tpB += normal * hB;\n\t\t\t\t\treturn normalize( cross( pA - p, pB - p ) );\n\t\t\t\t}\n\n\n\t\t\t\t// This essentially checks to see which morph edge this tile represents. Because\n\t\t\t\t// its a bitwise operation you can check for multipe enums. I.e. if a tile was tagged as EGDE_MORPH_LEFT | EGDE_MORPH_TOP, this\n\t\t\t\t// function will return true if its checked against EGDE_MORPH_LEFT or EGDE_MORPH_TOP, but nothing else.\n\t\t\t\tbool edgePresent( int edge )\n\t\t\t\t{\n\t\t\t\t\tint e = uEdgeMorph / edge;\n\t\t\t\t\treturn 2 * ( e / 2 ) !== e;\n\t\t\t\t}\n\n\n\t\t\t\t// At the edges of tiles, morph the vertices if they are joining onto a higher layer.\n\t\t\t\t// The closer a vertex is to the edge, the higher the value returned will be. If the tile has an uEdgeMorph\n\t\t\t\t// of EGDE_MORPH_LEFT, and its x value is 0 then then the value returned will be 1. If the\n\t\t\t\t// value of x was === MORPH_REGION (which is the max distance from the edge before morphing) then it would be 0.\n\t\t\t\t// This function tells you how much the vertex needs to morph. Vertices away from the edge will return 0, but those\n\t\t\t\t// closer to edges will be higher.\n\t\t\t\tfloat calculateMorph( vec3 p )\n\t\t\t\t{\n\t\t\t\t\tfloat morphFactor = 0.0;\n\n\t\t\t\t\tif ( edgePresent( EGDE_MORPH_TOP ) && p.z >= 1.0 - MORPH_REGION )\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat m = 1.0 - clamp( ( 1.0 - p.z ) / MORPH_REGION, 0.0, 1.0 );\n\t\t\t\t\t\tmorphFactor = max( m, morphFactor );\n\t\t\t\t\t}\n\t\t\t\t\tif ( edgePresent( EGDE_MORPH_LEFT ) && p.x <= MORPH_REGION )\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat m = 1.0 - clamp( p.x / MORPH_REGION, 0.0, 1.0 );\n\t\t\t\t\t\tmorphFactor = max( m, morphFactor );\n\t\t\t\t\t}\n\t\t\t\t\tif ( edgePresent( EGDE_MORPH_BOTTOM ) && p.z <= MORPH_REGION )\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat m = 1.0 - clamp( p.z / MORPH_REGION, 0.0, 1.0 );\n\t\t\t\t\t\tmorphFactor = max( m, morphFactor );\n\t\t\t\t\t}\n\t\t\t\t\tif ( edgePresent( EGDE_MORPH_RIGHT ) && p.x >= 1.0 - MORPH_REGION )\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat m = 1.0 - clamp( ( 1.0 - p.x ) / MORPH_REGION, 0.0, 1.0 );\n\t\t\t\t\t\tmorphFactor = max( m, morphFactor );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn morphFactor;\n\t\t\t\t}\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tvec3 pos;\n\n\t\t\t\t\t// Morph factor tells us how close we are to next level.\n\t\t\t\t\t// 0.0 is this level\n\t\t\t\t\t// 1.0 is next level\n\t\t\t\t\tfloat morphFactor = calculateMorph(position);\n\n\t\t\t\t\t// Move into correct place by scaling the vert based on the scale and offset of the tile\n\t\t\t\t\t// Remember that the geometry for each tile is no larger than 1 unit wide and deep\n\t\t\t\t\tpos = uScale * position + vec3(uTileOffset.x, 0.0, uTileOffset.y) + vec3(camPosition.x, 0.0, camPosition.z);\n\n\t\t\t\t\t// Snap to grid\n\t\t\t\t\tfloat grid = uScale / TILE_RESOLUTION;\n\t\t\t\t\tpos = floor( pos / grid ) * grid;\n\n\t\t\t\t\t// Morph between zoom layers\n\t\t\t\t\tif ( morphFactor > 0.0 )\n\t\t\t\t\t{\n\t\t\t\t\t\t// Get position that we would have if we were on higher level grid\n\t\t\t\t\t\tgrid = 2.0 * grid;\n\t\t\t\t\t\tvec3 position2 = floor( pos / grid ) * grid;\n\n\t\t\t\t\t\t// Linearly interpolate the two, depending on morph factor\n\t\t\t\t\t\tpos = mix( pos, position2, morphFactor );\n\t\t\t\t\t}\n\n\n\t\t\t\t\t// Get height and calculate normal\n\t\t\t\t\tpos = pos + normal * getHeight( pos );\n\n\t\t\t\t\t// For reflection clipping\n\t\t\t\t\tvEyePosition = modelViewMatrix * vec4( pos, 1.0 );\n\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );\n\n\t\t\t\t\tvUv = worldToMapSpace(pos.xz);\n\t\t\t\t\t#ifdef BRUSHMODE\n\t\t\t\t\t\tvPosition = vec4( pos, 1.0 );\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#if defined(SHADOW_MAPPING) || defined(PASS_SHADOW)\n\t\t\t\t\t\tvec4 worldPosition = vec4( pos, 1.0 );\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef PASS_GBUFFER\n\t\t\t\t\t\t#ifdef HEIGHT_COLORS\n\t\t\t\t\t\t\theight = pos.y;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.vertMain() + "\n\t\t\t\t\t#endif\n\n\t\t\t\t\t// We need to add the pass data\n\t\t\t\t\t#ifdef PASS_GBUFFER2\n\t\t\t\t\t\tnormalView = normalMatrix * getNormal( pos, morphFactor );\n\t\t\t\t\t\tvNormal = normal;\n                        vec4 mvPosition;\n\t\t\t\t\t\tmvPosition = modelViewMatrix * vec4( pos, 1.0 );\n\t\t\t\t\t\t#ifdef USE_BUMPMAP\n\t\t\t\t\t\t\tvViewPosition = -mvPosition.xyz;\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\tvDepth = mvPosition.z / -cameraFar;\n\t\t\t\t\t#endif\n\t\t\t\t}\n\n\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialTerrain.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\t// Declarations\n\t\t\t\t" + Trike.ShaderFragments.FragParams.defaults() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.clippingParams() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.map() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.bumpmapUniforms() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.bumpmapFunctions() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.vecToFloat() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.encodeNormal() + "\n\n\t\t\t\t#ifdef USE_BUMPMAP\n\t\t\t\t\tuniform float bumpDistance;\n\t\t\t\t\tuniform float rockDistance;\n\t\t\t\t\tuniform float rockScale;\n\t\t\t\t\tuniform vec2 repeatOverlayRock;\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef ALBEDO_PASS\n\n\t\t\t\t\t#ifdef TERRAIN_TEX_BASE\n\t\t\t\t\t\tuniform vec2 repeatOverlayBase;\n\t\t\t\t\t\tuniform sampler2D tDiffuseBase;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef TERRAIN_TEX_SPLAT\n\t\t\t\t\t\tuniform sampler2D tSplat;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef TERRAIN_TEX_DIFF1\n\t\t\t\t\t\tuniform vec2 repeatOverlay1;\n\t\t\t\t\t\tuniform sampler2D tDiffuse1;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef TERRAIN_TEX_DIFF2\n\t\t\t\t\t\tuniform vec2 repeatOverlay2;\n\t\t\t\t\t\tuniform sampler2D tDiffuse2;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef TERRAIN_TEX_DIFF3\n\t\t\t\t\t\tuniform vec2 repeatOverlay3;\n\t\t\t\t\t\tuniform sampler2D tDiffuse3;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef TERRAIN_TEX_DIFF4\n\t\t\t\t\t\tuniform vec2 repeatOverlay4;\n\t\t\t\t\t\tuniform sampler2D tDiffuse4;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\n\t\t\t\t#ifdef PASS_GBUFFER\n\n\t\t\t\t\t" + Trike.ShaderFragments.FragParams.environmentMapping() + "\n\t\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.fragParams() + "\n\n\t\t\t\t\t#ifdef USE_SPECULARMAP\n\t\t\t\t\t\tuniform sampler2D specularMap;\n\t\t\t\t\t#endif\n\t\t\t\t\tuniform vec3 diffuse;\n\t\t\t\t\tuniform vec3 specular;\n\t\t\t\t\tuniform vec3 emissive;\n\n\n\n\t\t\t\t\t#ifdef HEIGHT_COLORS\n\t\t\t\t\t\tuniform vec3 topColor;\n\t\t\t\t\t\tuniform vec3 bottomColor;\n\t\t\t\t\t\tuniform vec3 midColor;\n\t\t\t\t\t\tuniform float heightColorsMinAltitude;\n\t\t\t\t\t\tuniform float heightColorsMidAltitude;\n\t\t\t\t\t\tuniform float heightColorsMaxAltitude;\n\t\t\t\t\t\tvarying float height;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef TERRAIN_TEX_COLORS\n\t\t\t\t\t\tuniform sampler2D tColourMap;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef TERRAIN_TEX_LIGHTMAP\n\t\t\t\t\t\tuniform sampler2D tLightmap;\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t\t// Used when sampling the heightfield. Higher values mean vaster terrain\n\t\t\t\tuniform float worldScale;\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t\t#ifdef EDITOR_PASS\n\t\t\t\t\t#ifdef BRUSHMODE\n\t\t\t\t\t\tvarying vec4 vPosition;\n\t\t\t\t\t\tuniform float ring_border_width;\n\t\t\t\t\t\tuniform vec3 ring_color;\n\t\t\t\t\t\tuniform vec3 ring_center;\n\t\t\t\t\t\tuniform float ring_radius;\n\t\t\t\t\t\tuniform float ring_falloff;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef USE_HEIGHTFIELD\n\t\t\t\t\t#ifdef PASS_GBUFFER2\n\t\t\t\t\t\tuniform sampler2D heightfield;\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\n\n\t\t\t\tvec2 worldToMapSpace( vec2 worldPosition )\n\t\t\t\t{\n\t\t\t\t\treturn ( worldPosition / worldScale + 0.5 );\n\t\t\t\t}\n\n\t\t\t\t#ifdef PASS_GBUFFER2\n\t\t\t\t\tuniform float shininess;\n\t\t\t\t#endif\n\n\t\t\t\t#if (defined(DIFFUSE_MAPS)) || (defined(PASS_GBUFFER2) && defined(USE_BUMPMAP))\n\t\t\t\t\tuniform sampler2D tDiffuseMaps;\n\t\t\t\t\tuniform float viewWidth;\n\t\t\t\t\tuniform float viewHeight;\n\t\t\t\t#endif\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.clippingTest() + "\n\n\t\t\t\t\t#if (defined(DIFFUSE_MAPS)) || (defined(PASS_GBUFFER2) && defined(USE_BUMPMAP))\n\t\t\t\t\t\tvec2 uvCoordinates = gl_FragCoord.xy / vec2( viewWidth, viewHeight );\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef PASS_GBUFFER\n\n\t\t\t\t\t\tfloat specularStrength = 1.0;\n\n\t\t\t\t\t\t#ifdef USE_SPECULARMAP\n\t\t\t\t\t\t\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\t\t\t\t\t\t\tspecularStrength = texelSpecular.r;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// Albedo in Z\n\t\t\t\t\t\t#ifdef DIFFUSE_MAPS\n\t\t\t\t\t\t\tvec4 texelColor = texture2D( tDiffuseMaps, uvCoordinates );\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tvec4 texelColor = vec4( 1.0,  1.0,  1.0, 1.0 );\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#ifdef TERRAIN_TEX_COLORS\n\t\t\t\t\t\t\ttexelColor *= texture2D( tColourMap, vUv );\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#ifdef TERRAIN_TEX_LIGHTMAP\n\t\t\t\t\t\t\ttexelColor *= texture2D( tLightmap, vUv );\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// Height based colours\n\t\t\t\t\t\t#ifdef HEIGHT_COLORS\n\t\t\t\t\t\t\tvec3 heightColors = bottomColor;\n\t\t\t\t\t\t\theightColors = mix( heightColors, midColor, smoothstep( heightColorsMinAltitude, heightColorsMidAltitude, height ) );\n\t\t\t\t\t\t\theightColors = mix( heightColors, topColor, smoothstep( heightColorsMidAltitude, heightColorsMaxAltitude, height ) );\n\t\t\t\t\t\t\ttexelColor.rgb *= heightColors;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t" + Trike.ShaderFragments.ShadowMapping.fragMain() + "\n\n\t\t\t\t\t\t#ifndef SHADOW_MAPPING\n\t\t\t\t\t\t\tfloat shadowAmount = 1.0;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// Diffuse color in x\n\t\t\t\t\t\tgl_FragColor.x = vec3_to_float( diffuse * shadowAmount );\n\n\t\t\t\t\t\t// Specular color in y\n\t\t\t\t\t\tgl_FragColor.y = vec3_to_float( specular * specularStrength * shadowAmount );\n\n\t\t\t\t\t\t// Albedo in z\n\t\t\t\t\t\tgl_FragColor.z = vec3_to_float( texelColor.xyz );\n\n\t\t\t\t\t\t// Emmsive in w\n\t\t\t\t\t\tgl_FragColor.w = vec3_to_float( emissive * shadowAmount );\n\n\t\t\t\t\t#endif\n\n\n\t\t\t\t\t//\tDraw the ring and grid on the terrain for when we are editing it.\n\t\t\t\t\t#ifdef EDITOR_PASS\n\t\t\t\t\t\t#ifdef BRUSHMODE\n\t\t\t\t\t\t\tfloat alpha = 0.0;\n\t\t\t\t\t\t\tfloat distance = sqrt((vPosition.x - ring_center.x) * (vPosition.x - ring_center.x) + (vPosition.z - ring_center.z) * (vPosition.z - ring_center.z));\n\t\t\t\t\t\t\tif (distance < ring_radius + ring_border_width / 2.0 && distance > ring_radius - ring_border_width / 2.0)\n\t\t\t\t\t\t\t\talpha = 1.0;\n\n\n\t\t\t\t\t\t\t// \tGrid overlay\n\t\t\t\t\t\t\tfloat gridDist = ring_radius * ring_falloff - ring_border_width / 2.0;\n\t\t\t\t\t\t\tif (distance < gridDist )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfloat tiles = 1.0 / 300.0;\n\t\t\t\t\t\t\t\tif (mod(vUv.x * worldScale, tiles) < .03 || mod(vUv.y * worldScale, tiles) < .03)\n\t\t\t\t\t\t\t\t\talpha = alpha * ( 1.0 - distance / gridDist );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgl_FragColor = vec4( ring_color, alpha );\n\t\t\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n\t\t\t\t\t\t#endif\n\t\t\t\t\t#endif\n\n\n\t\t\t\t\t#ifdef ALBEDO_PASS\n\t\t\t\t\t\t#ifdef TERRAIN_TEX_BASE\n\t\t\t\t\t\t\tvec2 uvTiledBase = repeatOverlayBase * vUv;\n\t\t\t\t\t\t\tvec4 tvDifBase = texture2D( tDiffuseBase, uvTiledBase );\n\t\t\t\t\t\t\tvec4 texelColor = vec4( tvDifBase.r, tvDifBase.g, tvDifBase.b, 1.0 );\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tvec4 texelColor = vec4( 1.0,  1.0,  1.0, 1.0 );\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#ifdef TERRAIN_TEX_DIFF1\n\t\t\t\t\t\t\tvec2 uvTiled1 = repeatOverlay1 * vUv;\n\t\t\t\t\t\t\tvec4 tvDif1 = texture2D( tDiffuse1, uvTiled1 );\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#ifdef TERRAIN_TEX_DIFF2\n\t\t\t\t\t\t\tvec2 uvTiled2 = repeatOverlay2 * vUv;\n\t\t\t\t\t\t\tvec4 tvDif2 = texture2D( tDiffuse2, uvTiled2 );\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#ifdef TERRAIN_TEX_DIFF3\n\t\t\t\t\t\t\tvec2 uvTiled3 = repeatOverlay3 * vUv;\n\t\t\t\t\t\t\tvec4 tvDif3 = texture2D( tDiffuse3, uvTiled3 );\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t#ifdef TERRAIN_TEX_DIFF4\n\t\t\t\t\t\t\tvec2 uvTiled4 = repeatOverlay4 * vUv;\n\t\t\t\t\t\t\tvec4 tvDif4 = texture2D( tDiffuse4, uvTiled4 );\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// Blend the 4 textures base\n\t\t\t\t\t\t#ifdef TERRAIN_TEX_SPLAT\n\t\t\t\t\t\t\tvec4 tvSplat = texture2D( tSplat, vUv );\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tvec4 tvSplat = vec4( 0.0, 0.0, 0.0, 0.0 );\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifdef TERRAIN_TEX_DIFF1\n\t\t\t\t\t\t\ttexelColor = mix( texelColor, tvDif1, tvSplat.x );\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifdef TERRAIN_TEX_DIFF2\n\t\t\t\t\t\t\ttexelColor = mix( texelColor, tvDif2, tvSplat.y );\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifdef TERRAIN_TEX_DIFF3\n\t\t\t\t\t\t\ttexelColor = mix( texelColor, tvDif3, tvSplat.z );\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#ifdef TERRAIN_TEX_DIFF4\n\t\t\t\t\t\t\ttexelColor = mix( texelColor, tvDif4, tvSplat.w );\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\tgl_FragColor = texelColor;\n\t\t\t\t\t#endif\n\n\t\t\t\t\t#ifdef PASS_GBUFFER2\n\n\t\t\t\t\t\tvec3 normal = normalize( normalView );\n\n\t\t\t\t\t\t// Get the depth from 0 to 1\n\t\t\t\t\t\tfloat normalizedDepth = vDepth;\n\n\t\t\t\t\t\t#ifdef USE_BUMPMAP\n\t\t\t\t\t\t\tvec3 detailNormal = perturbNormalArb(-vViewPosition, normal, dHdxy_fwd(uvCoordinates, tDiffuseMaps, bumpScale));\n\t\t\t\t\t\t\tif ( normalizedDepth < bumpDistance )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfloat bumpLerp = normalizedDepth / bumpDistance;\n\t\t\t\t\t\t\t\tnormal = mix( detailNormal, normal, bumpLerp );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( normalizedDepth > rockDistance )\n\t\t\t\t\t\t\t\tnormal =  mix( perturbNormalArb( -vViewPosition, normal, dHdxy_fwd( repeatOverlayRock * vUv, bumpMap, rockScale ) ), normal, (1.0 - normalizedDepth) / ( 1.0 - rockDistance ) );\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t// Normal in XYZ\n\t\t\t\t\t\tgl_FragColor.x = vec3_to_float( normal * 0.5 + 0.5 );\n\n\t\t\t\t\t\t// Translucency in Y\n\t\t\t\t\t\t" + Trike.ShaderFragments.FragMain.packTranslucency() + "\n\n\t\t\t\t\t\t// Depth in Z\n\t\t\t\t\t\tgl_FragColor.z = normalizedDepth;\n\n\t\t\t\t\t\t// FREE, Opacity, shininess\n\t\t\t\t\t\tgl_FragColor.w = vec3_to_float( vec3( 0.0, opacity, shininess ) );\n\n\t\t\t\t\t#endif\n\n\t\t\t\t\t" + Trike.ShaderFragments.Passes.fragShadowMain() + "\n\t\t\t\t}\n\t\t\t";
        };
        /*
        * Checks the uniforms or attributes of the material after a potentially breaking change
        */
        MaterialTerrain.prototype._validate = function () {
            if (this.materials[Trike.PassType.GBuffer]._uniforms['modelMatrix'])
                this.materials[Trike.PassType.GBuffer].removeUniform('modelMatrix', false);
        };
        MaterialTerrain.prototype.setTextureUniform = function (texUniform, tileUniform, val, tile, define, textureType, passType) {
            var material = this.materials[passType];
            var curTexture = material._uniforms[texUniform];
            if (curTexture && val)
                material.setUniform(texUniform, val, true);
            else if (!curTexture && val) {
                material.addUniform(new Trike.UniformVar(texUniform, Trike.UniformType.TEXTURE, val));
                if (tileUniform)
                    material.addUniform(new Trike.UniformVar(tileUniform, Trike.UniformType.FLOAT2, tile));
                if (define)
                    material.addDefine(define);
                if (passType === Trike.PassType.TerrainAlbedo && this._numDiffuseTextures === 0) {
                    this._albedoPass.enabled = true;
                    this.materials[Trike.PassType.GBuffer].addDefine('#define DIFFUSE_MAPS');
                    this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('tDiffuseMaps', Trike.UniformType.TEXTURE, this._albedoPass.renderTarget));
                    this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 0));
                    this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 0));
                    if (this._bumpMapping) {
                        this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('tDiffuseMaps', Trike.UniformType.TEXTURE, this._albedoPass.renderTarget));
                        this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 0));
                        this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 0));
                    }
                }
                if (passType === Trike.PassType.TerrainAlbedo)
                    this._numDiffuseTextures++;
            }
            else {
                material.removeUniform(texUniform);
                if (tileUniform)
                    material.removeUniform(tileUniform);
                if (define)
                    material.removeDefine(define);
                if (curTexture && passType === Trike.PassType.TerrainAlbedo)
                    this._numDiffuseTextures--;
                if (passType === Trike.PassType.TerrainAlbedo && this._numDiffuseTextures === 0) {
                    this._albedoPass.enabled = false;
                    this.materials[Trike.PassType.GBuffer].removeDefine('#define DIFFUSE_MAPS');
                    this.materials[Trike.PassType.GBuffer].removeUniform('tDiffuseMaps');
                    this.materials[Trike.PassType.GBuffer].removeUniform('viewWidth');
                    this.materials[Trike.PassType.GBuffer].removeUniform('viewHeight');
                    if (this._bumpMapping) {
                        this.materials[Trike.PassType.GBuffer2].removeUniform('tDiffuseMaps');
                        this.materials[Trike.PassType.GBuffer2].removeUniform('viewWidth');
                        this.materials[Trike.PassType.GBuffer2].removeUniform('viewHeight');
                    }
                }
            }
            this._textureEvent.type = textureType;
            this.emit('texture_changed', this._textureEvent);
        };
        /**
        * Gets or sets the base diffuse texture
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialTerrain.prototype.textureBase = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.TerrainAlbedo]._uniforms['tDiffuseBase'].value;
            this.setTextureUniform('tDiffuseBase', 'repeatOverlayBase', val, this._tileScaleBase, Trike.ShaderDefines.TERRAIN_TEX_BASE, Trike.TerrainTextureType.Base, Trike.PassType.TerrainAlbedo);
            return val;
        };
        /**
        * Gets or sets the base diffuse texture 1
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialTerrain.prototype.textureDiffuse1 = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.TerrainAlbedo]._uniforms['tDiffuse1'].value;
            this.setTextureUniform('tDiffuse1', 'repeatOverlay1', val, this._tileScaleDiff1, Trike.ShaderDefines.TERRAIN_TEX_DIFF1, Trike.TerrainTextureType.Diffuse1, Trike.PassType.TerrainAlbedo);
            return val;
        };
        /**
        * Gets or sets the base diffuse texture 2
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialTerrain.prototype.textureDiffuse2 = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.TerrainAlbedo]._uniforms['tDiffuse2'].value;
            this.setTextureUniform('tDiffuse2', 'repeatOverlay2', val, this._tileScaleDiff2, Trike.ShaderDefines.TERRAIN_TEX_DIFF2, Trike.TerrainTextureType.Diffuse2, Trike.PassType.TerrainAlbedo);
            return val;
        };
        /**
        * Gets or sets the base diffuse texture 3
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialTerrain.prototype.textureDiffuse3 = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.TerrainAlbedo]._uniforms['tDiffuse3'].value;
            this.setTextureUniform('tDiffuse3', 'repeatOverlay3', val, this._tileScaleDiff3, Trike.ShaderDefines.TERRAIN_TEX_DIFF3, Trike.TerrainTextureType.Diffuse3, Trike.PassType.TerrainAlbedo);
            return val;
        };
        /**
        * Gets or sets the base diffuse texture 4
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialTerrain.prototype.textureDiffuse4 = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.TerrainAlbedo]._uniforms['tDiffuse4'].value;
            this.setTextureUniform('tDiffuse4', 'repeatOverlay4', val, this._tileScaleDiff4, Trike.ShaderDefines.TERRAIN_TEX_DIFF4, Trike.TerrainTextureType.Diffuse4, Trike.PassType.TerrainAlbedo);
            return val;
        };
        /**
        * Gets or sets the base splat texture
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialTerrain.prototype.textureSplat = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.TerrainAlbedo]._uniforms['tSplat'].value;
            this.setTextureUniform('tSplat', null, val, null, Trike.ShaderDefines.TERRAIN_TEX_SPLAT, Trike.TerrainTextureType.Splat, Trike.PassType.TerrainAlbedo);
            return val;
        };
        /**
        * Gets or sets the specular texture
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialTerrain.prototype.textureSpecular = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['specularMap'].value;
            this.setTextureUniform('specularMap', null, val, null, Trike.ShaderDefines.SPECULAR_MAP, Trike.TerrainTextureType.Specular, Trike.PassType.GBuffer);
            return val;
        };
        /**
        * Gets or sets the lightmap texture
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialTerrain.prototype.textureLightmap = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['tLightmap'].value;
            this.setTextureUniform('tLightmap', null, val, null, Trike.ShaderDefines.TERRAIN_TEX_LIGHTMAP, Trike.TerrainTextureType.Lightmap, Trike.PassType.GBuffer);
            return val;
        };
        /**
        * Gets or sets the color map texture
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialTerrain.prototype.textureColors = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['tColourMap'].value;
            this.setTextureUniform('tColourMap', null, val, null, Trike.ShaderDefines.TERRAIN_TEX_COLORS, Trike.TerrainTextureType.Colors, Trike.PassType.GBuffer);
            return val;
        };
        /**
        * Gets or sets the distant rock texture
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialTerrain.prototype.textureRockmap = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.TerrainAlbedo]._uniforms['bumpMap'].value;
            this._bumpMap = val;
            this.setTextureUniform('bumpMap', 'repeatOverlayRock', val, this._tileScaleRock, null, Trike.TerrainTextureType.Rocks, Trike.PassType.GBuffer2);
            return val;
        };
        /**
        * Gets or sets a heightmap texture
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialTerrain.prototype.heightmap = function (val) {
            if (val === undefined)
                return this._uniforms['heightfield'].value;
            var material = this;
            var curTexture = this._uniforms['heightfield'];
            this._heightfield = val;
            material.removeDefine('#define HEIGHTFIELD_SIZE_X ' + this._prevWidth.toFixed(1));
            material.removeDefine('#define HEIGHTFIELD_SIZE_Y ' + this._prevHeight.toFixed(1));
            // If we have a texture already - then just update the uniform
            if (curTexture && val) {
                this._prevWidth = val.width;
                this._prevHeight = val.height;
                material.addDefine('#define HEIGHTFIELD_SIZE_X ' + this._prevWidth.toFixed(1));
                material.addDefine('#define HEIGHTFIELD_SIZE_Y ' + this._prevHeight.toFixed(1));
                material.setUniform('heightfield', val, true);
                this.emit('texture_changed', this._textureEvent);
                return;
            }
            else if (!curTexture && val) {
                this._prevWidth = val.width;
                this._prevHeight = val.height;
                material.addDefine('#define HEIGHTFIELD_SIZE_X ' + this._prevWidth.toFixed(1));
                material.addDefine('#define HEIGHTFIELD_SIZE_Y ' + this._prevHeight.toFixed(1));
                material.addUniform(new Trike.UniformVar('heightfield', Trike.UniformType.TEXTURE, val));
                material.addUniform(new Trike.UniformVar('altitude', Trike.UniformType.FLOAT, this._altitude));
                material.addUniform(new Trike.UniformVar('heightOffset', Trike.UniformType.FLOAT, this._heightOffset));
                material.addDefine(Trike.ShaderDefines.USE_HEIGHTFIELD);
            }
            else {
                this.removeDefine('#define HEIGHTFIELD_SIZE_X ' + this._prevWidth.toFixed(1));
                this.removeDefine('#define HEIGHTFIELD_SIZE_Y ' + this._prevHeight.toFixed(1));
                material.removeUniform('heightfield');
                material.removeUniform('altitude');
                material.removeUniform('heightOffset');
                material.removeDefine(Trike.ShaderDefines.USE_HEIGHTFIELD);
            }
            this._textureEvent.type = Trike.TerrainTextureType.Heightmap;
            this.emit('texture_changed', this._textureEvent);
            return val;
        };
        /**
        * Gets or sets if the terrain adds height based colours to the final pixel contribution.
        * @param {boolean} val [Optional]
        * @returns {boolean}
        */
        MaterialTerrain.prototype.heightColors = function (val) {
            if (val === undefined)
                return this._heightBasedColors;
            if (this._heightBasedColors === val)
                return;
            var material = this.materials[Trike.PassType.GBuffer];
            this._heightBasedColors = val;
            if (val) {
                material.addUniform(new Trike.UniformVar('topColor', Trike.UniformType.COLOR3, this._topColor));
                material.addUniform(new Trike.UniformVar('bottomColor', Trike.UniformType.COLOR3, this._bottomColor));
                material.addUniform(new Trike.UniformVar('midColor', Trike.UniformType.COLOR3, this._midColor));
                material.addUniform(new Trike.UniformVar('heightColorsMinAltitude', Trike.UniformType.FLOAT, this._heightColorsMinAltitude));
                material.addUniform(new Trike.UniformVar('heightColorsMidAltitude', Trike.UniformType.FLOAT, this._heightColorsMidAltitude));
                material.addUniform(new Trike.UniformVar('heightColorsMaxAltitude', Trike.UniformType.FLOAT, this._heightColorsMaxAltitude));
                material.addDefine('#define HEIGHT_COLORS');
            }
            else {
                material.removeUniform('topColor');
                material.removeUniform('bottomColor');
                material.removeUniform('midColor');
                material.removeUniform('heightColorsMaxAltitude');
                material.removeUniform('heightColorsMidAltitude');
                material.removeUniform('heightColorsMinAltitude');
                material.removeDefine('#define HEIGHT_COLORS');
            }
            return val;
        };
        /**
        * Gets or sets the top color multiplier. This affects the highest altitude only if heightColors is true.
        * Tweak this with heightColorsMin, heightColorsMid and heightColorsMaxAltitude variables.
        * @param {Color} val [Optional]
        * @returns {Color}
        */
        MaterialTerrain.prototype.topColor = function (val) {
            if (val === undefined)
                return this._topColor;
            this._topColor = val;
            if (!this._heightBasedColors)
                return;
            var material = this.materials[Trike.PassType.GBuffer];
            material.setUniform('topColor', val, false);
            return val;
        };
        /**
        * Gets or sets the mid color multiplier. This affects the highest altitude only if heightColors is true.
        * Tweak this with heightColorsMin, heightColorsMid and heightColorsMaxAltitude variables.
        * @param {Color} val [Optional]
        * @returns {Color}
        */
        MaterialTerrain.prototype.midColor = function (val) {
            if (val === undefined)
                return this._midColor;
            this._midColor = val;
            if (!this._heightBasedColors)
                return;
            var material = this.materials[Trike.PassType.GBuffer];
            material.setUniform('midColor', val, false);
            return val;
        };
        /**
        * Gets or sets the bottom color multiplier. This affects the highest altitude only if heightColors is true.
        * Tweak this with heightColorsMin, heightColorsMid and heightColorsMaxAltitude variables.
        * @param {Color} val [Optional]
        * @returns {Color}
        */
        MaterialTerrain.prototype.bottomColor = function (val) {
            if (val === undefined)
                return this._bottomColor;
            this._bottomColor = val;
            if (!this._heightBasedColors)
                return;
            var material = this.materials[Trike.PassType.GBuffer];
            material.setUniform('bottomColor', val, false);
            return val;
        };
        /**
        * Gets or sets the lower altitude of the height colour multiplier.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialTerrain.prototype.heightColorsMinAltitude = function (val) {
            if (val === undefined)
                return this._heightColorsMinAltitude;
            this._heightColorsMinAltitude = val;
            if (!this._heightBasedColors)
                return;
            var material = this.materials[Trike.PassType.GBuffer];
            material.setUniform('heightColorsMinAltitude', val, false);
            return val;
        };
        /**
        * Gets or sets the mid altitude of the height colour multiplier.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialTerrain.prototype.heightColorsMidAltitude = function (val) {
            if (val === undefined)
                return this._heightColorsMidAltitude;
            this._heightColorsMidAltitude = val;
            if (!this._heightBasedColors)
                return;
            var material = this.materials[Trike.PassType.GBuffer];
            material.setUniform('heightColorsMidAltitude', val, false);
            return val;
        };
        /**
        * Gets or sets the max altitude of the height colour multiplier.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialTerrain.prototype.heightColorsMaxAltitude = function (val) {
            if (val === undefined)
                return this._heightColorsMaxAltitude;
            this._heightColorsMaxAltitude = val;
            if (!this._heightBasedColors)
                return;
            var material = this.materials[Trike.PassType.GBuffer];
            material.setUniform('heightColorsMaxAltitude', val, false);
            return val;
        };
        /**
        * Gets or sets how far we need to calculate bumpmapping on the terrain. The values are from 0 to 1.
        * @param {number} val
        * @returns {number}
        */
        MaterialTerrain.prototype.bumpDistance = function (val) {
            if (val === undefined)
                return this._bumpDistance;
            this._bumpDistance = val;
            if (!this._bumpMapping)
                return;
            // We set this on the normal depth as the color pass ignores it
            var normDepth = this.materials[Trike.PassType.GBuffer2];
            normDepth.setUniform('bumpDistance', val, true);
            return val;
        };
        /**
        * Gets or sets how far we need to calculate the rock map bumpmapping on the terrain.
        * The values are from 0 to 1, typically 0 means the rock map gets gradually bumpier to the distance right in front of the camera.
        * If the value is 0.5, then the rock bumps only start to appear half way from the camera view distance.
        * @param {number} val
        * @returns {number}
        */
        MaterialTerrain.prototype.rockDistance = function (val) {
            if (val === undefined)
                return this._rockDistance;
            this._rockDistance = val;
            if (!this._bumpMapping)
                return;
            // We set this on the normal depth as the color pass ignores it
            var normDepth = this.materials[Trike.PassType.GBuffer2];
            normDepth.setUniform('rockDistance', val, true);
            return val;
        };
        /**
        * Gets or sets if the bump mapping is turned on
        * @param {boolean} val
        * @returns {boolean}
        */
        MaterialTerrain.prototype.bumpMapping = function (val) {
            if (val === undefined)
                return this._bumpMapping;
            // We set this on the normal depth as the color pass ignores it
            var normDepth = this.materials[Trike.PassType.GBuffer2];
            this._bumpMapping = val;
            if (val) {
                normDepth.addUniform(new Trike.UniformVar('bumpMap', Trike.UniformType.TEXTURE, this._bumpMap));
                normDepth.addUniform(new Trike.UniformVar('bumpScale', Trike.UniformType.FLOAT, this._tileScale));
                normDepth.addUniform(new Trike.UniformVar('rockScale', Trike.UniformType.FLOAT, this._rockScale));
                normDepth.addUniform(new Trike.UniformVar('bumpDistance', Trike.UniformType.FLOAT, this._bumpDistance));
                normDepth.addUniform(new Trike.UniformVar('rockDistance', Trike.UniformType.FLOAT, this._rockDistance));
                normDepth.addUniform(new Trike.UniformVar('repeatOverlayRock', Trike.UniformType.FLOAT2, this._tileScaleRock));
                normDepth.addDefine(Trike.ShaderDefines.BUMP_MAP);
                if (this._numDiffuseTextures > 0) {
                    normDepth.addUniform(new Trike.UniformVar('tDiffuseMaps', Trike.UniformType.TEXTURE, this._albedoPass.renderTarget));
                    normDepth.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 0));
                    normDepth.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 0));
                }
            }
            else {
                normDepth.removeUniform('bumpMap');
                normDepth.removeUniform('bumpScale');
                normDepth.removeUniform('rockScale');
                normDepth.removeUniform('bumpDistance');
                normDepth.removeUniform('rockDistance');
                normDepth.removeUniform('repeatOverlayRock');
                normDepth.removeDefine(Trike.ShaderDefines.BUMP_MAP);
                if (this._numDiffuseTextures > 0) {
                    normDepth.removeUniform('tDiffuseMaps');
                    normDepth.removeUniform('viewWidth');
                    normDepth.removeUniform('viewHeight');
                }
            }
            return val;
        };
        /**
        * Gets or sets the bump scale of the texture tiles. Higher values mean the terrain textures are very bumpy. Typically between 0 and 1, but can be more or less.
        * @param {number} val
        * @returns {number}
        */
        MaterialTerrain.prototype.tileScale = function (val) {
            if (val === undefined)
                return this._tileScale;
            // We set this on the normal depth as the color pass ignores it
            var normDepth = this.materials[Trike.PassType.GBuffer2];
            this._tileScale = val;
            if (!this._bumpMapping)
                return;
            normDepth.setUniform('bumpScale', val, false);
            return val;
        };
        /**
        * Gets or sets the bump scale of the rock map. Higher values mean the terrain is very bumpy. Typically between 0 and 1, but can be more or less.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialTerrain.prototype.rockScale = function (val) {
            if (val === undefined)
                return this._rockScale;
            // We set this on the normal depth as the color pass ignores it
            var normDepth = this.materials[Trike.PassType.GBuffer2];
            this._rockScale = val;
            if (!this._bumpMapping)
                return;
            normDepth.setUniform('rockScale', val, false);
            return val;
        };
        /*
        * Gets or sets diffuse lighting color of the material
        * @param {Color} val [Optional]
        * @returns {Color}
        */
        MaterialTerrain.prototype.diffuse = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['diffuse'].value;
            this.materials[Trike.PassType.GBuffer].setUniform('diffuse', val, false);
            return val;
        };
        /*
        * Gets or sets specular light colour
        * @param {Color} val [Optional]
        * @returns {Color}
        */
        MaterialTerrain.prototype.specular = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['specular'].value;
            this.materials[Trike.PassType.GBuffer].setUniform('specular', val, false);
            return val;
        };
        /*
        * Gets or sets emissive light colour
        * @param {Color} val [Optional]
        * @returns {Color}
        */
        MaterialTerrain.prototype.emissive = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['emissive'].value;
            this.materials[Trike.PassType.GBuffer].setUniform('emissive', val, false);
            return val;
        };
        /*
        * Gets or sets the shininess of the specular component
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialTerrain.prototype.shininess = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer2]._uniforms['shininess'].value;
            this.materials[Trike.PassType.GBuffer2].setUniform('shininess', val, false);
            return val;
        };
        /**
        * Gets or sets the altitude multiplier
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialTerrain.prototype.altitude = function (val) {
            if (val === undefined)
                return this._altitude;
            this._altitude = val;
            if (this._heightfield)
                this.setUniform('altitude', val, true);
            return val;
        };
        /**
        * Gets or sets the height offset multiplier
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialTerrain.prototype.heightOffset = function (val) {
            if (val === undefined)
                return this._heightOffset;
            this._heightOffset = val;
            if (this._heightfield)
                this.setUniform('heightOffset', val, true);
            return val;
        };
        /**
        * Gets or sets how wide and deep the heightfield texture must be sampled. Higher values mean more vast terrain.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialTerrain.prototype.worldScale = function (val) {
            if (val === undefined)
                return this._worldScale;
            this._worldScale = val;
            if (this._worldScale)
                this.setUniform('worldScale', val, true);
            return val;
        };
        /**
        * Gets or sets the resolution of the tiles. This must be the same as the terrain's resolution
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialTerrain.prototype.tileResolution = function (val) {
            if (val === undefined)
                return this._tileResolution;
            this.removeDefine('#define TILE_RESOLUTION ' + this._tileResolution.toFixed(1));
            this._tileResolution = val;
            this.addDefine('#define TILE_RESOLUTION ' + val.toFixed(1));
            return val;
        };
        /**
        * Gets or sets if the terrain brush mode is on. Brush mode will draw a circular brush on the terrain. This can be useful for editors
        * @returns {boolean} val
        * @returns {boolean} val
        */
        MaterialTerrain.prototype.brushMode = function (val) {
            if (val === undefined)
                return this._brushMode;
            if (this._brushMode === val)
                return;
            this._brushMode = val;
            if (val) {
                this.materials[Trike.PassType.EditorPass].addDefine(Trike.ShaderDefines.BRUSHMODE);
                this.materials[Trike.PassType.EditorPass].addUniform(new Trike.UniformVar('ring_border_width', Trike.UniformType.FLOAT, this._ring_border_width));
                this.materials[Trike.PassType.EditorPass].addUniform(new Trike.UniformVar('ring_color', Trike.UniformType.COLOR3, this._ring_color));
                this.materials[Trike.PassType.EditorPass].addUniform(new Trike.UniformVar('ring_center', Trike.UniformType.FLOAT3, this._ring_center));
                this.materials[Trike.PassType.EditorPass].addUniform(new Trike.UniformVar('ring_radius', Trike.UniformType.FLOAT, this._ring_radius));
                this.materials[Trike.PassType.EditorPass].addUniform(new Trike.UniformVar('ring_falloff', Trike.UniformType.FLOAT, this._ring_falloff));
            }
            else {
                this.materials[Trike.PassType.EditorPass].removeDefine(Trike.ShaderDefines.BRUSHMODE);
                this.materials[Trike.PassType.EditorPass].removeUniform('ring_border_width');
                this.materials[Trike.PassType.EditorPass].removeUniform('ring_color');
                this.materials[Trike.PassType.EditorPass].removeUniform('ring_center');
                this.materials[Trike.PassType.EditorPass].removeUniform('ring_radius');
                this.materials[Trike.PassType.EditorPass].removeUniform('ring_falloff');
            }
            return val;
        };
        /**
        * Gets or sets the width of the outer ring border
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialTerrain.prototype.ring_border_width = function (val) {
            if (val === undefined)
                return this._ring_border_width;
            this._ring_border_width = val;
            if (!this._brushMode)
                return;
            this.materials[Trike.PassType.EditorPass].setUniform('ring_border_width', val, false);
            return val;
        };
        /**
        * Gets or sets the ring color. Only valid if in brush mode.
        * @param {Color} val
        * @returns {Color} val
        */
        MaterialTerrain.prototype.ring_color = function (val) {
            if (val === undefined)
                return this._ring_color;
            this._ring_color = val;
            if (!this._brushMode)
                return;
            this.materials[Trike.PassType.EditorPass].setUniform('ring_color', val, false);
            return val;
        };
        /**
        * Gets or sets the ring center (world space). Only valid if in brush mode. Only visible if brush mode is true.
        * @param {Vec3} val
        * @returns {Vec3}
        */
        MaterialTerrain.prototype.ring_center = function (val) {
            if (val === undefined)
                return this._ring_center;
            this._ring_center = val;
            if (!this._brushMode)
                return;
            this.materials[Trike.PassType.EditorPass].setUniform('ring_center', val, false);
            return val;
        };
        /**
        * Gets or sets the ring outer radius. Only valid if in brush mode. Only visible if brush mode is true.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialTerrain.prototype.ring_radius = function (val) {
            if (val === undefined)
                return this._ring_radius;
            this._ring_radius = val;
            if (!this._brushMode)
                return;
            this.materials[Trike.PassType.EditorPass].setUniform('ring_radius', val, false);
            return val;
        };
        /**
        * Gets or sets the ring falloff value. A value of 1 means the falloff is the same size as the ring_radius.
        * Only visible if brush mode is true.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialTerrain.prototype.ring_falloff = function (val) {
            if (val === undefined)
                return this._ring_falloff;
            this._ring_falloff = val;
            if (!this._brushMode)
                return;
            this.materials[Trike.PassType.EditorPass].setUniform('ring_falloff', val, false);
            return val;
        };
        /**
        * Gets or sets the UV scale of the rock bump texture
        * @param {Vec2} [Optional]
        * @returns {Vec2}
        */
        MaterialTerrain.prototype.tileScaleRock = function (val) {
            if (val === undefined)
                return this._tileScaleRock;
            this._tileScaleRock = val;
            var material = this.materials[Trike.PassType.GBuffer2];
            if (material._uniforms['repeatOverlayRock'])
                material.setUniform('repeatOverlayRock', val, true);
            return val;
        };
        /**
        * Gets or sets the UV scale of the base texture
        * @param {Vec2} [Optional]
        * @returns {Vec2}
        */
        MaterialTerrain.prototype.tileScaleBase = function (val) {
            if (val === undefined)
                return this._tileScaleBase;
            this._tileScaleBase = val;
            var material = this.materials[Trike.PassType.TerrainAlbedo];
            if (material._uniforms['repeatOverlayBase'])
                material.setUniform('repeatOverlayBase', val, true);
            return val;
        };
        /**
        * Gets or sets the UV scale of the first texture
        * @param {Vec2} [Optional]
        * @returns {Vec2}
        */
        MaterialTerrain.prototype.tileScaleDiff1 = function (val) {
            if (val === undefined)
                return this._tileScaleDiff1;
            this._tileScaleDiff1 = val;
            var material = this.materials[Trike.PassType.TerrainAlbedo];
            if (material._uniforms['repeatOverlay1'])
                material.setUniform('repeatOverlay1', val, true);
            return val;
        };
        /**
        * Gets or sets the UV scale of the second texture
        * @param {Vec2} [Optional]
        * @returns {Vec2}
        */
        MaterialTerrain.prototype.tileScaleDiff2 = function (val) {
            if (val === undefined)
                return this._tileScaleDiff2;
            this._tileScaleDiff2 = val;
            var material = this.materials[Trike.PassType.TerrainAlbedo];
            if (material._uniforms['repeatOverlay2'])
                material.setUniform('repeatOverlay2', val, true);
            return val;
        };
        /**
        * Gets or sets the UV scale of the third texture
        * @param {Vec2} [Optional]
        * @returns {Vec2}
        */
        MaterialTerrain.prototype.tileScaleDiff3 = function (val) {
            if (val === undefined)
                return this._tileScaleDiff3;
            this._tileScaleDiff3 = val;
            var material = this.materials[Trike.PassType.TerrainAlbedo];
            if (material._uniforms['repeatOverlay3'])
                material.setUniform('repeatOverlay3', val, true);
            return val;
        };
        /**
        * Gets or sets the UV scale of the fourth texture
        * @param {Vec2} [Optional]
        * @returns {Vec2}
        */
        MaterialTerrain.prototype.tileScaleDiff4 = function (val) {
            if (val === undefined)
                return this._tileScaleDiff4;
            this._tileScaleDiff4 = val;
            var material = this.materials[Trike.PassType.TerrainAlbedo];
            if (material._uniforms['repeatOverlay4'])
                material.setUniform('repeatOverlay4', val, true);
            return val;
        };
        /*
        * Gets or sets the opacity of this material. The values are from 0 to 1.
        * @param {number} val
        */
        MaterialTerrain.prototype.opacity = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer2]._uniforms['opacity'].value;
            this.materials[Trike.PassType.GBuffer2].setUniform('opacity', val, false);
            return val;
        };
        /*
        * Gets or sets if translucency is enabled
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialTerrain.prototype.translucencyEnabled = function (val) {
            if (val === undefined)
                return this._translucencyEnabled;
            if (this._translucencyEnabled === val)
                return;
            if (val) {
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('translucencyScale', Trike.UniformType.FLOAT, this._translucencyScale), false);
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('translucencyDistortion', Trike.UniformType.FLOAT, this._translucencyDistortion), false);
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('translucencyPower', Trike.UniformType.FLOAT, this._translucencyPower), false);
                this.materials[Trike.PassType.GBuffer2].addDefine(Trike.ShaderDefines.TRANSLUCENCY_ENABLED);
            }
            else {
                this.materials[Trike.PassType.GBuffer2].removeUniform('translucencyScale', false);
                this.materials[Trike.PassType.GBuffer2].removeUniform('translucencyDistortion', false);
                this.materials[Trike.PassType.GBuffer2].removeUniform('translucencyPower', false);
                this.materials[Trike.PassType.GBuffer2].removeDefine(Trike.ShaderDefines.TRANSLUCENCY_ENABLED);
            }
            this._translucencyEnabled = val;
        };
        /*
        * Gets or sets the translucency scale of the material. This is a uniform multiplier of the effect.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialTerrain.prototype.translucencyScale = function (val) {
            if (val === undefined)
                return this._translucencyScale;
            this._translucencyScale = val;
            if (this._translucencyEnabled)
                this.materials[Trike.PassType.GBuffer2].setUniform('translucencyScale', val, false);
        };
        /*
        * Gets or sets the translucency distortion of the material.
        * Modifies the light angle as it enters the material
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialTerrain.prototype.translucencyDistortion = function (val) {
            if (val === undefined)
                return this._translucencyDistortion;
            this._translucencyDistortion = val;
            if (this._translucencyEnabled)
                this.materials[Trike.PassType.GBuffer2].setUniform('translucencyDistortion', val, false);
        };
        /*
        * Gets or sets the translucency power of the material.
        * Increasing this has the effect of narrowing the area of the effect
        * @param {number} val [Optional]
        */
        MaterialTerrain.prototype.translucencyPower = function (val) {
            if (val === undefined)
                return this._translucencyPower;
            this._translucencyPower = val;
            if (this._translucencyEnabled)
                this.materials[Trike.PassType.GBuffer2].setUniform('translucencyPower', val, false);
        };
        return MaterialTerrain;
    }(Trike.MaterialMulti));
    Trike.MaterialTerrain = MaterialTerrain;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    *
    */
    var MaterialOcean = (function (_super) {
        __extends(MaterialOcean, _super);
        /**
        * Creates an instance of the terrain material
        * @param {number} tileResolution The resolution of the planes used in the terrain
        * @param {number} altitude Specified how high/low the terrain will go. Default is 200.
        * @param {number} worldScale Defines how wide and deep the heightfield texture must be sampled. Higher values mean more vast terrain. Default is 1024.
        */
        function MaterialOcean(tileResolution, altitude, worldScale, editorMode) {
            if (altitude === void 0) { altitude = 200; }
            if (worldScale === void 0) { worldScale = 1024; }
            if (editorMode === void 0) { editorMode = true; }
            // Call the material base
            _super.call(this);
            if (editorMode)
                this.materials[Trike.PassType.EditorPass] = new Trike.PassMaterial('EditorPass', this);
            this._mirrorReflection = false;
            this._reflectionMap = null;
            this._mirrorDistortion = 10;
            this._alphaTest = 0;
            this._tileScale = 1;
            this._altitude = altitude;
            this._heightOffset = 0;
            this._prevWidth = 0;
            this._prevHeight = 0;
            this._worldScale = worldScale;
            this._bumpMapping = false;
            // Height based colours
            this._topColor = new Trike.Color(0xFFFFFF);
            this._bottomColor = new Trike.Color(0x4F483B);
            this._bumpDistance = 0.03;
            this._translucencyEnabled = false;
            this._translucencyScale = 1;
            this._translucencyDistortion = 0.185;
            this._translucencyPower = 0.04;
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('modelViewMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('projectionMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('worldScale', Trike.UniformType.FLOAT, worldScale), true);
            this.addUniform(new Trike.UniformVar('uTileOffset', Trike.UniformType.FLOAT2, new Trike.Vec2()), true);
            this.addUniform(new Trike.UniformVar('camPosition', Trike.UniformType.FLOAT3, new Trike.Vec3()), true);
            this.addUniform(new Trike.UniformVar('uTileOffset', Trike.UniformType.FLOAT2, new Trike.Vec2()), true);
            this.addUniform(new Trike.UniformVar('uScale', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('uEdgeMorph', Trike.UniformType.INT, 0), true);
            this.addUniform(new Trike.UniformVar('customClipping', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('customClipPlane', Trike.UniformType.FLOAT4), true);
            // GBufffer only
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('diffuse', Trike.UniformType.COLOR3, new Trike.Color(0x96762C)));
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('specular', Trike.UniformType.COLOR3, new Trike.Color(0xffffff)));
            this.materials[Trike.PassType.GBuffer].addUniform(new Trike.UniformVar('emissive', Trike.UniformType.COLOR3, new Trike.Color(0x000000)));
            // Add the camera far uniform to the normal depth material
            this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('cameraFar', Trike.UniformType.FLOAT, 1000));
            this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('shininess', Trike.UniformType.FLOAT, 0.05));
            this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('opacity', Trike.UniformType.FLOAT, 1));
            this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('topColor', Trike.UniformType.COLOR3, this._topColor));
            this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('bottomColor', Trike.UniformType.COLOR3, this._bottomColor));
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            this.addAttribute(new Trike.AttributeVar('normal', Trike.AttributeType.NORMAL));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.addDefine(Trike.ShaderDefines.ATTR_NORMAL);
            this.addDefine(Trike.ShaderDefines.STANDARD_DERIVATIVES);
            this._tileResolution = tileResolution;
            this.tileResolution(tileResolution);
            this.addDefine('#define EGDE_MORPH_TOP 1');
            this.addDefine('#define EGDE_MORPH_LEFT 2');
            this.addDefine('#define EGDE_MORPH_BOTTOM 4');
            this.addDefine('#define EGDE_MORPH_RIGHT 8');
            this.addDefine('#define MORPH_REGION 0.3');
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.heightmap = null;
            this.transparent = true;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialOcean.prototype.getVertexShader = function () {
            return [
                Trike.ShaderFragments.VertParams.defaults(),
                Trike.ShaderFragments.VertParams.clippingParameters(),
                '#ifdef USE_HEIGHTFIELD',
                '    uniform sampler2D heightfield;',
                '#endif',
                // Used when sampling the heightfield. Higher values mean vaster terrain
                'uniform float worldScale;',
                // Used to amplify the height
                'uniform float altitude;',
                // Used to offset the terrain vertically
                'uniform float heightOffset;',
                // Used for the tile positioning
                'uniform vec3 camPosition;',
                'uniform vec2 tileScale;',
                'uniform vec2 uTileOffset;',
                'uniform float uScale;',
                'uniform int uEdgeMorph;',
                'varying vec2 vUv;',
                'varying float vHeight;',
                '#ifdef USE_HEIGHTFIELD \n',
                // catmull works by specifying 4 control points p0, p1, p2, p3 and a weight. The function is used to calculate a point n between p1 and p2 based
                // on the weight. The weight is normalized, so if it's a value of 0 then the return value will be p1 and if its 1 it will return p2.
                '	float catmullRom( float p0, float p1, float p2, float p3, float weight ) {',
                '		float weight2 = weight * weight;',
                '		return 0.5 * (',
                '			p0 * weight * ( ( 2.0 - weight ) * weight - 1.0 ) +',
                '			p1 * ( weight2 * ( 3.0 * weight - 5.0 ) + 2.0 ) +',
                '			p2 * weight * ( ( 4.0 - 3.0 * weight ) * weight + 1.0 ) +',
                '			p3 * ( weight - 1.0 ) * weight2 );',
                '	}',
                // Performs a horizontal catmulrom operation at a given V value.
                '	float textureCubicU( sampler2D samp, vec2 uv00, float texel, float offsetV, float frac ) {',
                '		return catmullRom(',
                '			texture2DLod( samp, uv00 + vec2( -texel, offsetV ), 0.0 ).r,',
                '			texture2DLod( samp, uv00 + vec2( 0.0, offsetV ), 0.0 ).r,',
                '			texture2DLod( samp, uv00 + vec2( texel, offsetV ), 0.0 ).r,',
                '			texture2DLod( samp, uv00 + vec2( texel * 2.0, offsetV ), 0.0 ).r,',
                '		frac );',
                '	}',
                // Samples a texture using a bicubic sampling algorithm. This essentially queries neighbouring
                // pixels to get an average value.
                '	float textureBicubic( sampler2D samp, vec2 uv00, vec2 texel, vec2 frac ) {',
                '		return catmullRom(',
                '			textureCubicU( samp, uv00, texel.x, -texel.y, frac.x ),',
                '			textureCubicU( samp, uv00, texel.x, 0.0, frac.x ),',
                '			textureCubicU( samp, uv00, texel.x, texel.y, frac.x ),',
                '			textureCubicU( samp, uv00, texel.x, texel.y * 2.0, frac.x ),',
                '		frac.y );',
                '	}\n',
                '#endif',
                // Gets the  UV coordinates based on the world X Z position
                'vec2 worldToMapSpace( vec2 worldPosition ) {',
                '	return ( worldPosition / worldScale + 0.5 );',
                '}',
                // Gets the height at a location p (world space)
                'float getHeight( vec3 worldPosition )',
                '{',
                '	#ifdef USE_HEIGHTFIELD',
                '		vec2 heightUv = worldToMapSpace(worldPosition.xz);',
                '		vec2 tHeightSize = vec2( HEIGHTFIELD_SIZE_X, HEIGHTFIELD_SIZE_Y );',
                // If we increase the smoothness factor, the terrain becomes a lot smoother.
                // This is because it has the effect of shrinking the texture size and increaing
                // the texel size. Which means when we do sampling the samples are from farther away - making
                // it smoother. However this means the terrain looks less like the original heightmap and so
                // terrain picking goes a bit off.
                '		float smoothness = 1.1;',
                '		tHeightSize /= smoothness;',
                // The size of each texel
                '		vec2 texel = vec2( 1.0 / tHeightSize );',
                // Find the top-left texel we need to sample.
                '		vec2 heightUv00 = ( floor( heightUv * tHeightSize ) ) / tHeightSize;',
                // Determine the fraction across the 4-texel quad we need to compute.
                '		vec2 frac = vec2( heightUv - heightUv00 ) * tHeightSize;',
                '		float coarseHeight = textureBicubic( heightfield, heightUv00, texel, frac );',
                '		return altitude * coarseHeight + heightOffset;',
                '	#else',
                '		return 0.0;',
                '	#endif',
                '}',
                // Gets the normal at a location p
                'vec3 getNormal( vec3 pos, float morphFactor ) ',
                '{',
                // Get 2 vectors perpendicular to the unperturbed normal, and create at point at each (relative to position)
                '	float delta = ( morphFactor + 1.0 ) * uScale / TILE_RESOLUTION;',
                '	vec3 dA = delta * normalize( cross( normal.yzx, normal ));',
                '	vec3 dB = delta * normalize( cross( normal, dA ));',
                '	vec3 p = pos;',
                '	vec3 pA = pos + dA;',
                '	vec3 pB = pos + dB;',
                // Now get the height at those points
                '	float h = getHeight(pos);',
                '	float hA = getHeight(pA);',
                '	float hB = getHeight(pB);',
                // Update the points with their correct heights and calculate true normal
                '	p += normal * h;',
                '	pA += normal * hA;',
                '	pB += normal * hB;',
                '	return normalize( cross( pA - p, pB - p ) );',
                '}',
                // This essentially checks to see which morph edge this tile represents. Because
                // its a bitwise operation you can check for multipe enums. I.e. if a tile was tagged as EGDE_MORPH_LEFT | EGDE_MORPH_TOP, this
                // function will return true if its checked against EGDE_MORPH_LEFT or EGDE_MORPH_TOP, but nothing else.
                'bool edgePresent( int edge )',
                '{',
                '	int e = uEdgeMorph / edge;',
                '	return 2 * ( e / 2 ) !== e;',
                '}',
                // At the edges of tiles, morph the vertices if they are joining onto a higher layer.
                // The closer a vertex is to the edge, the higher the value returned will be. If the tile has an uEdgeMorph
                // of EGDE_MORPH_LEFT, and its x value is 0 then then the value returned will be 1. If the
                // value of x was === MORPH_REGION (which is the max distance from the edge before morphing) then it would be 0.
                // This function tells you how much the vertex needs to morph. Vertices away from the edge will return 0, but those
                // closer to edges will be higher.
                'float calculateMorph( vec3 p ) ',
                '{',
                '	float morphFactor = 0.0;',
                '	if ( edgePresent( EGDE_MORPH_TOP ) && p.z >= 1.0 - MORPH_REGION )',
                '	{',
                '		float m = 1.0 - clamp( ( 1.0 - p.z ) / MORPH_REGION, 0.0, 1.0 );',
                '		morphFactor = max( m, morphFactor );',
                '	}',
                '	if ( edgePresent( EGDE_MORPH_LEFT ) && p.x <= MORPH_REGION )',
                '	{',
                '		float m = 1.0 - clamp( p.x / MORPH_REGION, 0.0, 1.0 );',
                '		morphFactor = max( m, morphFactor );',
                '	}',
                '	if ( edgePresent( EGDE_MORPH_BOTTOM ) && p.z <= MORPH_REGION )',
                '	{',
                '		float m = 1.0 - clamp( p.z / MORPH_REGION, 0.0, 1.0 );',
                '		morphFactor = max( m, morphFactor );',
                '	}',
                '	if ( edgePresent( EGDE_MORPH_RIGHT ) && p.x >= 1.0 - MORPH_REGION )',
                '	{',
                '		float m = 1.0 - clamp( ( 1.0 - p.x ) / MORPH_REGION, 0.0, 1.0 );',
                '		morphFactor = max( m, morphFactor );',
                '	}',
                '	return morphFactor;',
                '}',
                'void main()',
                '{',
                '	vec3 pos;',
                // Morph factor tells us how close we are to next level.
                // 0.0 is this level
                // 1.0 is next level
                '	float morphFactor = calculateMorph(position);',
                // Move into correct place by scaling the vert based on the scale and offset of the tile
                // Remember that the geometry for each tile is no larger than 1 unit wide and deep
                '	pos = uScale * position + vec3(uTileOffset.x, 0.0, uTileOffset.y) + vec3(camPosition.x, 0.0, camPosition.z);',
                // Snap to grid
                '	float grid = uScale / TILE_RESOLUTION;',
                '	pos = floor( pos / grid ) * grid;',
                // Morph between zoom layers
                '	if ( morphFactor > 0.0 )',
                '	{',
                // Get position that we would have if we were on higher level grid
                '		grid = 2.0 * grid;',
                '		vec3 position2 = floor( pos / grid ) * grid;',
                // Linearly interpolate the two, depending on morph factor
                '		pos = mix( pos, position2, morphFactor );',
                '	}',
                // Get height and calculate normal
                '	pos = pos + normal * getHeight( pos );',
                // For reflection clipping
                '	vEyePosition = modelViewMatrix * vec4( pos, 1.0 );',
                '	gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );',
                '	vUv = worldToMapSpace(pos.xz) * tileScale;',
                '	vHeight = pos.y;',
                // We need to add the pass data
                '	#ifdef PASS_GBUFFER2',
                '		normalView = normalMatrix * getNormal( pos, morphFactor );',
                '		vNormal = normal;',
                '		#ifdef USE_BUMPMAP',
                '			vec4 mvPosition;',
                '			mvPosition = modelViewMatrix * vec4( pos, 1.0 );',
                '			vViewPosition = -mvPosition.xyz;',
                '		#endif',
                '		clipPos = gl_Position;',
                '	#endif',
                '	#ifdef REFLECTION_MAP',
                '		mirrorCoord = textureMatrix * vec4( pos, 1.0 );',
                '	#endif',
                '}'
            ].join('\n');
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialOcean.prototype.getFragmentShader = function () {
            return [
                // Declarations
                Trike.ShaderFragments.FragParams.defaults(),
                Trike.ShaderFragments.FragParams.clippingParams(),
                Trike.ShaderFragments.FragParams.map(),
                Trike.ShaderFragments.FragParams.bumpmapUniforms(),
                Trike.ShaderFragments.FragParams.bumpmapFunctions(),
                Trike.ShaderFragments.FragParams.vecToFloat(),
                Trike.ShaderFragments.FragParams.encodeNormal(),
                '	#ifdef USE_BUMPMAP',
                '		uniform float bumpDistance;',
                '	#endif',
                '#ifdef PASS_GBUFFER',
                Trike.ShaderFragments.FragParams.environmentMapping(),
                '	uniform vec3 diffuse;',
                '	uniform vec3 specular;',
                '	uniform vec3 emissive;',
                '#endif',
                // Used when sampling the heightfield. Higher values mean vaster terrain
                'uniform float worldScale;',
                'varying vec2 vUv;',
                'varying float vHeight;',
                '#ifdef USE_HEIGHTFIELD ',
                '	#ifdef PASS_GBUFFER2',
                '		uniform sampler2D heightfield;',
                '	#endif',
                '#endif\n\n',
                'vec2 worldToMapSpace( vec2 worldPosition ) {',
                '	return ( worldPosition / worldScale + 0.5 );',
                '}',
                '#ifdef PASS_GBUFFER2',
                '	uniform vec3 topColor;',
                '	uniform vec3 bottomColor;',
                '	uniform float shininess;',
                '#endif',
                'void main()',
                '{',
                Trike.ShaderFragments.FragMain.clippingTest(),
                '	#ifdef PASS_GBUFFER \n',
                '		gl_FragColor = vec4( diffuse, 1.0 );',
                '		float specularStrength = 1.0;',
                //		diffuse color in x
                '		gl_FragColor.x = vec3_to_float( gl_FragColor.xyz );',
                //		specular color in y
                '		gl_FragColor.y = vec3_to_float( specular * specularStrength );',
                //		translucency stored in z
                Trike.ShaderFragments.FragMain.packTranslucency(),
                //		We store the emmsive in w
                '		gl_FragColor.w = vec3_to_float( emissive );',
                '	#endif',
                '	#ifdef PASS_GBUFFER2',
                '		vec4 texelColor = vec4( 1.0,  1.0,  1.0, 1.0 );',
                '		gl_FragColor = vec4( texelColor );',
                '		' + Trike.ShaderFragments.FragMain.alphaTest(),
                '		vec3 normal = normalize( normalView );',
                //		Colors
                '		vec3 heightColors = bottomColor;',
                '		heightColors = mix( heightColors, topColor, smoothstep( 0.0, 10.0, vHeight ) );',
                '		texelColor.rgb *= heightColors;',
                //		Get the depth from 0 to 1
                '		float normalizedDepth = clipPos.z / cameraFar;',
                '		#ifdef USE_BUMPMAP',
                '			if ( normalizedDepth < bumpDistance )',
                '			{ ',
                '				vec3 detailNormal = vec3(0.0, 1.0, 0.0);',
                '				#ifdef TERRAIN_TEX_BASE',
                '					detailNormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd( uvTiledBase, tDiffuseBase, tileScale ) ) * (4.0 - ( tvSplat.x + tvSplat.y + tvSplat.z + tvSplat.w ) );',
                '				#endif',
                '				detailNormal = normalize( detailNormal );',
                '				float bumpLerp = normalizedDepth / bumpDistance;',
                '				normal = mix( detailNormal, normal, bumpLerp );',
                '			} ',
                '			if ( normalizedDepth > rockDistance )',
                '				normal =  mix( perturbNormalArb( -vViewPosition, normal, dHdxy_fwd( repeatOverlayRock * vUv, bumpMap, rockScale ) ), normal, (1.0 - normalizedDepth) / ( 1.0 - rockDistance ) );',
                '		#endif',
                //		Normal in XYZ
                '		gl_FragColor.x = vec3_to_float( normal * 0.5 + 0.5 );',
                //		Map in Y
                '		gl_FragColor.y = vec3_to_float( texelColor.xyz );',
                //		Reflection map...
                '		#ifdef REFLECTION_MAP',
                '			vec3 worldToEye = cameraPosition - vEyePosition.xyz;',
                '			vec3 eyeDirection = normalize(worldToEye);',
                '			vec4 distortion = vec4( normal.x / mirrorDistortion, 0.0, normal.z / mirrorDistortion, 0.0 );',
                '			float theta1 = max(dot(eyeDirection, normal), 0.0);',
                '			float rf0 = 0.02;',
                '			float reflectance = rf0 + (1.0 - rf0) * pow((1.0 - theta1), 5.0);',
                '			vec3 mirrorSample = texture2DProj(reflectionSampler, mirrorCoord + distortion).xyz;',
                '			gl_FragColor.y = vec3_to_float( mix( texelColor.xyz, mirrorSample, reflectance ) );',
                '		#endif',
                //		Depth in Z
                '		gl_FragColor.z = normalizedDepth;',
                //		FREE, Opacity, shininess
                '		gl_FragColor.w = vec3_to_float( vec3( 0.0, opacity, shininess ) );',
                '	#endif',
                '}'
            ].join('\n');
        };
        /*
        * Gets or sets the texture map of this material
        * @param {Texture} val
        * @returns {Texture}
        */
        MaterialOcean.prototype.heightmap = function (val) {
            if (val === undefined)
                return this._heightfield;
            this.removeDefine('#define HEIGHTFIELD_SIZE_X ' + this._prevWidth.toFixed(1));
            this.removeDefine('#define HEIGHTFIELD_SIZE_Y ' + this._prevHeight.toFixed(1));
            if (this._heightfield && val) {
                this._heightfield = val;
                this.setUniform('heightfield', val, true);
                this._prevWidth = val.width;
                this._prevHeight = val.height;
                this.addDefine('#define HEIGHTFIELD_SIZE_X ' + this._prevWidth.toFixed(1));
                this.addDefine('#define HEIGHTFIELD_SIZE_Y ' + this._prevHeight.toFixed(1));
                return val;
            }
            if (!this._heightfield && val) {
                this._heightfield = val;
                this.addUniform(new Trike.UniformVar('heightfield', Trike.UniformType.TEXTURE, val));
                this.addDefine(Trike.ShaderDefines.USE_HEIGHTFIELD);
                this._prevWidth = val.width;
                this._prevHeight = val.height;
                this.addDefine('#define HEIGHTFIELD_SIZE_X ' + this._prevWidth.toFixed(1));
                this.addDefine('#define HEIGHTFIELD_SIZE_Y ' + this._prevHeight.toFixed(1));
                this.addUniform(new Trike.UniformVar('altitude', Trike.UniformType.FLOAT, this._altitude));
                this.addUniform(new Trike.UniformVar('heightOffset', Trike.UniformType.FLOAT, this._heightOffset));
            }
            else {
                this._heightfield = null;
                this.removeUniform('heightfield');
                this.removeUniform('altitude');
                this.removeUniform('heightOffset');
                this.removeDefine(Trike.ShaderDefines.USE_HEIGHTFIELD);
            }
            return val;
        };
        /*
        * Gets or sets the texture matrix of this material for reflective textures
        * @param {Matrix4}  val
        */
        MaterialOcean.prototype.textureMatrix = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['textureMatrix'].value;
            return this.materials[Trike.PassType.GBuffer].setUniform('textureMatrix', val, false).value;
        };
        /**
        * Adds or removes the properties for reflection
        * @param {boolean} val [Optional]
        * @returns {boolean}
        */
        MaterialOcean.prototype.mirrorReflection = function (val) {
            if (val === undefined)
                return this._mirrorReflection;
            var material = this.materials[Trike.PassType.GBuffer];
            if (val) {
                material.addUniform(new Trike.UniformVar('reflectionSampler', Trike.UniformType.TEXTURE));
                material.addUniform(new Trike.UniformVar('textureMatrix', Trike.UniformType.MAT4));
                material.addUniform(new Trike.UniformVar('mirrorDistortion', Trike.UniformType.FLOAT, this._mirrorDistortion));
                material.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 0));
                material.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 0));
                material.addUniform(new Trike.UniformVar('invProjectionMatrix', Trike.UniformType.MAT4));
                material.addDefine(Trike.ShaderDefines.REFLECTION_MAP);
            }
            else {
                material.removeUniform('reflectionSampler');
                material.removeUniform('viewWidth');
                material.removeUniform('viewHeight');
                material.removeUniform('textureMatrix');
                material.removeUniform('mirrorDistortion');
                material.removeUniform('invProjectionMatrix');
                material.removeDefine(Trike.ShaderDefines.REFLECTION_MAP);
            }
        };
        /**
        * Gets or sets the texture map of this material
        * @param {RenderTarget} val [Optional]
        * @returns {RenderTarget}
        */
        MaterialOcean.prototype.reflectionMap = function (val) {
            if (val === undefined)
                return this._reflectionMap;
            var material = this.materials[Trike.PassType.GBuffer];
            if (this._reflectionMap && val) {
                this._reflectionMap = val;
                material.setUniform('reflectionSampler', val, true);
            }
            else if (!this._reflectionMap && val) {
                this._reflectionMap = val;
                this.mirrorReflection(true);
            }
            else {
                this._reflectionMap = null;
                this.mirrorReflection(false);
            }
            return this._reflectionMap;
        };
        /*
        * Gets or sets the mirror distortion
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialOcean.prototype.mirrorDistortion = function (val) {
            if (val === undefined)
                return this._mirrorDistortion;
            this._mirrorDistortion = val;
            if (this._reflectionMap)
                this.materials[Trike.PassType.GBuffer].setUniform('mirrorDistortion', val, false);
            return this._mirrorDistortion;
        };
        Object.defineProperty(MaterialOcean.prototype, "topColor", {
            /**
            * Gets the top color multiplier. This affects the highest altitude only if heightColors is true.
            * Tweak this with heightColorsMin, heightColorsMid and heightColorsMaxAltitude variables.
            * @returns {Color} val
            */
            get: function () { return this._topColor; },
            /**
            * Sets the top color multiplier. This affects the highest altitude only if heightColors is true.
            * Tweak this with heightColorsMin, heightColorsMid and heightColorsMaxAltitude variables.
            * @param {Color} val
            */
            set: function (val) {
                this._topColor = val;
                var material = this.materials[Trike.PassType.GBuffer2];
                material.setUniform('topColor', val, false);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialOcean.prototype, "bottomColor", {
            /**
            * Gets the bottom color multiplier. This affects the highest altitude only if heightColors is true.
            * Tweak this with heightColorsMin, heightColorsMid and heightColorsMaxAltitude variables.
            * @returns {Color} val
            */
            get: function () { return this._bottomColor; },
            /**
            * Sets the bottom color multiplier. This affects the highest altitude only if heightColors is true.
            * Tweak this with heightColorsMin, heightColorsMid and heightColorsMaxAltitude variables.
            * @param {Color} val
            */
            set: function (val) {
                this._bottomColor = val;
                var material = this.materials[Trike.PassType.GBuffer2];
                material.setUniform('bottomColor', val, false);
            },
            enumerable: true,
            configurable: true
        });
        /**
        * Gets or sets the bump scale of the texture tiles. Higher values mean the terrain textures are very bumpy. Typically between 0 and 1, but can be more or less.
        * @param {number} val
        * @returns {number}
        */
        MaterialOcean.prototype.tileScale = function (val) {
            if (val === undefined)
                return this._tileScale;
            // We set this on the normal depth as the color pass ignores it
            var normDepth = this.materials[Trike.PassType.GBuffer2];
            this._tileScale = val;
            if (!this._bumpMapping)
                return;
            normDepth.setUniform('bumpScale', val, false);
            return val;
        };
        /*
        * Gets or sets diffuse lighting color of the material
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialOcean.prototype.diffuse = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['diffuse'].value;
            this.materials[Trike.PassType.GBuffer].setUniform('diffuse', val, false);
            return val;
        };
        /*
        * Gets or sets specular light colour
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialOcean.prototype.specular = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['specular'].value;
            this.materials[Trike.PassType.GBuffer].setUniform('specular', val, false);
            return val;
        };
        /*
        * Gets or sets emissive light colour
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialOcean.prototype.emissive = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer]._uniforms['emissive'].value;
            this.materials[Trike.PassType.GBuffer].setUniform('emissive', val, false);
            return val;
        };
        /*
        * Gets or sets the shininess of the specular component
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialOcean.prototype.shininess = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer2]._uniforms['shininess'].value;
            this.materials[Trike.PassType.GBuffer2].setUniform('shininess', val, false);
            return val;
        };
        /**
        * Gets or sets the altitude multiplier
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialOcean.prototype.altitude = function (val) {
            if (val === undefined)
                return this._altitude;
            this._altitude = val;
            if (this._heightfield)
                this.setUniform('altitude', val, true);
            return val;
        };
        /**
        * Gets or sets the height offset multiplier
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialOcean.prototype.heightOffset = function (val) {
            if (val === undefined)
                return this._heightOffset;
            this._heightOffset = val;
            if (this._heightfield)
                this.setUniform('heightOffset', val, true);
            return val;
        };
        /**
        * Gets or sets how wide and deep the heightfield texture must be sampled. Higher values mean more vast terrain.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialOcean.prototype.worldScale = function (val) {
            if (val === undefined)
                return this._worldScale;
            this._worldScale = val;
            if (this._worldScale)
                this.setUniform('worldScale', val, true);
            return val;
        };
        /**
        * Gets or sets the resolution of the tiles. This must be the same as the terrain's resolution
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialOcean.prototype.tileResolution = function (val) {
            if (val === undefined)
                return this._tileResolution;
            this.removeDefine('#define TILE_RESOLUTION ' + this._tileResolution.toFixed(1));
            this._tileResolution = val;
            this.addDefine('#define TILE_RESOLUTION ' + val.toFixed(1));
            return val;
        };
        /*
        * Gets or sets the opacity of this material. The values are from 0 to 1.
        * @param {number} val
        */
        MaterialOcean.prototype.opacity = function (val) {
            if (val === undefined)
                return this.materials[Trike.PassType.GBuffer2]._uniforms['opacity'].value;
            this.materials[Trike.PassType.GBuffer2].setUniform('opacity', val, false);
            return val;
        };
        /*
        * Gets or sets if translucency is enabled
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialOcean.prototype.translucencyEnabled = function (val) {
            if (val === undefined)
                return this._translucencyEnabled;
            if (this._translucencyEnabled === val)
                return val;
            if (val) {
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('translucencyScale', Trike.UniformType.FLOAT, this._translucencyScale), false);
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('translucencyDistortion', Trike.UniformType.FLOAT, this._translucencyDistortion), false);
                this.materials[Trike.PassType.GBuffer2].addUniform(new Trike.UniformVar('translucencyPower', Trike.UniformType.FLOAT, this._translucencyPower), false);
                this.materials[Trike.PassType.GBuffer2].addDefine(Trike.ShaderDefines.TRANSLUCENCY_ENABLED);
            }
            else {
                this.materials[Trike.PassType.GBuffer2].removeUniform('translucencyScale', false);
                this.materials[Trike.PassType.GBuffer2].removeUniform('translucencyDistortion', false);
                this.materials[Trike.PassType.GBuffer2].removeUniform('translucencyPower', false);
                this.materials[Trike.PassType.GBuffer2].removeDefine(Trike.ShaderDefines.TRANSLUCENCY_ENABLED);
            }
            this._translucencyEnabled = val;
            return val;
        };
        /*
        * Gets or sets the translucency scale of the material. This is a uniform multiplier of the effect.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialOcean.prototype.translucencyScale = function (val) {
            if (val === undefined)
                return this._translucencyScale;
            this._translucencyScale = val;
            if (this._translucencyEnabled)
                this.materials[Trike.PassType.GBuffer2].setUniform('translucencyScale', val, false);
            return val;
        };
        /*
        * Gets or sets the translucency distortion of the material.
        * Modifies the light angle as it enters the material
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialOcean.prototype.translucencyDistortion = function (val) {
            if (val === undefined)
                return this._translucencyDistortion;
            this._translucencyDistortion = val;
            if (this._translucencyEnabled)
                this.materials[Trike.PassType.GBuffer2].setUniform('translucencyDistortion', val, false);
            return val;
        };
        /*
        * Gets or sets the translucency power of the material.
        * Increasing this has the effect of narrowing the area of the effect
        * @param {number} val [Optional]
        */
        MaterialOcean.prototype.translucencyPower = function (val) {
            if (val === undefined)
                return this._translucencyPower;
            this._translucencyPower = val;
            if (this._translucencyEnabled)
                this.materials[Trike.PassType.GBuffer2].setUniform('translucencyPower', val, false);
            return val;
        };
        return MaterialOcean;
    }(Trike.MaterialMulti));
    Trike.MaterialOcean = MaterialOcean;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A very simple shader that draws a texture to a screen aligned quad
    */
    var MaterialGaussian = (function (_super) {
        __extends(MaterialGaussian, _super);
        function MaterialGaussian() {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this._photometricExponent = 0.1;
            this.materials[Trike.PassType.ScreenQuad] = new Trike.PassMaterial('Screen Texture', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('map', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('blurriness', Trike.UniformType.FLOAT, 1), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
            this.setDirection(true);
        }
        /**
        * Gets or sets the photometric exponent of the shader. Only applies if in CBF mode
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialGaussian.prototype.photometricExponent = function (val) {
            if (val === undefined)
                return this._photometricExponent;
            this._photometricExponent = val;
            if (this._uniforms['photometricExponent'])
                this.setUniform('photometricExponent', val, true);
            return val;
        };
        /**
        * Cross Bilateral filter
        * https://bitbucket.org/sinbad/ogre/src/79c37025a057c6aa00d6a444e08a406c147a6d62/Samples/Media/materials/scripts/SSAO/CrossBilateralFilterYFP.glsl?at=v1-9
        */
        MaterialGaussian.prototype.crossBilateralFilter = function (val) {
            if (val === undefined)
                return this.hasDefine('#define CBF');
            this.removeDefine('#define CBF');
            this.removeUniform('gBuffer2');
            this.removeUniform('photometricExponent');
            if (val) {
                this.addDefine('#define CBF');
                this.addUniform(new Trike.UniformVar('gBuffer2', Trike.UniformType.TEXTURE));
                this.addUniform(new Trike.UniformVar('photometricExponent', Trike.UniformType.FLOAT, this._photometricExponent));
            }
            return val;
        };
        /**
        * Gets or sets the texture we are blurring
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialGaussian.prototype.map = function (val) {
            if (val === undefined)
                return this._uniforms['map'].value;
            this.setUniform('map', val, true);
            return val;
        };
        /**
        * Gets or sets which blur direction this material is employing
        * @param {boolean} horizontal If true, this will be a horizontal blur otherwise it will be vertical
        */
        MaterialGaussian.prototype.setDirection = function (horizontal) {
            this.removeDefine('#define BLUR_X');
            this.removeDefine('#define BLUR_Y');
            if (horizontal)
                this.addDefine('#define BLUR_X');
            else
                this.addDefine('#define BLUR_Y');
        };
        /**
        * Gets or sets the blurriness of the shader
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialGaussian.prototype.blurriness = function (val) {
            if (val === undefined)
                return this._uniforms['blurriness'].value;
            this.setUniform('blurriness', val, true);
            return val;
        };
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialGaussian.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialGaussian.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\tuniform sampler2D map;\n\t\t\t\t#ifdef CBF\n\t\t\t\t\tuniform sampler2D gBuffer2;\n\t\t\t\t\tuniform float photometricExponent;\n\t\t\t\t#endif\n\t\t\t\tuniform float viewHeight;\n\t\t\t\tuniform float viewWidth;\n                uniform float blurriness;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.quadTexCoord() + "\n\n                \tvec4 sum = vec4(0.0);\n\n\t\t\t\t\t#ifdef CBF\n\n\t\t\t\t\t\tconst float kernelWidth = 13.0;\n\t\t\t\t\t\tfloat sigma = ( kernelWidth - 1.0 ) / 6.0; // make the kernel span 6 sigma\n\t\t\t\t\t\tfloat fragmentDepth = texture2D( gBuffer2, texCoord ).z;\n\t\t\t\t\t\tfloat weights = 0.0;\n\t\t\t\t\t\tfloat blurred = 0.0;\n\n\t\t\t\t\t\t#ifdef BLUR_X\n\n\t\t\t\t\t\t\tfloat stepX = blurriness / viewWidth;\n\t\t\t\t\t\t\tfor ( float i = -(kernelWidth - 1.0) / 2.0; i < (kernelWidth - 1.0) / 2.0; i++ )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfloat geometricWeight = exp( -pow( i, 2.0 ) / ( 2.0 * pow( sigma, 2.0 ) ) );\n\t\t\t\t\t\t\t\tfloat sampleDepth = texture2D( gBuffer2, vec2( texCoord.x - i * stepX, texCoord.y ) ).z;\n\t\t\t\t\t\t\t\tfloat photometricWeight = 1.0 / pow( ( 1.0 + abs( fragmentDepth - sampleDepth ) ), photometricExponent );\n\n\t\t\t\t\t\t\t\tweights += (geometricWeight * photometricWeight);\n\t\t\t\t\t\t\t\tblurred += texture2D(map, vec2(texCoord.x - i * stepX, texCoord.y)).r * geometricWeight * photometricWeight;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#else\n\n\t\t\t\t\t\t\tfloat stepY = blurriness / viewHeight;\n\t\t\t\t\t\t\tfor ( float i = -(kernelWidth - 1.0) / 2.0; i < (kernelWidth - 1.0) / 2.0; i++ )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfloat geometricWeight = exp( -pow( i, 2.0 ) / ( 2.0 * pow( sigma, 2.0 ) ) );\n\t\t\t\t\t\t\t\tfloat sampleDepth = texture2D( gBuffer2, vec2( texCoord.x, texCoord.y - i * stepY ) ).z;\n\t\t\t\t\t\t\t\tfloat photometricWeight = 1.0 / pow( ( 1.0 + abs( fragmentDepth - sampleDepth ) ), photometricExponent );\n\n\t\t\t\t\t\t\t\tweights += (geometricWeight * photometricWeight);\n\t\t\t\t\t\t\t\tblurred += texture2D(map, vec2(texCoord.x, texCoord.y - i * stepY )).r * geometricWeight * photometricWeight;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\tblurred /= weights;\n\t\t\t\t\t\t\tgl_FragColor = vec4( blurred, blurred, blurred, 1.0 );\n\n\t\t\t\t\t#else\n                \t\t#ifdef BLUR_X\n                \t\t\tfloat blur  = (blurriness / viewWidth);\n\t\t\t\t\t\t\tfloat texX = texCoord.x;\n                \t\t\tfloat texY = texCoord.y;\n\n\t\t\t\t\t\t\t// blur in y (horizontal)\n\t\t\t\t\t\t\t// take nine samples, with the distance blur between them\n\t\t\t\t\t\t\tsum += texture2D(map, vec2(texX - 4.0 * blur,\ttexY)) * 0.05;\n                \t\t\tsum += texture2D(map, vec2(texX - 3.0 * blur,\ttexY)) * 0.09;\n                \t\t\tsum += texture2D(map, vec2(texX - 2.0 * blur,\ttexY)) * 0.12;\n                \t\t\tsum += texture2D(map, vec2(texX - blur,\t\t\ttexY)) * 0.15;\n\n                \t\t\tsum += texture2D(map, vec2(texX,\t\t\t\ttexY)) * 0.16;\n\n                \t\t\tsum += texture2D(map, vec2(texX + blur,\t\t\ttexY)) * 0.15;\n                \t\t\tsum += texture2D(map, vec2(texX + 2.0 * blur,\ttexY)) * 0.12;\n                \t\t\tsum += texture2D(map, vec2(texX + 3.0 * blur,\ttexY)) * 0.09;\n                \t\t\tsum += texture2D(map, vec2(texX + 4.0 * blur,\ttexY)) * 0.05;\n                \t\t\tgl_FragColor = sum;\n\n                \t\t#else\n\n                \t\t\tfloat blur  = (blurriness / viewHeight);\n                \t\t\tfloat texX = texCoord.x;\n                \t\t\tfloat texY = texCoord.y;\n\n\t\t\t\t\t\t\t// blur in y (vertical)\n\t\t\t\t\t\t\t// take nine samples, with the distance blur between them\n                \t\t\tsum += texture2D(map, vec2(texX, texY - 4.0 * blur )) * 0.05;\n\t\t\t\t\t\t\tsum += texture2D(map, vec2(texX, texY - 3.0 * blur )) * 0.09;\n\t\t\t\t\t\t\tsum += texture2D(map, vec2(texX, texY - 2.0 * blur )) * 0.12;\n\t\t\t\t\t\t\tsum += texture2D(map, vec2(texX, texY - blur )) * 0.15;\n\n\t\t\t\t\t\t\tsum += texture2D(map, vec2(texX, texY)) * 0.16;\n\n\t\t\t\t\t\t\tsum += texture2D(map, vec2(texX, texY + blur )) * 0.15;\n\t\t\t\t\t\t\tsum += texture2D(map, vec2(texX, texY + 2.0 * blur )) * 0.12;\n\t\t\t\t\t\t\tsum += texture2D(map, vec2(texX, texY + 3.0 * blur )) * 0.09;\n\t\t\t\t\t\t\tsum += texture2D(map, vec2(texX, texY + 4.0 * blur )) * 0.05;\n\n\t\t\t\t\t\t\tgl_FragColor = sum;\n\n                \t\t#endif\n\t\t\t\t\t#endif\n\t\t\t\t}\n\t\t\t";
        };
        return MaterialGaussian;
    }(Trike.MaterialMulti));
    Trike.MaterialGaussian = MaterialGaussian;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Extracts or highlights luminescent areas of a texture
    */
    var MaterialExtractLight = (function (_super) {
        __extends(MaterialExtractLight, _super);
        function MaterialExtractLight() {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.ScreenQuad] = new Trike.PassMaterial('Material Extract Light', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('map', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('contrast', Trike.UniformType.FLOAT, 6.2), true);
            this.addUniform(new Trike.UniformVar('brightness', Trike.UniformType.FLOAT, 0.5), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Gets or sets the contrast of the shader
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialExtractLight.prototype.contrast = function (val) {
            if (val === undefined)
                return this._uniforms['contrast'].value;
            this.setUniform('contrast', val, true);
            return val;
        };
        /**
        * Gets or sets the max brightness of the shader
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialExtractLight.prototype.brightness = function (val) {
            if (val === undefined)
                return this._uniforms['brightness'].value;
            this.setUniform('brightness', val, true);
            return val;
        };
        /**
        * Gets or sets the texture we are blurring
        * @param {TextureBase} val [Optional]
        * @returns {TextureBase}
        */
        MaterialExtractLight.prototype.map = function (val) {
            if (val === undefined)
                return this._uniforms['map'].value;
            this.setUniform('map', val, true);
            return val;
        };
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialExtractLight.prototype.getVertexShader = function () {
            return "\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialExtractLight.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\tuniform sampler2D map;\n\t\t\t\tuniform float viewHeight;\n\t\t\t\tuniform float viewWidth;\n                uniform float brightness;\n\t\t\t\tuniform float contrast;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.quadTexCoord() + "\n\n                \tgl_FragColor = texture2D( map, texCoord );\n\n                \tvec3 inColor = gl_FragColor.xyz;\n                \tinColor = inColor * inColor;\n                \tinColor *= brightness;\n                \tvec3 outColor;\n                \tvec3 x = max( vec3( 0.0 ), inColor - 0.004 );\n                \toutColor = ( x * ( contrast * x + 0.5 ) ) / ( x * ( contrast * x + 1.7 ) + 0.06 );\n\t\t\t\t\tgl_FragColor.rgb = outColor;\n\t\t\t\t}\n\n\t\t\t";
        };
        return MaterialExtractLight;
    }(Trike.MaterialMulti));
    Trike.MaterialExtractLight = MaterialExtractLight;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Darkens areas of the scene where geometry is close together
    * See
    * http://blog.evoserv.at/index.php/2012/12/hemispherical-screen-space-ambient-occlusion-ssao-for-deferred-renderers-using-openglglsl/
    * https://github.com/jdupuy/ssgi/blob/master/src/shaders/ssgi.glsl
    * http://forum.unity3d.com/threads/my-ssao-ssgi-prototype.78566/
    * https://github.com/kayru/dssdo/blob/master/dssdo.hlsl
    * http://kayru.org/articles/dssdo/
    */
    var MaterialAO = (function (_super) {
        __extends(MaterialAO, _super);
        function MaterialAO() {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.ScreenQuad] = new Trike.PassMaterial('AO', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('gBuffer2', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('noiseSampler', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('samplingRadius', Trike.UniformType.FLOAT, 10), true);
            this.addUniform(new Trike.UniformVar('occluderBias', Trike.UniformType.FLOAT, 0.05), true);
            this.addUniform(new Trike.UniformVar('intensity', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('frustumCorners', Trike.UniformType.FLOAT3_ARRAY), true);
            this.addUniform(new Trike.UniformVar('texelSize', Trike.UniformType.FLOAT2), true);
            this.addUniform(new Trike.UniformVar('attenuation1', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('attenuation2', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('noiseScale', Trike.UniformType.FLOAT2), true);
            this.addUniform(new Trike.UniformVar('invProjectionMatrix', Trike.UniformType.MAT4), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            this.addAttribute(new Trike.AttributeVar('frustumCornerIndex', Trike.AttributeType.SCREEN_CORNER_INDEX));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.addDefine(Trike.ShaderDefines.QUAD_LIGHTING);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialAO.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n                " + Trike.ShaderFragments.VertParams.frustumCorners() + "\n                " + Trike.ShaderFragments.VertParams.screenQuadBoundaries() + "\n\n                void main()\n                {\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.frustumCorners() + "\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.checkBoundaries() + "\n                }";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialAO.prototype.getFragmentShader = function () {
            return "\n\t\t\t\tuniform sampler2D gBuffer2;\n\t\t\t\tuniform sampler2D noiseSampler;\n\t\t\t\tuniform float viewHeight;\n\t\t\t\tuniform float viewWidth;\n                uniform float intensity;\n\t\t\t\tuniform float attenuation1;\n\t\t\t\tuniform float attenuation2;\n\t\t\t\tuniform vec2 noiseScale;\n\t\t\t\tuniform mat4 invProjectionMatrix;\n\t\t\t\tuniform float samplingRadius;\n\t\t\t\tuniform float occluderBias;\n\n\t\t\t\tuniform vec2 texelSize;\n\t\t\t\tconst int sample_count = 16;\n\n\t\t\t\t" + Trike.ShaderFragments.FragParams.frustumCorners() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.floatToVec() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.vecToFloat() + "\n\n\t\t\t\tvec3 posFromDepth(vec2 coord)\n\t\t\t\t{\n\t\t\t\t\tvec4 curSample = texture2D(gBuffer2, coord);\n\t\t\t\t\tfloat d = curSample.z;\n\t\t\t\t\tvec3 tray = ( invProjectionMatrix * vec4( ( coord.x - 0.5 ) * 2.0, ( coord.y - 0.5 ) * 2.0, 1.0, 1.0 ) ).xyz;\n\t\t\t\t\treturn tray * d;\n\t\t\t\t}\n\n\t\t\t\tfloat samplePixels(vec3 srcPosition, vec3 srcNormal, vec2 uv )\n\t\t\t\t{\n\t\t\t\t\tvec3 dstPosition = posFromDepth(uv);\n\t\t\t\t\tvec3 direction = dstPosition - srcPosition;\n\t\t\t\t\tfloat dist = length(direction);\n\n\t\t\t\t\t// Calculate ambient occlusion amount between these two points\n\t\t\t\t\t// It is simular to diffuse lighting. Objects directly above the fragment cast\n\t\t\t\t\t// the hardest shadow and objects closer to the horizon have minimal effect.\n\t\t\t\t\tfloat intensity = max(dot(normalize(direction), srcNormal) - occluderBias, 0.0);\n\n\t\t\t\t\t// Attenuate the occlusion, similar to how you attenuate a light source.\n\t\t\t\t\t// The further the distance between points, the less effect AO has on the fragment.\n\t\t\t\t\tfloat attenuation = 1.0 / (attenuation1 + (attenuation2 * dist));\n\t\t\t\t\treturn intensity * attenuation;\n\t\t\t\t}\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.quadTexCoord() + "\n\t\t\t\t\tvec4 gBuffer2Sample = texture2D( gBuffer2, texCoord );\n\t\t\t\t\tfloat normalizedDepth = gBuffer2Sample.z;\n\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.computeNormal() + "\n\t\t\t\t\tvec3 srcPosition = posFromDepth(texCoord);\n\t\t\t\t\tvec2 randVec = normalize(texture2D(noiseSampler, texCoord * noiseScale ).xy * 2.0 - 1.0);\n\n\t\t\t\t\t// The following variable specifies how many pixels we skip over after each\n\t\t\t\t\t// iteration in the ambient occlusion loop. We can't sample every pixel within\n\t\t\t\t\t// the sphere of influence because that's too slow. We only need to sample\n\t\t\t\t\t// some random pixels nearby to apprxomate the solution.\n\t\t\t\t\t//\n\t\t\t\t\t// Pixels far off in the distance will not sample as many pixels as those close up.\n\t\t\t\t\tfloat kernelRadius = samplingRadius * (1.0 - normalizedDepth);\n\n\t\t\t\t\t// Sample neighbouring pixels\n\t\t\t\t\tvec2 kernel[4];\n\t\t\t\t\tkernel[0] = vec2(0.0, 1.0); // top\n\t\t\t\t\tkernel[1] = vec2(1.0, 0.0); // right\n\t\t\t\t\tkernel[2] = vec2(0.0, -1.0); // bottom\n\t\t\t\t\tkernel[3] = vec2(-1.0, 0.0); // left\n\n\t\t\t\t\tconst float Sin45 = 0.707107; // 45 degrees = sin(PI / 4)\n\n\t\t\t\t\t// Sample from 16 pixels, which should be enough to appromixate a result. You can\n\t\t\t\t\t// sample from more pixels, but it comes at the cost of performance.\n\t\t\t\t\tfloat occlusion = 0.0;\n\n\t\t\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tvec2 k1 = reflect(kernel[i], randVec);\n\t\t\t\t\t\tvec2 k2 = vec2(k1.x * Sin45 - k1.y * Sin45, k1.x * Sin45 + k1.y * Sin45);\n\t\t\t\t\t\tk1 *= texelSize;\n\t\t\t\t\t\tk2 *= texelSize;\n\n\t\t\t\t\t\tocclusion += samplePixels(srcPosition, normal, texCoord + k1 * kernelRadius );\n\t\t\t\t\t\tocclusion += samplePixels(srcPosition, normal, texCoord + k2 * kernelRadius * 0.75 );\n\t\t\t\t\t\tocclusion += samplePixels(srcPosition, normal, texCoord + k1 * kernelRadius * 0.5 );\n\t\t\t\t\t\tocclusion += samplePixels(srcPosition, normal, texCoord + k2 * kernelRadius * 0.25 );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Average and clamp ambient occlusion\n\t\t\t\t\tocclusion /= 16.0;\n\t\t\t\t\tocclusion = clamp(occlusion, 0.0, 1.0);\n\n\t\t\t\t\t// Stops artifacts forming in the distance\n\t\t\t\t\tocclusion *= 1.0 - smoothstep(0.7, 0.8, normalizedDepth);\n\n\t\t\t\t\tgl_FragColor.xyz = vec3(1.0 - occlusion * intensity);\n\t\t\t\t}";
        };
        return MaterialAO;
    }(Trike.MaterialMulti));
    Trike.MaterialAO = MaterialAO;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Similar to screen space amient occlusion, but more expensive.
    * See http://developer.download.nvidia.com/presentations/2008/SIGGRAPH/HBAO_SIG08b.pdf
    * https://github.com/scanberg/hbao
    * https://gist.github.com/fisch0920/6770346
    */
    var MaterialHBAO = (function (_super) {
        __extends(MaterialHBAO, _super);
        function MaterialHBAO() {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.ScreenQuad] = new Trike.PassMaterial('AO', this);
            this._numDirections = 6;
            this._numSteps = 3;
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('fov', Trike.UniformType.FLOAT, 45), true);
            this.addUniform(new Trike.UniformVar('sampleRadius', Trike.UniformType.FLOAT, 0.5), true);
            this.addUniform(new Trike.UniformVar('angleBias', Trike.UniformType.FLOAT, 0.2), true);
            this.addUniform(new Trike.UniformVar('intensity', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('invProjectionMatrix', Trike.UniformType.MAT4), true);
            this.addUniform(new Trike.UniformVar('noiseScale', Trike.UniformType.FLOAT2), true);
            this.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('gBuffer2', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('noiseSampler', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('frustumCorners', Trike.UniformType.FLOAT3_ARRAY), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            this.addAttribute(new Trike.AttributeVar('frustumCornerIndex', Trike.AttributeType.SCREEN_CORNER_INDEX));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.addDefine(Trike.ShaderDefines.QUAD_LIGHTING);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
            this.numDirections(6);
            this.numSteps(3);
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialHBAO.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n                " + Trike.ShaderFragments.VertParams.frustumCorners() + "\n                " + Trike.ShaderFragments.VertParams.screenQuadBoundaries() + "\n\n                void main()\n                {\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.frustumCorners() + "\n\t\t\t\t\t" + Trike.ShaderFragments.VertMain.checkBoundaries() + "\n                }";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialHBAO.prototype.getFragmentShader = function () {
            return "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.frustumCorners() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.floatToVec() + "\n\t\t\t\t" + Trike.ShaderFragments.FragParams.vecToFloat() + "\n\n\t\t\t\tuniform sampler2D gBuffer2;\n\t\t\t\tuniform sampler2D noiseSampler;\n\t\t\t\tuniform float viewHeight;\n\t\t\t\tuniform float viewWidth;\n\t\t\t\tuniform mat4 invProjectionMatrix;\n\t\t\t\tuniform float fov;\n\t\t\t\tuniform float sampleRadius;\n\t\t\t\tuniform float angleBias;\n\t\t\t\tuniform float intensity;\n\t\t\t\tuniform vec2 noiseScale;\n\n\t\t\t\t#define APPLY_ATTENUATION     false\n\t\t\t\t#define USE_ACTUAL_NORMALS    false\n\t\t\t\t#define PI 3.14159265359\n\t\t\t\t#define TWO_PI 6.28318530718\n\n\t\t\t\tvec3 posFromDepth(vec2 coord)\n\t\t\t\t{\n\t\t\t\t\tvec4 curSample = texture2D(gBuffer2, coord);\n\t\t\t\t\tfloat d = curSample.z;\n\n\t\t\t\t\t// [0,1] -> [-1,1] clip space\n\t\t\t\t\tvec3 tray = ( invProjectionMatrix * vec4( ( coord.x-0.5 ) * 2.0, ( coord.y - 0.5 ) * 2.0, 1.0, 1.0 ) ).xyz;\n\t\t\t\t\treturn tray * d;\n\t\t\t\t}\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\t" + Trike.ShaderFragments.FragMain.quadTexCoord() + "\n\t\t\t\t\tvec3 originVS = posFromDepth(texCoord);\n\n\t\t\t\t\t#if defined(USE_ACTUAL_NORMALS)\n\t\t\t\t\t\tvec3 normalVS = normalize( float_to_vec3( abs( texture2D( gBuffer2, texCoord ).x ) ) * 2.0 - 1.0 );\n\t\t\t\t\t#else\n\t\t\t\t\t\tvec3 normalVS = reconstructNormalVS(originVS);\n\t\t\t\t\t#endif\n\n\t\t\t\t\tfloat radiusSS = 0.0; // radius of influence in screen space\n\t\t\t\t\tfloat radiusWS = 0.0; // radius of influence in world space\n\n\t\t\t\t\tradiusSS = sampleRadius;\n\t\t\t\t\tvec4 temp0 = invProjectionMatrix * vec4(0.0, 0.0, -1.0, 1.0);\n\t\t\t\t\tvec3 out0  = temp0.xyz;\n\t\t\t\t\tvec4 temp1 = invProjectionMatrix * vec4(radiusSS, 0.0, -1.0, 1.0);\n\t\t\t\t\tvec3 out1  = temp1.xyz;\n\n\t\t\t\t\t// NOTE (travis): empirically, the main introduction of artifacts with HBAO\n\t\t\t\t\t// is having too large of a world-space radius; attempt to combat this issue by\n\t\t\t\t\t// clamping the world-space radius based on the screen-space radius' projection\n\t\t\t\t\tradiusWS = min(tan(radiusSS * fov / 2.0) * originVS.y / 2.0, length(out1 - out0));\n\n\t\t\t\t\tconst float theta = TWO_PI / float(NUM_SAMPLE_DIRECTIONS);\n\t\t\t\t\tfloat cosTheta = cos(theta);\n\t\t\t\t\tfloat sinTheta = sin(theta);\n\n\t\t\t\t\t// matrix to create the sample directions\n\t\t\t\t\tmat2 deltaRotationMatrix = mat2(cosTheta, -sinTheta, sinTheta, cosTheta);\n\n\t\t\t\t\t// step vector in view space\n\t\t\t\t\tvec2 deltaUV = vec2(1.0, 0.0) * (radiusSS / (float(NUM_SAMPLE_DIRECTIONS * NUM_SAMPLE_STEPS) + 1.0));\n\n\t\t\t\t\t// we don't want to sample to the perimeter of R since those samples would be\n\t\t\t\t\t// omitted by the distance attenuation (W(R) = 0 by definition)\n\t\t\t\t\t// Therefore we add a extra step and don't use the last sample.\n\t\t\t\t\tvec3 sampleNoise    = texture2D(noiseSampler, texCoord * noiseScale).xyz;\n\t\t\t\t\tmat2 rotationMatrix = mat2(sampleNoise.x, -sampleNoise.y, sampleNoise.y,  sampleNoise.x);\n\n\t\t\t\t\t// apply a random rotation to the base step vector\n\t\t\t\t\tdeltaUV = rotationMatrix * deltaUV;\n\n\t\t\t\t\tfloat jitter = sampleNoise.z;\n\t\t\t\t\tfloat occlusion = 0.0;\n\n\t\t\t\t\tfor (int i = 0; i < NUM_SAMPLE_DIRECTIONS; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\t// incrementally rotate sample direction\n\t\t\t\t\t\tdeltaUV = deltaRotationMatrix * deltaUV;\n\n\t\t\t\t\t\tvec2 sampleDirUV = deltaUV;\n\t\t\t\t\t\tfloat oldAngle   = angleBias;\n\n\t\t\t\t\t\tfor (int j = 0; j < NUM_SAMPLE_STEPS; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec2 sampleUV\t\t= texCoord + (jitter + float(j)) * sampleDirUV;\n\t\t\t\t\t\t\tvec3 sampleVS\t\t= posFromDepth(sampleUV);\n\t\t\t\t\t\t\tvec3 sampleDirVS\t= (sampleVS - originVS);\n\n\t\t\t\t\t\t\t// angle between fragment tangent and the sample\n\t\t\t\t\t\t\tfloat gamma = (PI / 2.0) - acos(dot(normalVS, normalize(sampleDirVS)));\n\n\t\t\t\t\t\t\tif (gamma > oldAngle)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfloat value = sin(gamma) - sin(oldAngle);\n\n\t\t\t\t\t\t\t\t#if defined(APPLY_ATTENUATION)\n\t\t\t\t\t\t\t\t\t// distance between original and sample points\n\t\t\t\t\t\t\t\t\tfloat attenuation = clamp(1.0 - pow(length(sampleDirVS) / radiusWS, 2.0), 0.0, 1.0);\n\t\t\t\t\t\t\t\t\tocclusion += attenuation * value;\n\t\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t\tocclusion += value;\n\t\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\t\toldAngle = gamma;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tocclusion = 1.0 - occlusion / float(NUM_SAMPLE_DIRECTIONS);\n\t\t\t\t\tocclusion = clamp(pow(occlusion, 1.0 + intensity), 0.0, 1.0);\n\t\t\t\t\tgl_FragColor = vec4(occlusion, occlusion, occlusion, 1.0);\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Gets or sets the number of sample directions (beware that increasing this can significantly slow down the shader)
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialHBAO.prototype.numDirections = function (val) {
            if (val === undefined)
                return this._numDirections;
            this.removeDefine('#define NUM_SAMPLE_DIRECTIONS ' + this._numDirections.toFixed(0));
            this._numDirections = val;
            this.addDefine('#define NUM_SAMPLE_DIRECTIONS ' + val.toFixed(0));
            return val;
        };
        /**
        * Gets or sets the number of sample steps (beware that increasing this can significantly slow down the shader)
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialHBAO.prototype.numSteps = function (val) {
            if (val === undefined)
                return this._numSteps;
            this.removeDefine('#define NUM_SAMPLE_STEPS ' + this._numSteps.toFixed(0));
            this._numSteps = val;
            this.addDefine('#define NUM_SAMPLE_STEPS ' + val.toFixed(0));
            return val;
        };
        /**
        * Gets or sets the fov of the pixels from each sample point.
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialHBAO.prototype.fov = function (val) {
            if (val === undefined)
                return this._uniforms['fov'].value;
            this.setUniform('fov', val, true);
            return val;
        };
        /**
        * Gets or sets the sample radius of the AO
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialHBAO.prototype.sampleRadius = function (val) {
            if (val === undefined)
                return this._uniforms['sampleRadius'].value;
            this.setUniform('sampleRadius', val, true);
            return val;
        };
        /**
        * Gets or sets the angle bias radius of the AO
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialHBAO.prototype.angleBias = function (val) {
            if (val === undefined)
                return this._uniforms['angleBias'].value;
            this.setUniform('angleBias', val, true);
            return val;
        };
        /**
        * Gets or sets the intensity of the AO
        * @param {number} val [Optional]
        * @returns {number}
        */
        MaterialHBAO.prototype.intensity = function (val) {
            if (val === undefined)
                return this._uniforms['intensity'].value;
            this.setUniform('intensity', val, true);
            return val;
        };
        /**
        * Gets or sets the noise scale of the AO
        * @param {Vec2} val [Optional]
        * @returns {Vec2}
        */
        MaterialHBAO.prototype.noiseScale = function (val) {
            if (val === undefined)
                return this._uniforms['noiseScale'].value;
            this.setUniform('noiseScale', val, true);
            return val;
        };
        return MaterialHBAO;
    }(Trike.MaterialMulti));
    Trike.MaterialHBAO = MaterialHBAO;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Blurs the image depending on the distance of the pixel to the focal point
    * Based on http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html
    */
    var MaterialBokeh = (function (_super) {
        __extends(MaterialBokeh, _super);
        function MaterialBokeh() {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.ScreenQuad] = new Trike.PassMaterial('Bokeh', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('gBuffer2', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('compositionPass', Trike.UniformType.TEXTURE), true);
            this.addUniform(new Trike.UniformVar('maxBlur', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('aperture', Trike.UniformType.FLOAT, 0.025), true);
            this.addUniform(new Trike.UniformVar('focus', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('aspect', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 500), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialBokeh.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n                void main()\n                {\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n                }";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialBokeh.prototype.getFragmentShader = function () {
            return "\n                uniform float viewHeight;\n\t\t\t\tuniform float viewWidth;\n                uniform sampler2D compositionPass;\n                uniform sampler2D gBuffer2;\n                uniform float maxBlur;\n                uniform float aperture;\n                uniform float focus;\n                uniform float aspect;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n                    " + Trike.ShaderFragments.FragMain.quadTexCoord() + "\n                    vec2 aspectcorrect = vec2( 1.0, aspect );\n                    float depth = texture2D( gBuffer2, texCoord ).z;\n                    float factor = depth - focus;\n                    vec2 dofblur = vec2 ( clamp( factor * aperture, -maxBlur, maxBlur ) );\n                    vec2 dofblur9 = dofblur * 0.9;\n                    vec2 dofblur7 = dofblur * 0.7;\n                    vec2 dofblur4 = dofblur * 0.4;\n                    vec4 col = vec4( 0.0 );\n\n                    col += texture2D( compositionPass, texCoord.xy );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );\n\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\n\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );\n\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\n                    col += texture2D( compositionPass, texCoord.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );\n\n                    gl_FragColor = col / 41.0;\n                    gl_FragColor.a = 1.0;\n\t\t\t\t}";
        };
        return MaterialBokeh;
    }(Trike.MaterialMulti));
    Trike.MaterialBokeh = MaterialBokeh;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Convolves a texture
    * See for more:
    * http://codeflow.org/entries/2011/apr/18/advanced-webgl-part-3-irradiance-environment-map/
    */
    var MaterialConvolver = (function (_super) {
        __extends(MaterialConvolver, _super);
        function MaterialConvolver() {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.ScreenQuad] = new Trike.PassMaterial('Convolver', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('sampler', Trike.UniformType.TEXTURE_CUBE), true);
            this.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('specularity', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('invViewRot', Trike.UniformType.MAT4), true);
            // Different from the standard uniform as it uses a different camera
            this.addUniform(new Trike.UniformVar('invProjMatrix', Trike.UniformType.MAT4), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialConvolver.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n                void main()\n                {\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n                }";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialConvolver.prototype.getFragmentShader = function () {
            return "\n\t\t\t\tuniform samplerCube sampler;\n\t\t\t\tuniform float viewHeight;\n\t\t\t\tuniform float viewWidth;\n\t\t\t\tuniform mat4 invProjMatrix;\n\t\t\t\tuniform mat4 invViewRot;\n\t\t\t\tuniform float specularity;\n\n\t\t\t\tconst vec3 x = vec3(1.0, 0.0, 0.0);\n\t\t\t\tconst vec3 y = vec3(0.0, 1.0, 0.0);\n\t\t\t\tconst vec3 z = vec3(0.0, 0.0, 1.0);\n\n\t\t\t\tconst mat3 front = mat3(x, y, z);\n\t\t\t\tconst mat3 back = mat3(x, y, -z);\n\t\t\t\tconst mat3 right = mat3(z, y, x);\n\t\t\t\tconst mat3 left = mat3(z, y, -x);\n\t\t\t\tconst mat3 top = mat3(x, z, y);\n\t\t\t\tconst mat3 bottom = mat3(x, z, -y);\n\n\t\t\t\tconst float size = 16.0;\n\t\t\t\tconst float start = ((0.5/size)-0.5)*2.0;\n\t\t\t\tconst float end = -start;\n\t\t\t\tconst float incr = 2.0/size;\n\n\t\t\t\tvec3 getEyeNormal()\n\t\t\t\t{\n\t\t\t\t\tvec2 fragCoord = gl_FragCoord.xy / vec2(viewWidth, viewHeight);\n\t\t\t\t\tfragCoord = ( fragCoord - 0.5 ) * 2.0;\n\t\t\t\t\tvec4 deviceNormal = vec4( fragCoord, 0.0, 1.0 );\n\t\t\t\t\tvec3 eyeNormal = normalize( ( invProjMatrix * deviceNormal ).xyz );\n\t\t\t\t\tvec3 worldNormal = normalize( ( invViewRot * vec4( eyeNormal, 0.0 ) ).xyz );\n\t\t\t\t\treturn worldNormal;\n\t\t\t\t}\n\n\t\t\t\tvec4 sample( mat3 side, vec3 eyedir, vec3 baseRay )\n\t\t\t\t{\n\t\t\t\t\tvec3 ray = side * baseRay;\n\t\t\t\t\tfloat lambert = max( 0.0, dot( ray, eyedir ) );\n\t\t\t\t\tfloat term = pow( lambert, specularity ) * baseRay.z;\n\t\t\t\t\treturn vec4( textureCube( sampler, ray ).rgb * term, term );\n\t\t\t\t}\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tvec4 result = vec4(0.0);\n\t\t\t\t\tvec3 eyedir = getEyeNormal(), ray;\n\n\t\t\t\t\tfor(float xi=start; xi<=end; xi+=incr)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(float yi=start; yi<=end; yi+=incr)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tray = normalize((invProjMatrix * vec4(xi, yi, 0.0, 1.0)).xyz);\n\t\t\t\t\t\t\tresult += sample(front, eyedir, ray);\n\t\t\t\t\t\t\tresult += sample(back, eyedir, ray);\n\t\t\t\t\t\t\tresult += sample(top, eyedir, ray);\n\t\t\t\t\t\t\tresult += sample(bottom, eyedir, ray);\n\t\t\t\t\t\t\tresult += sample(left, eyedir, ray);\n\t\t\t\t\t\t\tresult += sample(right, eyedir, ray);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tresult /= result.w;\n\t\t\t\t\tgl_FragColor = vec4(result.rgb, 1.0);\n\t\t\t\t}";
        };
        return MaterialConvolver;
    }(Trike.MaterialMulti));
    Trike.MaterialConvolver = MaterialConvolver;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Downsamples a cube texture
    * See
    * https://github.com/pyalot/WebGL-City-SSAO/blob/master/sky/downsample.shader
    */
    var MaterialCubeDownsample = (function (_super) {
        __extends(MaterialCubeDownsample, _super);
        function MaterialCubeDownsample() {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.ScreenQuad] = new Trike.PassMaterial('Downsampler', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('sampler', Trike.UniformType.TEXTURE_CUBE), true);
            this.addUniform(new Trike.UniformVar('viewWidth', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('viewHeight', Trike.UniformType.FLOAT, 500), true);
            this.addUniform(new Trike.UniformVar('invViewRot', Trike.UniformType.MAT4), true);
            // Different from the standard uniform as it uses a different camera
            this.addUniform(new Trike.UniformVar('invProjMatrix', Trike.UniformType.MAT4), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialCubeDownsample.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n                void main()\n                {\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n                }";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialCubeDownsample.prototype.getFragmentShader = function () {
            return "\n\t\t\t\tuniform samplerCube sampler;\n\t\t\t\tuniform float viewHeight;\n\t\t\t\tuniform float viewWidth;\n\t\t\t\tuniform mat4 invProjMatrix;\n\t\t\t\tuniform mat4 invViewRot;\n\n\t\t\t\tconst vec3 x = vec3(1.0, 0.0, 0.0);\n\t\t\t\tconst vec3 y = vec3(0.0, 1.0, 0.0);\n\t\t\t\tconst vec3 z = vec3(0.0, 0.0, 1.0);\n\n\t\t\t\tconst mat3 front = mat3(x, y, z);\n\t\t\t\tconst mat3 back = mat3(x, y, -z);\n\t\t\t\tconst mat3 right = mat3(z, y, x);\n\t\t\t\tconst mat3 left = mat3(z, y, -x);\n\t\t\t\tconst mat3 top = mat3(x, z, y);\n\t\t\t\tconst mat3 bottom = mat3(x, z, -y);\n\n\t\t\t\tconst float size = 16.0;\n\t\t\t\tconst float start = ( ( 0.5 / size ) - 0.5 ) * 2.0;\n\t\t\t\tconst float end = -start;\n\t\t\t\tconst float incr = 2.0 / size;\n\n\t\t\t\tvec3 getWorldNormal( vec2 pos, vec2 dims )\n\t\t\t\t{\n\t\t\t\t\tvec2 frag_coord = pos / dims;\n\t\t\t\t\tfrag_coord = ( frag_coord - 0.5 ) * 2.0;\n\t\t\t\t\tvec4 device_normal = vec4( frag_coord, 0.0, 1.0 );\n\t\t\t\t\tvec3 eye_normal = normalize( ( invProjMatrix * device_normal ).xyz );\n\t\t\t\t\tvec3 world_normal = normalize( ( invViewRot * vec4( eye_normal, 0.0 ) ).xyz );\n\t\t\t\t\treturn world_normal;\n\t\t\t\t}\n\n\t\t\t\tvec4 sample(float xoff, float yoff)\n\t\t\t\t{\n\t\t\t\t\tvec2 off = gl_FragCoord.xy * 2.0 + vec2( xoff, yoff );\n\t\t\t\t\tvec3 normal = getWorldNormal( off, vec2( viewWidth, viewHeight ) * 2.0 );\n\t\t\t\t\treturn sqrt( textureCube( sampler, normal ) );\n\t\t\t\t}\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tvec4 color = (\n\t\t\t\t\t\tsample(-0.5, -0.5) +\n\t\t\t\t\t\tsample(-0.5, +0.5) +\n\t\t\t\t\t\tsample(+0.5, -0.5) +\n\t\t\t\t\t\tsample(+0.5, +0.5)\n\t\t\t\t\t) * 0.25;\n\n\t\t\t\t\tgl_FragColor = vec4( color.rgb, 1.0 );\n\t\t\t\t}";
        };
        return MaterialCubeDownsample;
    }(Trike.MaterialMulti));
    Trike.MaterialCubeDownsample = MaterialCubeDownsample;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Builds the shaders of the materials used in the passes
    */
    var ShaderPassBuilder = (function () {
        function ShaderPassBuilder() {
            ShaderPassBuilder._singleton = this;
        }
        ShaderPassBuilder.prototype.buildPassShaders = function (materials) {
            var material;
            for (var m in materials) {
                material = materials[m];
            }
        };
        ShaderPassBuilder.getSingleton = function (customBuilder) {
            if (!ShaderPassBuilder._singleton)
                new ShaderPassBuilder();
            return ShaderPassBuilder._singleton;
        };
        return ShaderPassBuilder;
    }());
    Trike.ShaderPassBuilder = ShaderPassBuilder;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * A very simple shader that draws a sobel noise
    */
    var MaterialSobel = (function (_super) {
        __extends(MaterialSobel, _super);
        /**
        * Creates an instance of the shader
        * @param {number} width The width of the texture
        * @param {number} height The height of the texture
        */
        function MaterialSobel(width, height) {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Texture] = new Trike.PassMaterial('Sobel', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('resolution', Trike.UniformType.FLOAT2, new Trike.Vec2(width, height)), true);
            this.addUniform(new Trike.UniformVar('timeConst', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('frequency', Trike.UniformType.FLOAT, 4), true);
            this.addUniform(new Trike.UniformVar('period', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('amplitude', Trike.UniformType.FLOAT, 0.1), true);
            this.addUniform(new Trike.UniformVar('color', Trike.UniformType.COLOR3, new Trike.Color(0xffffff), true));
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialSobel.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialSobel.prototype.getFragmentShader = function () {
            // GLSL textureless classic 3D noise 'cnoise
            // with an RSL-style periodic variant 'pnoise'.
            // Author:  Stefan Gustavson (stefan.gustavson@liu.se)
            // Version: 2011-10-11
            //
            // Many thanks to Ian McEwan of Ashima Arts for the
            // ideas for permutation and gradient selection.
            //
            // Copyright (c) 2011 Stefan Gustavson. All rights reserved.
            // Distributed under the MIT license. See LICENSE file.
            // https://github.com/ashima/webgl-noise
            //
            return "\n\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tuniform vec3 color;\n\t\t\t\tuniform float timeConst;\n\t\t\t\tuniform float frequency;\n\t\t\t\tuniform float period;\n\t\t\t\tuniform float amplitude;\n\n\t\t\t\tvec3 mod289(vec3 x)\n\t\t\t\t{\n\t\t\t\t\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t\t\t}\n\n\t\t\t\tvec4 mod289(vec4 x)\n\t\t\t\t{\n\t\t\t\t\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t\t\t}\n\n\t\t\t\tvec4 permute(vec4 x)\n\t\t\t\t{\n\t\t\t\t\treturn mod289(((x * 34.0) + 1.0) * x);\n\t\t\t\t}\n\n\t\t\t\tvec4 taylorInvSqrt(vec4 r)\n\t\t\t\t{\n\t\t\t\t\treturn 1.79284291400159 - 0.85373472095314 * r;\n\t\t\t\t}\n\n\t\t\t\tvec3 fade(vec3 t)\n\t\t\t\t{\n\t\t\t\t\treturn t* t * t * (t * (t * 6.0 - 15.0) + 10.0);\n\t\t\t\t}\n\n\t\t\t\t// Classic Perlin noise\n\t\t\t\tfloat cnoise(vec3 P)\n\t\t\t\t{\n\t\t\t\t\tvec3 Pi0 = floor(P); // Integer part for indexing\n\t\t\t\t\tvec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n\t\t\t\t\tPi0 = mod289(Pi0);\n\t\t\t\t\tPi1 = mod289(Pi1);\n\t\t\t\t\tvec3 Pf0 = fract(P); // Fractional part for interpolation\n\t\t\t\t\tvec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n\t\t\t\t\tvec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n\t\t\t\t\tvec4 iy = vec4(Pi0.yy, Pi1.yy);\n\t\t\t\t\tvec4 iz0 = Pi0.zzzz;\n\t\t\t\t\tvec4 iz1 = Pi1.zzzz;\n\n\t\t\t\t\tvec4 ixy = permute(permute(ix) + iy);\n\t\t\t\t\tvec4 ixy0 = permute(ixy + iz0);\n\t\t\t\t\tvec4 ixy1 = permute(ixy + iz1);\n\n\t\t\t\t\tvec4 gx0 = ixy0 * (1.0 / 7.0);\n\t\t\t\t\tvec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n\t\t\t\t\tgx0 = fract(gx0);\n\t\t\t\t\tvec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n\t\t\t\t\tvec4 sz0 = step(gz0, vec4(0.0));\n\t\t\t\t\tgx0 -= sz0 * (step(0.0, gx0) - 0.5);\n\t\t\t\t\tgy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n\t\t\t\t\tvec4 gx1 = ixy1 * (1.0 / 7.0);\n\t\t\t\t\tvec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n\t\t\t\t\tgx1 = fract(gx1);\n\t\t\t\t\tvec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n\t\t\t\t\tvec4 sz1 = step(gz1, vec4(0.0));\n\t\t\t\t\tgx1 -= sz1 * (step(0.0, gx1) - 0.5);\n\t\t\t\t\tgy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n\t\t\t\t\tvec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n\t\t\t\t\tvec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n\t\t\t\t\tvec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n\t\t\t\t\tvec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n\t\t\t\t\tvec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n\t\t\t\t\tvec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n\t\t\t\t\tvec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n\t\t\t\t\tvec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n\n\t\t\t\t\tvec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n\t\t\t\t\tg000 *= norm0.x;\n\t\t\t\t\tg010 *= norm0.y;\n\t\t\t\t\tg100 *= norm0.z;\n\t\t\t\t\tg110 *= norm0.w;\n\t\t\t\t\tvec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n\t\t\t\t\tg001 *= norm1.x;\n\t\t\t\t\tg011 *= norm1.y;\n\t\t\t\t\tg101 *= norm1.z;\n\t\t\t\t\tg111 *= norm1.w;\n\n\t\t\t\t\tfloat n000 = dot(g000, Pf0);\n\t\t\t\t\tfloat n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n\t\t\t\t\tfloat n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n\t\t\t\t\tfloat n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n\t\t\t\t\tfloat n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n\t\t\t\t\tfloat n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n\t\t\t\t\tfloat n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n\t\t\t\t\tfloat n111 = dot(g111, Pf1);\n\n\t\t\t\t\tvec3 fade_xyz = fade(Pf0);\n\t\t\t\t\tvec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n\t\t\t\t\tvec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n\t\t\t\t\tfloat n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n\t\t\t\t\treturn 2.2 * n_xyz;\n\t\t\t\t}\n\n\t\t\t\tfloat surface3 (vec3 coord )\n\t\t\t\t{\n\t\t\t\t\tfloat n = 0.0;\n\n\t\t\t\t\tn += 1.0 * abs(cnoise(coord * frequency));\n\t\t\t\t\tn += 0.5 * abs(cnoise(coord * frequency * 2.0));\n\t\t\t\t\tn += 0.25 * abs(cnoise(coord * frequency * 3.0));\n\n\t\t\t\t\treturn n;\n\t\t\t\t}\n\n\t\t\t\tvoid main(void )\n\t\t\t\t{\n\t\t\t\t\tvec2 position = gl_FragCoord.xy / resolution.xy;\n\n\t\t\t\t\tfloat n = surface3(vec3(position, timeConst * period * 0.1)) * amplitude;\n\n\t\t\t\t\tgl_FragColor = vec4(n, n, n, 1.0);\n\t\t\t\t\tgl_FragColor.rgb *= color;\n\t\t\t\t}\n\t\t\t";
        };
        Object.defineProperty(MaterialSobel.prototype, "color", {
            /**
            * Gets the color
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['color'].value; },
            /**
            * Sets the color
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('color', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialSobel.prototype, "amplitude", {
            /**
            * Gets the amplitude of the filter
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['amplitude'].value; },
            /**
            * Sets the amplitude of the filter
            * @param {number} val
            */
            set: function (val) {
                this.materials[Trike.PassType.Texture].setUniform('amplitude', val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialSobel.prototype, "frequency", {
            /**
            * Gets the frequency of the filter
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['frequency'].value; },
            /**
            * Sets the frequency of the filter
            * @param {number} val
            */
            set: function (val) {
                this.materials[Trike.PassType.Texture].setUniform('frequency', val);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialSobel.prototype, "period", {
            /**
            * Gets the period of the filter
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['period'].value; },
            /**
            * Sets the period of the filter
            * @param {number} val
            */
            set: function (val) {
                this.materials[Trike.PassType.Texture].setUniform('period', val);
            },
            enumerable: true,
            configurable: true
        });
        return MaterialSobel;
    }(Trike.MaterialMulti));
    Trike.MaterialSobel = MaterialSobel;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Draws a cell like material
    */
    var MaterialCells = (function (_super) {
        __extends(MaterialCells, _super);
        /**
        * Creates an instance of the shader
        * @param {number} width The width of the texture
        * @param {number} height The height of the texture
        */
        function MaterialCells(width, height) {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Texture] = new Trike.PassMaterial('Cells', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('timeConst', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('resolution', Trike.UniformType.FLOAT2, new Trike.Vec2(width, height)), true);
            this.addUniform(new Trike.UniformVar('color', Trike.UniformType.COLOR3, new Trike.Color(0xffffff), true));
            this.addUniform(new Trike.UniformVar('frequency', Trike.UniformType.FLOAT, 10), true);
            this.addUniform(new Trike.UniformVar('period', Trike.UniformType.FLOAT, 1.0), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialCells.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialCells.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\tuniform float timeConst;\n\t\t\t\tuniform vec3 color;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tuniform float period;\n\t\t\t\tuniform float frequency;\n\n\t\t\t\t// animated voronoi texture\n\t\t\t\t// thank you internet for this random function\n\t\t\t\tvec2 rand22(in vec2 p)\n\t\t\t\t{\n\t\t\t\t\treturn fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n\t\t\t\t}\n\n\t\t\t\t// i just faked the vec3 version frin the one above by adding random numbers, no idea if it's 'correct'\n\t\t\t\tvec3 rand33(in vec3 p)\n\t\t\t\t{\n\t\t\t\t\treturn fract(vec3(sin(p.x * 591.32 + p.y * 154.077 + p.z * 712.223), cos(p.x * 391.32 + p.y * 49.077 + p.z * 401.326), cos(p.x * 1010.22 + p.y * 27.311 + p.z * 131.44)));\n\t\t\t\t}\n\n\t\t\t\tfloat dst(vec3 r)\n\t\t\t\t{\n\t\t\t\t\t// return max(abs(r.x), abs(r.y));\n\t\t\t\t\treturn length(r);\n\t\t\t\t}\n\n\t\t\t\tvec3 voronoi(in vec3 x)\n\t\t\t\t{\n\t\t\t\t\tvec3 n = floor(x); // grid cell id\n\t\t\t\t\tvec3 f = fract(x); // grid internal position\n\t\t\t\t\tvec3 mg; // shortest distance...\n\t\t\t\t\tvec3 mr; // ..and second shortest distance\n\t\t\t\t\tfloat md = 5.0, md2 = 1.0;\n\t\t\t\t\tfor(int j = -1; j <= 1; j ++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int i = -1; i <= 1; i ++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor(int k = -1; k <= 1; k ++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvec3 g = vec3(float(i), float(j), float(k)); // cell id\n\t\t\t\t\t\t\t\tvec3 o = rand33(n + g); // offset to edge point\n\t\t\t\t\t\t\t\tvec3 r = g + o - f;\n\n\t\t\t\t\t\t\t\tfloat d = dst(r); // distance to the edge\n\n\t\t\t\t\t\t\t\tif(d < md)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmd2 = md; md = d;\n\t\t\t\t\t\t\t\t\tmr = r; mg = g;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if(d < md2)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmd2 = d;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn vec3((n + mg).xy, md);\n\t\t\t\t}\n\n\t\t\t\tvoid main(void )\n\t\t\t\t{\n\t\t\t\t\tvec2 position = (gl_FragCoord.xy / resolution.xy);\n\t\t\t\t\tgl_FragColor = vec4(vec3(voronoi(vec3(position * frequency, timeConst * period )).z), 1.0);\n\t\t\t\t\tgl_FragColor.rgb = (vec3(1.0, 1.0, 1.0) - gl_FragColor.rgb) * color;\n\t\t\t\t}\n\t\t\t";
        };
        Object.defineProperty(MaterialCells.prototype, "color", {
            /**
            * Gets the color
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['color'].value; },
            /**
            * Sets the color
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('color', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialCells.prototype, "period", {
            /**
            * Gets the period
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['period'].value; },
            /**
            * Sets the period
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('period', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialCells.prototype, "frequency", {
            /**
            * Gets the frequency
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['frequency'].value; },
            /**
            * Sets the frequency
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('frequency', val); },
            enumerable: true,
            configurable: true
        });
        return MaterialCells;
    }(Trike.MaterialMulti));
    Trike.MaterialCells = MaterialCells;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Draws a liquid effect that's good for water or caustics
    * See http://glslsandbox.com/e#21272.0
    */
    var MaterialLiquid = (function (_super) {
        __extends(MaterialLiquid, _super);
        function MaterialLiquid() {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Texture] = new Trike.PassMaterial('Liquid', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('timeConst', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('frequency', Trike.UniformType.FLOAT, 50), true);
            this.addUniform(new Trike.UniformVar('color', Trike.UniformType.COLOR3, new Trike.Color(0xffffff), true));
            this.addUniform(new Trike.UniformVar('period', Trike.UniformType.FLOAT, 1.0), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            this.addAttribute(new Trike.AttributeVar('surface', Trike.AttributeType.SURFACE));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialLiquid.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 surface;\n\t\t\t\tvarying vec2 vSurface;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tvSurface = surface;\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialLiquid.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\tvarying vec2 vSurface;\n\t\t\t\tuniform vec3 color;\n\t\t\t\tuniform float timeConst;\n\t\t\t\tuniform float frequency;\n\t\t\t\tuniform float period;\n\n\n\t\t\t\t#define MAX_ITER 16\n\n\t\t\t\t" + Trike.ShaderFragments.FragParams.saturate() + "\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tvec2 sp = vSurface * frequency;//vec2(.4, .7);\n\t\t\t\t\tfloat timeC = (timeConst + sp.x) * period;\n\t\t\t\t\tvec2 p = sp * 6.0 - vec2(125.0);\n\t\t\t\t\tvec2 i = p;\n\t\t\t\t\tfloat c = 1.0;\n\n\t\t\t\t\tfloat inten = 0.01;\n\n\t\t\t\t\tfloat nor = float(MAX_ITER);\n\n\t\t\t\t\tfor (int n = 0; n < MAX_ITER; n++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat nth = float(n) / nor;\n\t\t\t\t\t\tfloat t = timeC / 10.0 * (1.0 - (3.0 / float(n + 1))) + ((2. + 4. * nth) * timeC * .33);\n\t\t\t\t\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\t\t\t\t\tc += 1.0 / length(vec2(p.x / (sin(i.x + t + timeC * .02) / inten), p.y / (cos(i.y + t - timeC * .021) / inten)));\n\t\t\t\t\t}\n\n\t\t\t\t\tc /= pow(float(MAX_ITER), 0.777);\n\t\t\t\t\tc = 1.5 - sqrt(c);\n\t\t\t\t\tgl_FragColor = vec4(vec3(c * c * c * c), 999.0) + vec4(0.0, 0.3, 0.5, 4.0);\n\t\t\t\t\tgl_FragColor.rgb = saturate( gl_FragColor.rgb, 0.0 ) * color;\n\t\t\t\t}\n\t\t\t";
        };
        Object.defineProperty(MaterialLiquid.prototype, "frequency", {
            /**
            * Gets the frequency
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['frequency'].value; },
            /**
            * Sets the frequency
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('frequency', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialLiquid.prototype, "color", {
            /**
            * Gets the color
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['color'].value; },
            /**
            * Sets the color
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('color', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialLiquid.prototype, "period", {
            /**
            * Gets the period
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['period'].value; },
            /**
            * Sets the period
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('period', val); },
            enumerable: true,
            configurable: true
        });
        return MaterialLiquid;
    }(Trike.MaterialMulti));
    Trike.MaterialLiquid = MaterialLiquid;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Draws a rain effect
    * See http://glslsandbox.com/e#17716.0
    */
    var MaterialRain = (function (_super) {
        __extends(MaterialRain, _super);
        /**
        * Creates an instance of the shader
        * @param {number} width The width of the texture
        * @param {number} height The height of the texture
        */
        function MaterialRain(width, height) {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Texture] = new Trike.PassMaterial('Rain', this);
            this._dropDensity = 0;
            this._dropThickness = 0;
            this._dropLength = 0;
            this._dropFallFactor = 0;
            this._dropFallSpeed = 0;
            this.dropDensity = 10.0;
            this.dropThickness = 1.0;
            this.dropLength = 1.0;
            this.dropFallFactor = 3.0;
            this.dropFallSpeed = 1.0;
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('timeConst', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('resolution', Trike.UniformType.FLOAT2, new Trike.Vec2(width, height)), true);
            this.addUniform(new Trike.UniformVar('color', Trike.UniformType.COLOR3, new Trike.Color(0xffffff), true));
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialRain.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialRain.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\tuniform float timeConst;\n\t\t\t\tuniform vec3 color;\n\t\t\t\tuniform vec2 resolution;\n\n\t\t\t\tfloat rand(vec2 co)\n\t\t\t\t{\n\t\t\t\t\treturn fract(sin(dot(co.xy, vec2(1.9898, 40.233))) * 6.5453);\n\t\t\t\t}\n\n\t\t\t\tfloat chr(vec2 outer, vec2 inner)\n\t\t\t\t{\n\t\t\t\t\tvec2 seed = floor(inner * 90.0) + outer.y;\n\t\t\t\t\tif (rand(vec2(outer.y, 4.0)) > 0.98)\n\t\t\t\t\tseed += floor((timeConst + rand(vec2(outer.y, 5.0))) * 1.0);\n\n\t\t\t\t\treturn float(rand(seed) > .2);\n\t\t\t\t}\n\n\t\t\t\tvoid main( void )\n\t\t\t\t{\n\t\t\t\t\tvec2 position = gl_FragCoord.xy / resolution.xy;\n\t\t\t\t\tposition.y /= resolution.x / resolution.y;\n\n\t\t\t\t\tfloat rx = gl_FragCoord.x / DROP_THICKNESS;\n\t\t\t\t\tfloat mx = mod(gl_FragCoord.x, 10.1);\n\t\t\t\t\tif (mx > DROP_DENSITY)\n\t\t\t\t\t\tgl_FragColor = vec4(0);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat x = floor(rx);\n\t\t\t\t\t\tfloat ry = gl_FragCoord.y + timeConst * rand(vec2(x, 23.0)) * 220.0 * DROP_FALL_SPEED;\n\t\t\t\t\t\tfloat my = mod(ry, 5.20);\n\t\t\t\t\t\tif (my > DROP_FALL_FACTOR)\n\t\t\t\t\t\t\tgl_FragColor = vec4(0);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfloat y = floor(ry / DROP_LENGTH);\n\t\t\t\t\t\t\tfloat b = chr(vec2(rx, floor((ry) / 15.0)), vec2(mx, my) / 12.0);\n\t\t\t\t\t\t\tfloat col = max(mod(-y, 60.0) - 0.0, 9.0) / 49.0;\n\t\t\t\t\t\t\tvec3 c = col < 0.2 ? vec3(0.0, col / 10.8, 0.0) : mix(vec3(0.0, 0.0, 0.0), vec3(1.0), (col - 0.9) / 0.4);\n\t\t\t\t\t\t\tgl_FragColor = vec4(c * b * color, 1.0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor.w = 1.0;\n\t\t\t\t}\n\t\t\t";
        };
        Object.defineProperty(MaterialRain.prototype, "dropDensity", {
            /**
            * Gets the drop density. Values from 1 to 10 are good
            * @returns {number}
            */
            get: function () { return this._dropDensity; },
            /**
            * Sets the drop density. Values from 1 to 10 are good
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define DROP_DENSITY ' + this._dropDensity.toFixed(3));
                this._dropDensity = val;
                this.addDefine('#define DROP_DENSITY ' + this._dropDensity.toFixed(3));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialRain.prototype, "color", {
            /**
            * Gets the drop color
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['color'].value; },
            /**
            * Sets the drop color
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('color', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialRain.prototype, "dropThickness", {
            /**
            * Gets the drop thickness
            * @returns {number}
            */
            get: function () { return this._dropThickness; },
            /**
            * Sets the drop thickness
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define DROP_THICKNESS ' + this._dropThickness.toFixed(3));
                this._dropThickness = val;
                this.addDefine('#define DROP_THICKNESS ' + this._dropThickness.toFixed(3));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialRain.prototype, "dropLength", {
            /**
            * Gets the drop length
            * @returns {number}
            */
            get: function () { return this._dropLength; },
            /**
            * Sets the drop length
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define DROP_LENGTH ' + this._dropLength.toFixed(3));
                this._dropLength = val;
                this.addDefine('#define DROP_LENGTH ' + this._dropLength.toFixed(3));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialRain.prototype, "dropFallFactor", {
            /**
            * Gets the drop fall factor. Lower values create snow like effects
            * @returns {number}
            */
            get: function () { return this._dropFallFactor; },
            /**
            * Sets the drop fall factor. Lower values create snow like effects
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define DROP_FALL_FACTOR ' + this._dropFallFactor.toFixed(3));
                this._dropFallFactor = val;
                this.addDefine('#define DROP_FALL_FACTOR ' + this._dropFallFactor.toFixed(3));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialRain.prototype, "dropFallSpeed", {
            /**
            * Gets the drop fall speed
            * @returns {number}
            */
            get: function () { return this._dropFallSpeed; },
            /**
            * Sets the drop fall speed
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define DROP_FALL_SPEED ' + this._dropFallSpeed.toFixed(3));
                this._dropFallSpeed = val;
                this.addDefine('#define DROP_FALL_SPEED ' + this._dropFallSpeed.toFixed(3));
            },
            enumerable: true,
            configurable: true
        });
        return MaterialRain;
    }(Trike.MaterialMulti));
    Trike.MaterialRain = MaterialRain;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * White glowing beams that look like a power up
    * See http://glslsandbox.com/e#17459.0
    * KSHIRO51
    */
    var MaterialPowerUp = (function (_super) {
        __extends(MaterialPowerUp, _super);
        /**
        * Creates an instance of the shader
        * @param {number} width The width of the texture
        * @param {number} height The height of the texture
        */
        function MaterialPowerUp() {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Texture] = new Trike.PassMaterial('Power up', this);
            this._glowStrength = 0;
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('timeConst', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('color', Trike.UniformType.COLOR3, new Trike.Color(0xffffff), true));
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            this.addAttribute(new Trike.AttributeVar('surface', Trike.AttributeType.SURFACE));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialPowerUp.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 surface;\n\t\t\t\tvarying vec2 vSurface;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tvSurface = surface;\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialPowerUp.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\tvarying vec2 vSurface;\n\t\t\t\tuniform float timeConst;\n\t\t\t\tuniform vec3 color;\n\n\t\t\t\tvoid main(void)\n\t\t\t\t{\n\t\t\t\t\tfloat c = 0.0;\n\t\t\t\t\tc += GLOW_STRENGTH / clamp(length(vSurface), 0.15, 1.0);\n\t\t\t\t\tc += 0.015 / (length(vSurface));\n\t\t\t\t\tc += 0.005 / (length(vSurface + vec2(+sin(timeConst * 2.0), 0.0) * 0.5)); //derecha\n\t\t\t\t\tc += 0.005 / (length(vSurface + vec2(0.0, -sin(timeConst * 2.0)) * 0.5)); //arriba\n\t\t\t\t\tc += 0.005 / (length(vSurface + vec2(sin(timeConst * 2.0), 0.0) * 0.5)); //izquierda\n\t\t\t\t\tc += 0.005 / (length(vSurface + vec2(0.0, sin(timeConst * 2.0)) * 0.5)); //abajo\n\t\t\t\t\tc += 0.013 / (length(vSurface.x - vSurface.y));\n\t\t\t\t\tc += 0.013 / (length(vSurface.x + vSurface.y));\n\t\t\t\t\tc += 0.020 / (length(vSurface + vec2(-sin(timeConst * 2.0), -sin(timeConst * 2.0)) * 0.5)); //izquierda abajo\n\t\t\t\t\tc += 0.020 / (length(vSurface + vec2(sin(timeConst * 2.0), -sin(timeConst * 2.0)) * 0.5)); //derecha abajo\n\t\t\t\t\tc += 0.010 / (length(vSurface + vec2(sin(timeConst * 2.0), sin(timeConst * 2.0)) * 0.5)); //derecha arriba\n\t\t\t\t\tc += 0.010 / (length(vSurface + vec2(-sin(timeConst * 2.0), sin(timeConst * 2.0)) * 0.5)); //izquierda arriba\n\t\t\t\t\tgl_FragColor =  vec4(color * vec3(c, c, c) * vec3(0.8, 0.75, 1.0), 1.0);\n\t\t\t\t}\n\t\t\t";
        };
        Object.defineProperty(MaterialPowerUp.prototype, "color", {
            /**
            * Gets the drop color
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['color'].value; },
            /**
            * Sets the drop color
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('color', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialPowerUp.prototype, "glowStrength", {
            /**
            * Gets the glow strength of the beam
            * @returns {number}
            */
            get: function () { return this._glowStrength; },
            /**
            * Sets the glow strength of the beam
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define GLOW_STRENGTH ' + this._glowStrength.toFixed(3));
                this._glowStrength = val;
                this.addDefine('#define GLOW_STRENGTH ' + this._glowStrength.toFixed(3));
            },
            enumerable: true,
            configurable: true
        });
        return MaterialPowerUp;
    }(Trike.MaterialMulti));
    Trike.MaterialPowerUp = MaterialPowerUp;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    (function (TechnoType) {
        TechnoType[TechnoType["Circuit"] = 0] = "Circuit";
        TechnoType[TechnoType["Organic"] = 1] = "Organic";
    })(Trike.TechnoType || (Trike.TechnoType = {}));
    var TechnoType = Trike.TechnoType;
    /**
    * Draws a matrix / electric effect
    * See http://glslsandbox.com/e#18217.0
    */
    var MaterialTechno = (function (_super) {
        __extends(MaterialTechno, _super);
        /**
        * Creates an instance of the shader
        * @param {number} width The width of the texture
        * @param {number} height The height of the texture
        */
        function MaterialTechno(width, height) {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Texture] = new Trike.PassMaterial('Techno', this);
            this._intensity = 0;
            this._numOctaves = 0;
            this._bluriness = 0;
            this._frequency = 0;
            this._type = TechnoType.Circuit;
            this.intensity = 0.6;
            this.numOctaves = 3.0;
            this.bluriness = 0.3;
            this.frequency = 3.0;
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('timeConst', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('resolution', Trike.UniformType.FLOAT2, new Trike.Vec2(width, height)), true);
            this.addUniform(new Trike.UniformVar('color', Trike.UniformType.COLOR3, new Trike.Color(0xffffff), true));
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialTechno.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialTechno.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\tuniform float timeConst;\n\t\t\t\tuniform vec3 color;\n\t\t\t\tuniform vec2 resolution;\n\n\t\t\t\t// rotate position around axis\n\t\t\t\tvec2 rotate(vec2 p, float a)\n\t\t\t\t{\n\t\t\t\t\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n\t\t\t\t}\n\n\t\t\t\t// 1D random numbers\n\t\t\t\tfloat rand(float n)\n\t\t\t\t{\n\t\t\t\t\treturn fract(sin(n) * 43758.5453123);\n\t\t\t\t}\n\n\t\t\t\t// 2D random numbers\n\t\t\t\tvec2 rand2(in vec2 p)\n\t\t\t\t{\n\t\t\t\t\t#ifdef CIRCUIT\n\t\t\t\t\t\treturn fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\n\t\t\t\t\t#else\n\t\t\t\t\t\treturn fract(vec2(sin(p.x * 274.32 + p.y * 454.077 + timeConst), cos(p.x * 191.32 + p.y * 490.077 + timeConst)));\n\t\t\t\t\t#endif\n\t\t\t\t}\n\n\t\t\t\t// 1D noise\n\t\t\t\tfloat noise1(float p)\n\t\t\t\t{\n\t\t\t\t\tfloat fl = floor(p);\n\t\t\t\t\tfloat fc = fract(p);\n\t\t\t\t\treturn mix(rand(fl), rand(fl + 1.0), fc);\n\t\t\t\t}\n\n\t\t\t\t// voronoi distance noise, based on iq's articles\n\t\t\t\tfloat voronoi(in vec2 x)\n\t\t\t\t{\n\t\t\t\t\tvec2 p = floor(x);\n\t\t\t\t\tvec2 f = fract(x);\n\n\t\t\t\t\tvec2 res = vec2(9.0);\n\t\t\t\t\tfor(int j = -1; j <= 1; j ++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int i = -1; i <= 1; i ++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec2 b = vec2(i, j);\n\t\t\t\t\t\t\tvec2 r = vec2(b) - f + rand2(p + b);\n\n\t\t\t\t\t\t\t// chebyshev distance, one of many ways to do this\n\t\t\t\t\t\t\tfloat d = max(abs(r.x), abs(r.y));\n\n\t\t\t\t\t\t\tif(d < res.x)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tres.y = res.x;\n\t\t\t\t\t\t\t\tres.x = d;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(d < res.y)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tres.y = d;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn res.y - res.x;\n\t\t\t\t}\n\n\t\t\t\tfloat flicker = noise1(timeConst * 1.0) * 0.8 + 0.;\n\n\t\t\t\tvoid main(void)\n\t\t\t\t{\n\t\t\t\t\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\t\t\t\t\tuv = (uv - 0.5) * 2.0;\n\t\t\t\t\tvec2 suv = uv;\n\t\t\t\t\tuv.x *= resolution.x / resolution.y;\n\t\t\t\t\tfloat v = 0.0;\n\t\t\t\t\tuv = rotate(uv, sin(0.0 * 0.3) * 1.0);\n\n\t\t\t\t\t// add some noise octaves\n\t\t\t\t\tfloat a = INTENSITY, f = 1.0;\n\n\t\t\t\t\tfor (int i = 0; i < NUM_OCTAVES; i++) // 4 octaves also look nice, its getting a bit slow though\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat v1 = voronoi(uv * f + 5.0);\n\t\t\t\t\t\tfloat v2 = 0.0;\n\n\t\t\t\t\t\t// make the moving electrons-effect for higher octaves\n\t\t\t\t\t\tif (i > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// of course everything based on voronoi\n\t\t\t\t\t\t\tv2 = voronoi(uv * f * 0.5 + 50.0 + timeConst);\n\n\t\t\t\t\t\t\tfloat va = 0.0, vb = 0.0;\n\t\t\t\t\t\t\tva = 1.0 - smoothstep(0.0, 0.11, v1);\n\t\t\t\t\t\t\t#ifdef CIRCUIT\n\t\t\t\t\t\t\tvb = 1.0 - smoothstep(0.0, 0.09, v2);\n\t\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tvb = 1.0 - smoothstep(0.0, 0.98, v2);\n\t\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t\tv += a * pow(va * (0.5 + vb), 2.0);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// make sharp edges\n\t\t\t\t\t\tv1 = 1.0 - smoothstep(0.0, BLURINESS, v1);\n\n\t\t\t\t\t\t// noise is used as intensity map\n\t\t\t\t\t\tv2 = a * (noise1(v1 * 5.5 + 0.1));\n\n\t\t\t\t\t\t// octave 0's intensity changes a bit\n\t\t\t\t\t\tif (i === 0)\n\t\t\t\t\t\t\tv += v2 * flicker;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tv += v2;\n\n\t\t\t\t\t\tf *= FREQUENCY;\n\t\t\t\t\t\ta *= 0.7;\n\t\t\t\t\t}\n\n\t\t\t\t\t// slight vignetting\n\t\t\t\t\tv *= exp(-0.6 * length(suv)) * 1.2;\n\n\t\t\t\t\t// old blueish color set\n\t\t\t\t\tvec3 cexp = vec3(1.0, 1.0, 1.0);\n\t\t\t\t\tcexp *= 1.3;\n\n\t\t\t\t\tvec3 col = vec3(pow(v, cexp.x), pow(v, cexp.y), pow(v, cexp.z)) * 2.0;\n\t\t\t\t\tcol *= color;\n\n\t\t\t\t\tgl_FragColor = vec4(col, 1.0);\n\t\t\t\t}\n\t\t\t";
        };
        Object.defineProperty(MaterialTechno.prototype, "color", {
            /**
            * Gets the drop color
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['color'].value; },
            /**
            * Sets the drop color
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('color', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialTechno.prototype, "type", {
            /**
            * Gets the frequency
            * @returns {TechnoType}
            */
            get: function () { return this._type; },
            /**
            * Sets the frequency
            * @param {TechnoType} val
            */
            set: function (val) {
                this.removeDefine('#define CIRCUIT');
                this._type = val;
                if (val === TechnoType.Circuit)
                    this.addDefine('#define CIRCUIT');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialTechno.prototype, "frequency", {
            /**
            * Gets the frequency
            * @returns {number}
            */
            get: function () { return this._frequency; },
            /**
            * Sets the frequency
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define FREQUENCY ' + this._frequency.toFixed(3));
                this._frequency = val;
                this.addDefine('#define FREQUENCY ' + this._frequency.toFixed(3));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialTechno.prototype, "bluriness", {
            /**
            * Gets the bluriness
            * @returns {number}
            */
            get: function () { return this._bluriness; },
            /**
            * Sets the bluriness
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define BLURINESS ' + this._bluriness.toFixed(3));
                this._bluriness = val;
                this.addDefine('#define BLURINESS ' + this._bluriness.toFixed(3));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialTechno.prototype, "numOctaves", {
            /**
            * Gets the number of octaves to use. Should not go over 4. Ideally 3
            * @returns {number}
            */
            get: function () { return this._numOctaves; },
            /**
            * Sets the number of octaves to use. Should not go over 4. Ideally 3
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define NUM_OCTAVES ' + this._numOctaves.toFixed(0));
                this._numOctaves = val;
                this.addDefine('#define NUM_OCTAVES ' + this._numOctaves.toFixed(0));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialTechno.prototype, "intensity", {
            /**
            * Gets the intensity of the techno lines
            * @returns {number}
            */
            get: function () { return this._intensity; },
            /**
            * Sets the intensity of the techno lines
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define INTENSITY ' + this._intensity.toFixed(3));
                this._intensity = val;
                this.addDefine('#define INTENSITY ' + this._intensity.toFixed(3));
            },
            enumerable: true,
            configurable: true
        });
        return MaterialTechno;
    }(Trike.MaterialMulti));
    Trike.MaterialTechno = MaterialTechno;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Draws a matrix / electric effect
    * See http://glslsandbox.com/e#16402.0
    */
    var MaterialSinWaves = (function (_super) {
        __extends(MaterialSinWaves, _super);
        /**
        * Creates an instance of the shader
        * @param {number} width The width of the texture
        * @param {number} height The height of the texture
        */
        function MaterialSinWaves(width, height) {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Texture] = new Trike.PassMaterial('Sin Waves', this);
            this._intensity = 0;
            this._amplitude = 0;
            this._waveCount = 0;
            this._frequency = 0;
            this.amplitude = 0.055;
            this.waveCount = 7.0;
            this.frequency = 2.0;
            this.intensity = 3.0;
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('timeConst', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('resolution', Trike.UniformType.FLOAT2, new Trike.Vec2(width, height)), true);
            this.addUniform(new Trike.UniformVar('color', Trike.UniformType.COLOR3, new Trike.Color(0xffffff), true));
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialSinWaves.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialSinWaves.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\tuniform float timeConst;\n\t\t\t\tuniform vec3 color;\n\t\t\t\tuniform vec2 resolution;\n\n\t\t\t\tfloat rand(vec2 co)\n\t\t\t\t{\n\t\t\t\t\treturn fract(sin(dot(co.xy, vec2(12.98, 78.233))) * 43758.5453);\n\t\t\t\t}\n\n\t\t\t\t" + Trike.ShaderFragments.FragParams.saturate() + "\n\n\t\t\t\tvoid main(void )\n\t\t\t\t{\n\t\t\t\t\tvec2 pos = gl_FragCoord.xy / resolution.xy;\n\t\t\t\t\tvec2 uPos = pos;\n\t\t\t\t\tuPos.y -= 0.5;\n\n\t\t\t\t\tvec3 c = vec3(0.0);\n\t\t\t\t\tfloat vertColor = 0.0;\n\t\t\t\t\tconst float k = NUM_WAVES;\n\t\t\t\t\tfor(float i = 1.0; i < k; ++i )\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat t = timeConst * FREQUENCY;\n\n\t\t\t\t\t\tuPos.y += sin(uPos.x * exp(i) - t) * AMPLITUDE;\n\t\t\t\t\t\tfloat fTemp = abs(1.0 / (80.0 * k) / uPos.y);\n\t\t\t\t\t\tvertColor += fTemp;\n\t\t\t\t\t\tc += vec3(fTemp * (i * INTENSITY), 0.0, cos(vertColor) * sin(fTemp));\n\t\t\t\t\t}\n\n\t\t\t\t\tvec4 color_final = vec4( saturate(c, 0.0), 1.0);\n\t\t\t\t\tgl_FragColor = color_final;\n\t\t\t\t\tfloat ft = fract(timeConst);\n\t\t\t\t\tgl_FragColor.rgb *= color;\n\t\t\t\t}\n\n\t\t\t";
        };
        Object.defineProperty(MaterialSinWaves.prototype, "color", {
            /**
            * Gets the color
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['color'].value; },
            /**
            * Sets the color
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('color', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialSinWaves.prototype, "amplitude", {
            /**
            * Gets the amplitude
            * @returns {number}
            */
            get: function () { return this._amplitude; },
            /**
            * Sets the amplitude
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define AMPLITUDE ' + this._amplitude.toFixed(3));
                this._amplitude = val;
                this.addDefine('#define AMPLITUDE ' + this._amplitude.toFixed(3));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialSinWaves.prototype, "frequency", {
            /**
            * Gets the frequency
            * @returns {number}
            */
            get: function () { return this._frequency; },
            /**
            * Sets the frequency
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define FREQUENCY ' + this._frequency.toFixed(3));
                this._frequency = val;
                this.addDefine('#define FREQUENCY ' + this._frequency.toFixed(3));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialSinWaves.prototype, "waveCount", {
            /**
            * Gets the number of waves
            * @returns {number}
            */
            get: function () { return this._waveCount; },
            /**
            * Sets the number of waves
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define NUM_WAVES ' + this._waveCount.toFixed(1));
                this._waveCount = val;
                this.addDefine('#define NUM_WAVES ' + this._waveCount.toFixed(1));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialSinWaves.prototype, "intensity", {
            /**
            * Gets the intensity
            * @returns {number}
            */
            get: function () { return this._intensity; },
            /**
            * Sets the intensity
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define INTENSITY ' + this._intensity.toFixed(3));
                this._intensity = val;
                this.addDefine('#define INTENSITY ' + this._intensity.toFixed(3));
            },
            enumerable: true,
            configurable: true
        });
        return MaterialSinWaves;
    }(Trike.MaterialMulti));
    Trike.MaterialSinWaves = MaterialSinWaves;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Draws a flowing electric pattern
    * See http://glslsandbox.com/e#18940.3
    */
    var MaterialVoltWaves = (function (_super) {
        __extends(MaterialVoltWaves, _super);
        /**
        * Creates an instance of the shader
        * @param {number} width The width of the texture
        * @param {number} height The height of the texture
        */
        function MaterialVoltWaves(width, height) {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Texture] = new Trike.PassMaterial('Volt Waves', this);
            this._intensity = 0;
            this._waveCount = 0;
            this._period = 0;
            this._amplitude = 0;
            this.waveCount = 2.0;
            this.period = 1.0;
            this.intensity = 2.0;
            this.amplitude = 0.5;
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('timeConst', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('resolution', Trike.UniformType.FLOAT2, new Trike.Vec2(width, height)), true);
            this.addUniform(new Trike.UniformVar('color', Trike.UniformType.COLOR3, new Trike.Color(0xffffff), true));
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialVoltWaves.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialVoltWaves.prototype.getFragmentShader = function () {
            return "\n\t\t\t\tuniform float timeConst;\n\t\t\t\tuniform vec3 color;\n\t\t\t\tuniform vec2 resolution;\n\n\t\t\t\tvoid main(void )\n\t\t\t\t{\n\t\t\t\t\tvec2 p = (gl_FragCoord.xy / resolution.xy) * 2.0 - 1.0;\n\t\t\t\t\tvec3 c = vec3(0.0);\n\t\t\t\t\tfloat amplitude = AMPLITUDE;\n\t\t\t\t\tfloat t = timeConst * PERIOD;\n\t\t\t\t\tfloat glowT = sin(t) * 0.5 + 0.5;\n\t\t\t\t\tfloat glowFactor = mix(0.15, 0.35, glowT) * INTENSITY;\n\n\t\t\t\t\tfor (float i = 0.0; i < NUM_WAVES; i++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tc += vec3(0.02, 0.03, 0.13) * (glowFactor * abs(1.0 / sin(p.x + sin(p.y + t + i) * amplitude + i * 0.1)));\n\t\t\t\t\t\tc += vec3(0.02, 0.03, 0.13) * (glowFactor * abs(1.0 / sin(p.y + sin(p.x + t + i) * amplitude + i * 0.1)));\n\t\t\t\t\t}\n\t\t\t\t\tc *= color;\n\t\t\t\t\tgl_FragColor = vec4(c, 1.0);\n\t\t\t\t}\n\t\t\t";
        };
        Object.defineProperty(MaterialVoltWaves.prototype, "color", {
            /**
            * Gets the color
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['color'].value; },
            /**
            * Sets the color
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('color', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialVoltWaves.prototype, "period", {
            /**
            * Gets the period
            * @returns {number}
            */
            get: function () { return this._period; },
            /**
            * Sets the period
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define PERIOD ' + this._period.toFixed(3));
                this._period = val;
                this.addDefine('#define PERIOD ' + this._period.toFixed(3));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialVoltWaves.prototype, "waveCount", {
            /**
            * Gets the number of waves
            * @returns {number}
            */
            get: function () { return this._waveCount; },
            /**
            * Sets the number of waves
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define NUM_WAVES ' + this._waveCount.toFixed(1));
                this._waveCount = val;
                this.addDefine('#define NUM_WAVES ' + this._waveCount.toFixed(1));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialVoltWaves.prototype, "intensity", {
            /**
            * Gets the intensity
            * @returns {number}
            */
            get: function () { return this._intensity; },
            /**
            * Sets the intensity
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define INTENSITY ' + this._intensity.toFixed(3));
                this._intensity = val;
                this.addDefine('#define INTENSITY ' + this._intensity.toFixed(3));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialVoltWaves.prototype, "amplitude", {
            /**
            * Gets the amplitude
            * @returns {number}
            */
            get: function () { return this._amplitude; },
            /**
            * Sets the amplitude
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define AMPLITUDE ' + this._amplitude.toFixed(3));
                this._amplitude = val;
                this.addDefine('#define AMPLITUDE ' + this._amplitude.toFixed(3));
            },
            enumerable: true,
            configurable: true
        });
        return MaterialVoltWaves;
    }(Trike.MaterialMulti));
    Trike.MaterialVoltWaves = MaterialVoltWaves;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Draws an electric circuite board
    * See http://glslsandbox.com/e#18940.3
    */
    var MaterialCircuit = (function (_super) {
        __extends(MaterialCircuit, _super);
        /**
        * Creates an instance of the shader
        * @param {number} width The width of the texture
        * @param {number} height The height of the texture
        */
        function MaterialCircuit(width, height) {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Texture] = new Trike.PassMaterial('Circuit', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('timeConst', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('resolution', Trike.UniformType.FLOAT2, new Trike.Vec2(width, height)), true);
            this.addUniform(new Trike.UniformVar('color', Trike.UniformType.COLOR3, new Trike.Color(0xffffff), true));
            this.addUniform(new Trike.UniformVar('boardSpeed', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('frequency', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('intensity', Trike.UniformType.FLOAT, 5), true);
            this.addUniform(new Trike.UniformVar('period', Trike.UniformType.FLOAT, 1.0), true);
            this.addUniform(new Trike.UniformVar('boardColor', Trike.UniformType.COLOR3, new Trike.Color(0xcccccc), true));
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialCircuit.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialCircuit.prototype.getFragmentShader = function () {
            return "\n\n\t\t\tuniform float timeConst;\n\t\t\tuniform vec3 color;\n\t\t\tuniform vec3 boardColor;\n\t\t\tuniform vec2 resolution;\n\t\t\tuniform float period;\n\t\t\tuniform float frequency;\n\t\t\tuniform float boardSpeed;\n\t\t\tuniform float intensity;\n\n\t\t\t#define PI 3.1415926535897932384626433832795\n\t\t\t#define float2 vec2\n\t\t\t#define float3 vec3\n\t\t\t#define float4 vec4\n\n\n\t\t\tfloat2 circuit(float2 p)\n\t\t\t{\n\t\t\t\tp = fract(p);\n\t\t\t\tfloat r = 0.123;\n\t\t\t\tfloat v = 0.0, g = 0.0;\n\t\t\t\tr = fract(r * 9184.928);\n\t\t\t\tfloat cp, d;\n\n\t\t\t\td = p.x;\n\t\t\t\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 1000.0);\n\t\t\t\td = p.y;\n\t\t\t\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 1000.0);\n\t\t\t\td = p.x - 1.0;\n\t\t\t\tg += pow(clamp(3.0 - abs(d), 0.0, 1.0), 1000.0);\n\t\t\t\td = p.y - 1.0;\n\t\t\t\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 10000.0);\n\n\t\t\t\tconst int iter = 12;\n\t\t\t\tfor(int i = 0; i < iter; i ++)\n\t\t\t\t{\n\t\t\t\t\tcp = 0.5 + (r - 0.5) * 0.9;\n\t\t\t\t\td = p.x - cp;\n\t\t\t\t\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 200.0);\n\t\t\t\t\tif(d > 0.0)\n\t\t\t\t\t{\n\t\t\t\t\t\tr = fract(r * 4829.013);\n\t\t\t\t\t\tp.x = (p.x - cp) / (1.0 - cp);\n\t\t\t\t\t\tv += 1.0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tr = fract(r * 1239.528);\n\t\t\t\t\t\tp.x = p.x / cp;\n\t\t\t\t\t}\n\t\t\t\t\tp = p.yx;\n\t\t\t\t}\n\t\t\t\tv /= float(iter);\n\t\t\t\treturn float2(g, v);\n\t\t\t}\n\n\t\t\tvoid main()\n\t\t\t{\n\t\t\t\tfloat scale = 0.5 * frequency;\n\n\t\t\t\tfloat2 uv = gl_FragCoord.xy;\n\t\t\t\tuv /= resolution.xy;\n\t\t\t\tuv = uv * 2.0 - 1.0;\n\t\t\t\tuv.x *= resolution.x / resolution.y;\n\t\t\t\tuv= uv * scale + float2(0.0, timeConst * period * 0.1) * boardSpeed;\n\t\t\t\tfloat2 cid2 = floor(uv);\n\t\t\t\tfloat cid = (cid2.y*10.0+cid2.x)*0.1;\n\n\t\t\t\tfloat2 dg = circuit(uv);\n\t\t\t\tfloat d = dg.x;\n\t\t\t\tfloat3 col1 = (0.2-float3(max(min(d, 2.0)-1.0, 0.0)*2.0*0.25)) * float3(1.0, 1.1, 1.3) * boardColor;\n\t\t\t\tfloat3 col2 = float3(max(d-1.0, 0.0)*2.0*0.5) * float3(1.0, 1.2, 1.6) * color;\n\n\t\t\t\tfloat f = max(0.5-mod(uv.y-uv.x*0.3+( timeConst * period * 0.4)+(dg.y*0.4), 2.5), 0.0) * intensity;\n\t\t\t\tcol2 *= f;\n\n\t\t\t\tgl_FragColor = vec4(col1+col2, 1.0);\n\t\t\t}\n\t\t\t";
        };
        Object.defineProperty(MaterialCircuit.prototype, "boardColor", {
            /**
            * Gets the board color
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['boardColor'].value; },
            /**
            * Sets the board color
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('boardColor', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialCircuit.prototype, "color", {
            /**
            * Gets the color
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['color'].value; },
            /**
            * Sets the color
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('color', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialCircuit.prototype, "period", {
            /**
            * Gets the period
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['period'].value; },
            /**
            * Sets the period
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('period', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialCircuit.prototype, "intensity", {
            /**
            * Gets the intensity
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['intensity'].value; },
            /**
            * Sets the intensity
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('intensity', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialCircuit.prototype, "boardSpeed", {
            /**
            * Gets the board speed
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['boardSpeed'].value; },
            /**
            * Sets the board speed
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('boardSpeed', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialCircuit.prototype, "frequency", {
            /**
            * Gets the frequency
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['frequency'].value; },
            /**
            * Sets the frequency
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('frequency', val); },
            enumerable: true,
            configurable: true
        });
        return MaterialCircuit;
    }(Trike.MaterialMulti));
    Trike.MaterialCircuit = MaterialCircuit;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Draws a lightning bolt
    * See http://glslsandbox.com/e#17334.0
    */
    var MaterialLightning = (function (_super) {
        __extends(MaterialLightning, _super);
        /**
        * Creates an instance of the shader
        * @param {number} width The width of the texture
        * @param {number} height The height of the texture
        */
        function MaterialLightning(width, height) {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Texture] = new Trike.PassMaterial('Lightning', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('timeConst', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('resolution', Trike.UniformType.FLOAT2, new Trike.Vec2(width, height)), true);
            this.addUniform(new Trike.UniformVar('color', Trike.UniformType.COLOR3, new Trike.Color(0xffffff), true));
            this.addUniform(new Trike.UniformVar('period', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('spread', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('intensity', Trike.UniformType.FLOAT, 1), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialLightning.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialLightning.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\tuniform float timeConst;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tuniform vec3 color;\n\t\t\t\tuniform float period;\n\t\t\t\tuniform float spread;\n\t\t\t\tuniform float intensity;\n\t\t\t\tfloat s = 0.0;  // fix glitch noise\n\n\t\t\t\t" + Trike.ShaderFragments.FragParams.saturate() + "\n\n\t\t\t\tvoid line(vec2 a , vec2 b, float size )\n\t\t\t\t{\n\t\t\t\t\tvec2 pos = gl_FragCoord.xy / resolution;\n\t\t\t\t\tfloat aspect = resolution.x / resolution.y;\n\t\t\t\t\tvec2 lab = a - b, la = pos - a, lb = pos - b;\n\t\t\t\t\tlab.x *= aspect; la.x *= aspect; lb.x *= aspect;\n\t\t\t\t\tfloat d = (length(la) + length(lb) - length(lab) + 1e-6)\n\t\t\t\t\t* min(length(la), length(lb));\n\t\t\t\t\ts = max(size - pow(d * 4.3e8, 0.07), s);\n\t\t\t\t}\n\n\n\t\t\t\tfloat rand(vec2 co)\n\t\t\t\t{\n\t\t\t\t\treturn fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n\t\t\t\t}\n\n\t\t\t\tfloat rand2(vec2 p)\n\t\t\t\t{\n\t\t\t\t\tmediump vec2 seed = floor(p * timeConst * period * resolution);\n\t\t\t\t\tmediump float rnd1 = fract(cos(seed.x * 8.3e-3 + seed.y) * 4.7e5);\n\t\t\t\t\treturn rnd1;\n\t\t\t\t}\n\n\t\t\t\tvoid split(vec2 a , vec2 b)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 1 ; j < 6 ; ++j )\n\t\t\t\t\t{\n\t\t\t\t\t\tvec2 t = a;\n\t\t\t\t\t\tvec2 d = (b - a) / float(15);\n\t\t\t\t\t\tfor (int i = 1 ; i < 15 ; ++i )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvec2 v = a + d * float(i);\n\t\t\t\t\t\t\tif(15-i === j * 2)\n\t\t\t\t\t\t\td+=(rand(vec2(float(j), float(j)) + v) - 0.5) * rand(v) * 0.025 * spread;\n\n\t\t\t\t\t\t\tv += (rand(v) - 0.5) * d.y;\n\t\t\t\t\t\t\tline(t, v, float(j) * 0.25 * intensity + 2.0);\n\t\t\t\t\t\t\tt = v;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvoid main(void )\n\t\t\t\t{\n\t\t\t\t\tsplit ( vec2(0.5,1.0), vec2( 0.5 , 0.0 ) + ( vec2( 1.0, 1.0 ) * rand2(vec2(1.1, 1.2)) * 0.0001 ));\n\t\t\t\t\tgl_FragColor = vec4(s - .2, s - 1., s, 1.0);\n\t\t\t\t\tgl_FragColor.rgb = saturate( gl_FragColor.rgb, 0.0 ) * color;\n\t\t\t\t}\n\t\t\t";
        };
        Object.defineProperty(MaterialLightning.prototype, "color", {
            /**
            * Gets the color
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['color'].value; },
            /**
            * Sets the color
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('color', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialLightning.prototype, "period", {
            /**
            * Gets the period
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['period'].value; },
            /**
            * Sets the period
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('period', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialLightning.prototype, "intensity", {
            /**
            * Gets the intensity
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['intensity'].value; },
            /**
            * Sets the intensity
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('intensity', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialLightning.prototype, "spread", {
            /**
            * Gets the spread
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['spread'].value; },
            /**
            * Sets the spread
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('spread', val); },
            enumerable: true,
            configurable: true
        });
        return MaterialLightning;
    }(Trike.MaterialMulti));
    Trike.MaterialLightning = MaterialLightning;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Draws a cloud of stars
    * See http://glslsandbox.com/e#21814.0
    */
    var MaterialStars = (function (_super) {
        __extends(MaterialStars, _super);
        /**
        * Creates an instance of the shader
        */
        function MaterialStars() {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Texture] = new Trike.PassMaterial('Stars', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('timeConst', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('color', Trike.UniformType.COLOR3, new Trike.Color(0xffffff), true));
            this.addUniform(new Trike.UniformVar('period', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('frequency', Trike.UniformType.FLOAT, 1), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            this.addAttribute(new Trike.AttributeVar('surface', Trike.AttributeType.SURFACE));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialStars.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 surface;\n\t\t\t\tvarying vec2 vSurface;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tvSurface = surface;\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialStars.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\tvarying vec2 vSurface;\n\t\t\t\tuniform vec3 color;\n\t\t\t\tuniform float timeConst;\n\t\t\t\tuniform float frequency;\n\t\t\t\tuniform float period;\n\n\t\t\t\t// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\n\t\t\t\tfloat Rand(vec2 co)\n\t\t\t\t{\n\t\t\t\t\thighp float a = 1552.9898;\n\t\t\t\t\thighp float b = 78.233;\n\t\t\t\t\thighp float c = 43758.5453;\n\t\t\t\t\thighp float dt= dot(co.xy, vec2(a, b));\n\t\t\t\t\thighp float sn= mod(dt, 3.14);\n\t\t\t\t\treturn fract(sin(sn) * c);\n\t\t\t\t}\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tfloat t = timeConst * period;\n\t\t\t\t\tvec2 uv = vSurface;\n\t\t\t\t\tvec2 tempVec = vec2(0.0);\n\t\t\t\t\tvec4 toReturn = vec4(0, 0, 0, 1);\n\t\t\t\t\ttempVec.x = Rand(vec2(uv.x, uv.y));\n\t\t\t\t\ttempVec.y = Rand(vec2(uv.y, uv.x));\n\n\t\t\t\t\thighp float PowIn = ((sin(((t + 10.0) * tempVec.x * 1.7)) * 0.5) + 0.5) * frequency;\n\t\t\t\t\ttoReturn.xyz = max(vec3( tempVec.x * pow( tempVec.y, 10.0) * pow(PowIn, 2.0) * 1.0), vec3(0.0)) * color;\n\n\t\t\t\t\tgl_FragColor = toReturn;\n\t\t\t\t}\n\n\t\t\t";
        };
        Object.defineProperty(MaterialStars.prototype, "color", {
            /**
            * Gets the color
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['color'].value; },
            /**
            * Sets the color
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('color', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialStars.prototype, "period", {
            /**
            * Gets the period
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['period'].value; },
            /**
            * Sets the period
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('period', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialStars.prototype, "frequency", {
            /**
            * Gets the frequency
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['frequency'].value; },
            /**
            * Sets the frequency
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('frequency', val); },
            enumerable: true,
            configurable: true
        });
        return MaterialStars;
    }(Trike.MaterialMulti));
    Trike.MaterialStars = MaterialStars;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Draws an animated fireball
    * See http://glslsandbox.com/e#21032.0
    */
    var MaterialFireball = (function (_super) {
        __extends(MaterialFireball, _super);
        /**
        * Creates an instance of the shader
        * @param {number} width The width of the texture
        * @param {number} height The height of the texture
        */
        function MaterialFireball(width, height) {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Texture] = new Trike.PassMaterial('Fireball', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('timeConst', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('resolution', Trike.UniformType.FLOAT2, new Trike.Vec2(width, height)), true);
            this.addUniform(new Trike.UniformVar('offset', Trike.UniformType.FLOAT2, new Trike.Vec2(0, 0)), true);
            this.addUniform(new Trike.UniformVar('color', Trike.UniformType.COLOR3, new Trike.Color(0xffffff), true));
            this.addUniform(new Trike.UniformVar('period', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('size', Trike.UniformType.FLOAT2, new Trike.Vec2(1, 1)), true);
            this.addUniform(new Trike.UniformVar('coarseness', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('granularity', Trike.UniformType.FLOAT, 16), true);
            this.addUniform(new Trike.UniformVar('intensity', Trike.UniformType.FLOAT, 1), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialFireball.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialFireball.prototype.getFragmentShader = function () {
            return "\n\t\t\t\tuniform float timeConst;\n\t\t\t\tuniform vec2 resolution;\n                uniform vec2 offset;\n                uniform vec3 color;\n                uniform float period;\n                uniform vec2 size;\n                uniform float coarseness;\n                uniform float granularity;\n                uniform float intensity;\n\n                " + Trike.ShaderFragments.FragParams.saturate() + "\n\n                float snoise(vec3 uv, float res)\n\t\t\t\t{\n\t\t\t\t\tconst vec3 s = vec3(1e0, 1e2, 1e3);\n\n\t\t\t\t\tuv *= res;\n\n\t\t\t\t\tvec3 uv0 = floor(mod(uv, res)) * s;\n\t\t\t\t\tvec3 uv1 = floor(mod(uv + vec3(1.), res)) * s;\n\n\t\t\t\t\tvec3 f = fract(uv); f = f * f * (3.0 - 2.0 * f);\n\n\t\t\t\t\tvec4 v = vec4(uv0.x + uv0.y + uv0.z, uv1.x + uv0.y + uv0.z,\n\t\t\t\t\tuv0.x + uv1.y + uv0.z, uv1.x + uv1.y + uv0.z);\n\n\t\t\t\t\tvec4 r = fract(sin(v * 1e-1) * 1e3);\n\t\t\t\t\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\n\t\t\t\t\tr = fract(sin((v + uv1.z - uv0.z) * 1e-1) * 1e3);\n\t\t\t\t\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\n\t\t\t\t\treturn mix(r0, r1, f.z) * 2. - 1.;\n\t\t\t\t}\n\n\t\t\t\tvoid main(void )\n\t\t\t\t{\n\t\t\t\t\tvec2 p = -.5 + gl_FragCoord.xy / resolution.xy;\n                \tp += offset; // offset\n\t\t\t\t\tp.x *= resolution.x / resolution.y;\n                \tp *= 1.0 / size;\n\t\t\t\t\tfloat c = 3.0 - (3. * length(2. * p));\n\n\t\t\t\t\tvec3 coord = vec3(atan(p.x, p.y) / 6.2832 + .5, length(p) * .4, .5);\n\n\t\t\t\t\tfor(int i = 1; i <= 7; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat power = pow(2.0, float(i));\n\t\t\t\t\t\tc += (1.5 * coarseness / power) * snoise(coord + vec3(0., -timeConst * period * .05, timeConst * period * .01), power * granularity);\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(c, pow(max(c, 0.), 2.) * 0.4, pow(max(c, 0.), 3.) * 0.15, 1.0);\n                \tgl_FragColor.xyz *= color * intensity;\n\t\t\t\t}\n\t\t\t";
        };
        Object.defineProperty(MaterialFireball.prototype, "offset", {
            /**
            * Gets the offset
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['offset'].value; },
            /**
            * Sets the offset
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('offset', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialFireball.prototype, "color", {
            /**
            * Gets the color
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['color'].value; },
            /**
            * Sets the color
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('color', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialFireball.prototype, "size", {
            /**
            * Gets the size
            * @returns {Vec2}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['size'].value; },
            /**
            * Sets the size
            * @param {Vec2} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('size', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialFireball.prototype, "period", {
            /**
            * Gets the period
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['period'].value; },
            /**
            * Sets the period
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('period', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialFireball.prototype, "intensity", {
            /**
            * Gets the intensity
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['intensity'].value; },
            /**
            * Sets the intensity
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('intensity', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialFireball.prototype, "coarseness", {
            /**
            * Gets the coarseness
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['coarseness'].value; },
            /**
            * Sets the coarseness
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('coarseness', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialFireball.prototype, "granularity", {
            /**
            * Gets the granularity
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['granularity'].value; },
            /**
            * Sets the granularity
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('granularity', parseInt(val.toString())); },
            enumerable: true,
            configurable: true
        });
        return MaterialFireball;
    }(Trike.MaterialMulti));
    Trike.MaterialFireball = MaterialFireball;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Draws an animated flame
    * See http://glslsandbox.com/e#17263.0
    */
    var MaterialFlame = (function (_super) {
        __extends(MaterialFlame, _super);
        /**
        * Creates an instance of the shader
        * @param {number} width The width of the texture
        * @param {number} height The height of the texture
        */
        function MaterialFlame(width, height) {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Texture] = new Trike.PassMaterial('Flame', this);
            this._noiseDepth = 0;
            this.noiseDepth = 3.0;
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('timeConst', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('resolution', Trike.UniformType.FLOAT2, new Trike.Vec2(width, height)), true);
            this.addUniform(new Trike.UniformVar('offset', Trike.UniformType.FLOAT2, new Trike.Vec2(0, 0)), true);
            this.addUniform(new Trike.UniformVar('color', Trike.UniformType.COLOR3, new Trike.Color(0xffffff), true));
            this.addUniform(new Trike.UniformVar('period', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('size', Trike.UniformType.FLOAT, 10), true);
            this.addUniform(new Trike.UniformVar('height', Trike.UniformType.FLOAT, 3), true);
            this.addUniform(new Trike.UniformVar('noiseSize', Trike.UniformType.FLOAT, 8), true);
            this.addUniform(new Trike.UniformVar('noiseStrength', Trike.UniformType.FLOAT, 0.25), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialFlame.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialFlame.prototype.getFragmentShader = function () {
            return "\n\t\t\t\tuniform float timeConst;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tuniform vec2 offset;\n\t\t\t\tuniform vec3 color;\n\t\t\t\tuniform float period;\n\t\t\t\tuniform float height;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float noiseSize;\n\t\t\t\tuniform float noiseStrength;\n\t\t\t\tuniform float noiseDepth;\n\n\t\t\t\t// Perlin noise source code from Stefan Gustavson\n\t\t\t\t// https://github.com/ashima/webgl-noise/blob/master/src/classicnoise2D.glsl\n\n\t\t\t\t" + Trike.ShaderFragments.FragParams.saturate() + "\n\n\t\t\t\tvec4 mod289(vec4 x)\n\t\t\t\t{\n\t\t\t\t\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t\t\t}\n\n\t\t\t\tvec4 permute(vec4 x)\n\t\t\t\t{\n\t\t\t\t\treturn mod289(((x * 34.0) + 1.0) * x);\n\t\t\t\t}\n\n\t\t\t\tvec4 taylorInvSqrt(vec4 r)\n\t\t\t\t{\n\t\t\t\t\treturn 1.79284291400159 - 0.85373472095314 * r;\n\t\t\t\t}\n\n\t\t\t\tvec2 fade(vec2 t)\n\t\t\t\t{\n\t\t\t\t\treturn t* t * t * (t * (t * 6.0 - 15.0) + 10.0);\n\t\t\t\t}\n\n\t\t\t\t// Classic Perlin noise\n\t\t\t\tfloat cnoise(vec2 P)\n\t\t\t\t{\n\t\t\t\t\tvec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n\t\t\t\t\tvec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n\t\t\t\t\tPi = mod289(Pi); // To avoid truncation effects in permutation\n\t\t\t\t\tvec4 ix = Pi.xzxz;\n\t\t\t\t\tvec4 iy = Pi.yyww;\n\t\t\t\t\tvec4 fx = Pf.xzxz;\n\t\t\t\t\tvec4 fy = Pf.yyww;\n\n\t\t\t\t\tvec4 i = permute(permute(ix) + iy);\n\n\t\t\t\t\tvec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n\t\t\t\t\tvec4 gy = abs(gx) - 0.5 ;\n\t\t\t\t\tvec4 tx = floor(gx + 0.5);\n\t\t\t\t\tgx = gx - tx;\n\n\t\t\t\t\tvec2 g00 = vec2(gx.x, gy.x);\n\t\t\t\t\tvec2 g10 = vec2(gx.y, gy.y);\n\t\t\t\t\tvec2 g01 = vec2(gx.z, gy.z);\n\t\t\t\t\tvec2 g11 = vec2(gx.w, gy.w);\n\n\t\t\t\t\tvec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n\t\t\t\t\tg00 *= norm.x;\n\t\t\t\t\tg01 *= norm.y;\n\t\t\t\t\tg10 *= norm.z;\n\t\t\t\t\tg11 *= norm.w;\n\n\t\t\t\t\tfloat n00 = dot(g00, vec2(fx.x, fy.x));\n\t\t\t\t\tfloat n10 = dot(g10, vec2(fx.y, fy.y));\n\t\t\t\t\tfloat n01 = dot(g01, vec2(fx.z, fy.z));\n\t\t\t\t\tfloat n11 = dot(g11, vec2(fx.w, fy.w));\n\n\t\t\t\t\tvec2 fade_xy = fade(Pf.xy);\n\t\t\t\t\tvec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n\t\t\t\t\tfloat n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n\t\t\t\t\treturn 2.3 * n_xy;\n\t\t\t\t}\n\n\n\t\t\t\tvoid main(void )\n\t\t\t\t{\n\t\t\t\t\tvec2 position = (vec2(0.5, 0.1) + offset) * resolution.xy;\n\n\t\t\t\t\t// Compute flame area\n\t\t\t\t\tvec2 coord;\n\t\t\t\t\tif (gl_FragCoord.y > position.y)\n\t\t\t\t\t\tcoord = vec2(gl_FragCoord.x, position.y + (gl_FragCoord.y - position.y) / height);\n\t\t\t\t\telse\n\t\t\t\t\t\tcoord = gl_FragCoord.xy;\n\n\t\t\t\t\tfloat dist = distance(position, coord) / resolution.y;\n\n\t\t\t\t\t// Compute flame noise\n\t\t\t\t\tvec2 noisePosition = noiseSize * (gl_FragCoord.xy - position) / resolution.y - vec2(0.0, period * timeConst);\n\t\t\t\t\tfloat noise = 0.0;\n\t\t\t\t\tfor (int i = 0; i < NOISE_DEPTH; i++)\n\t\t\t\t\tnoise += cnoise(noisePosition * pow(2.0, float(i)));\n\n\t\t\t\t\tgl_FragColor = vec4(mix(-size * dist, noise, noiseStrength) + vec3(2.0, 1.5, .5), 1.0);\n\t\t\t\t\tgl_FragColor.rgb *= color;\n\t\t\t\t}\n\t\t\t";
        };
        Object.defineProperty(MaterialFlame.prototype, "noiseDepth", {
            /**
            * Gets the noise depth. Ideally 3
            * @returns {number}
            */
            get: function () { return this._noiseDepth; },
            /**
            * Sets the noise depth. Ideally 3
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define NOISE_DEPTH ' + this._noiseDepth.toFixed(0));
                this._noiseDepth = val;
                this.addDefine('#define NOISE_DEPTH ' + this._noiseDepth.toFixed(0));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialFlame.prototype, "offset", {
            /**
            * Gets the offset
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['offset'].value; },
            /**
            * Sets the offset
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('offset', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialFlame.prototype, "color", {
            /**
            * Gets the color
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['color'].value; },
            /**
            * Sets the color
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('color', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialFlame.prototype, "height", {
            /**
            * Gets the height
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['height'].value; },
            /**
            * Sets the height
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('height', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialFlame.prototype, "size", {
            /**
            * Gets the size
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['size'].value; },
            /**
            * Sets the size
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('size', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialFlame.prototype, "period", {
            /**
            * Gets the period
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['period'].value; },
            /**
            * Sets the period
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('period', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialFlame.prototype, "noiseSize", {
            /**
            * Gets the noise size
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['noiseSize'].value; },
            /**
            * Sets the noise size
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('noiseSize', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialFlame.prototype, "noiseStrength", {
            /**
            * Gets the noise strength
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['noiseStrength'].value; },
            /**
            * Sets the noise strength
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('noiseStrength', val); },
            enumerable: true,
            configurable: true
        });
        return MaterialFlame;
    }(Trike.MaterialMulti));
    Trike.MaterialFlame = MaterialFlame;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Draws an animated oil puddle
    * See http://glslsandbox.com/e#17589.4
    */
    var MaterialOil = (function (_super) {
        __extends(MaterialOil, _super);
        /**
        * Creates an instance of the shader
        */
        function MaterialOil() {
            //Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Texture] = new Trike.PassMaterial('Oil', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('timeConst', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('sharpness', Trike.UniformType.FLOAT, 0.5), true);
            this.addUniform(new Trike.UniformVar('color', Trike.UniformType.COLOR3, new Trike.Color(0xffffff), true));
            this.addUniform(new Trike.UniformVar('period', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('frequency', Trike.UniformType.FLOAT, 1), true);
            //Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            this.addAttribute(new Trike.AttributeVar('surface', Trike.AttributeType.SURFACE));
            //Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialOil.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 surface;\n\t\t\t\tvarying vec2 vSurface;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tvSurface = surface;\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialOil.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\tuniform float timeConst;\n\t\t\t\tuniform vec3 color;\n\t\t\t\tuniform float period;\n\t\t\t\tuniform float sharpness;\n\t\t\t\tuniform float frequency;\n\t\t\t\tvarying vec2 vSurface;\n\n\t\t\t\t#define ptpi 1385.4557313670110891409199368797 //powten(pi)\n\t\t\t\t#define pipi  36.462159607207911770990826022692 //pi pied, pi^pi\n\t\t\t\t#define picu  31.006276680299820175476315067101 //pi cubed, pi^3\n\t\t\t\t#define pepi  23.140692632779269005729086367949 //powe(pi);\n\t\t\t\t#define chpi  11.59195327552152062775175205256  //cosh(pi)\n\t\t\t\t#define shpi  11.548739357257748377977334315388 //sinh(pi)\n\t\t\t\t#define pisq  9.8696044010893586188344909998762 //pi squared, pi^2\n\t\t\t\t#define twpi  6.283185307179586476925286766559  //two pi, 2*pi\n\t\t\t\t#define pi    3.1415926535897932384626433832795 //pi\n\t\t\t\t#define ttpi  2.0943951023931954923084289221863 //pi\n\t\t\t\t#define sqpi  1.7724538509055160272981674833411 //square root of pi\n\t\t\t\t#define hfpi  1.5707963267948966192313216916398 //half pi, 1/pi\n\t\t\t\t#define cupi  1.4645918875615232630201425272638 //cube root of pi\n\t\t\t\t#define prpi  1.4396194958475906883364908049738 //pi root of pi\n\t\t\t\t#define lnpi  1.1447298858494001741434273513531 //logn(pi);\n\t\t\t\t#define trpi  1.0471975511965977461542144610932 //one third of pi, pi/3\n\t\t\t\t#define thpi  0.99627207622074994426469058001254//tanh(pi)\n\t\t\t\t#define lgpi  0.4971498726941338543512682882909 //log(pi)\n\t\t\t\t#define rcpi  0.31830988618379067153776752674503// reciprocal of pi  , 1/pi\n\t\t\t\t#define rcpipi  0.0274256931232981061195562708591 // reciprocal of pipi  , 1/pipi\n\n\t\t\t\tvec3 warp(vec3 v)\n\t\t\t\t{\n\t\t\t\t\tv = v + sin(sin(v.x) + cos(v.y)) + v;\n\t\t\t\t\tfloat a = atan(v.y, v.x) * 1. + sin(v.z / pi) * twpi;\n\t\t\t\t\tfloat r = length(v.xy) + sin(v.z / 2.) + a;\n\t\t\t\t\tvec3 c = vec3(sin(a) * 0.5 + 0.5, sin(a + ttpi) * 0.5 + 0.5, sin(a - ttpi) * 0.5 + 0.5);\n\t\t\t\t\treturn (c)+(sin(r + a) * sharpness + 0.5);\n\t\t\t\t}\n\n\t\t\t\tvoid main(void )\n\t\t\t\t{\n\t\t\t\t\tvec2 pos = pipi * (vSurface / sqrt(length(vSurface) / pi + 1.)) * frequency;\n\t\t\t\t\tfloat t = timeConst * period + (sqrt(length(pos))) + sin(sqrt(length(pos))) * pi;\n\t\t\t\t\tvec3 col = vec3(0.0);\n\t\t\t\t\tfloat div = 0.0;\n\t\t\t\t\tfor (float i= 1.; i < 9.; i += 1.)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat fac = pow(4., i) + ((length(pos) + 1.) / pi + sin(sin(t / pi) + 1. * atan(pos.y, pos.x) + pi * sin(length(pos / pisq))) * pi);\n\t\t\t\t\t\tdiv += i * i;\n\t\t\t\t\t\tcol += warp(vec3((pos + sin(sin(t / lnpi) + 1. * atan(pos.y, pos.x) + length(pos) / pisq) / fac) + (pi / (pow(length(pos) / pi, rcpi) + 1.)), fac + (t / i) + sin((1. + length(col)) / pi)));\n\t\t\t\t\t}\n\n\t\t\t\t\tcol = (col * col) / div;\n\t\t\t\t\tgl_FragColor = vec4(col * color, 1.0);\n\t\t\t\t}\n\t\t\t";
        };
        Object.defineProperty(MaterialOil.prototype, "color", {
            /**
            * Gets the color
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['color'].value; },
            /**
            * Sets the color
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('color', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialOil.prototype, "period", {
            /**
            * Gets the period
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['period'].value; },
            /**
            * Sets the period
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('period', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialOil.prototype, "frequency", {
            /**
            * Gets the frequency
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['frequency'].value; },
            /**
            * Sets the frequency
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('frequency', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialOil.prototype, "sharpness", {
            /**
            * Gets the sharpness
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['sharpness'].value; },
            /**
            * Sets the sharpness
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('sharpness', val); },
            enumerable: true,
            configurable: true
        });
        return MaterialOil;
    }(Trike.MaterialMulti));
    Trike.MaterialOil = MaterialOil;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Draws an thundery cloud effect
    * See http://glslsandbox.com/e#17838.0
    */
    var MaterialThunder = (function (_super) {
        __extends(MaterialThunder, _super);
        /**
        * Creates an instance of the shader
        * @param {number} width The width of the texture
        * @param {number} height The height of the texture
        */
        function MaterialThunder(width, height) {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Texture] = new Trike.PassMaterial('Thunder', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('timeConst', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('resolution', Trike.UniformType.FLOAT2, new Trike.Vec2(width, height)), true);
            this.addUniform(new Trike.UniformVar('contrast', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('color', Trike.UniformType.COLOR3, new Trike.Color(0xffffff), true));
            this.addUniform(new Trike.UniformVar('period', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('intensity', Trike.UniformType.FLOAT, 1), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialThunder.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialThunder.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\tuniform float timeConst;\n\t\t\t\tuniform vec2 resolution;\n\n\t\t\t\tuniform vec3 color;\n\t\t\t\tuniform float period;\n\t\t\t\tuniform float contrast;\n\t\t\t\tuniform float intensity;\n\n\n\n\t\t\t\tfloat length2(vec2 p)\n\t\t\t\t{\n\t\t\t\t\treturn dot(p, p);\n\t\t\t\t}\n\n\t\t\t\tfloat noise(vec2 p)\n\t\t\t\t{\n\t\t\t\t\treturn fract(sin(fract(sin(p.x) * (4313.13311)) + p.y) * 3131.0011);\n\t\t\t\t}\n\n\t\t\t\tfloat worley(vec2 p)\n\t\t\t\t{\n\t\t\t\t\tfloat d = 1e30;\n\t\t\t\t\tvec2 tp;\n\t\t\t\t\ttp = floor(p) + vec2(-1.0, -1.0);\n\t\t\t\t\td = min(d, length2(p - tp - vec2(noise(tp))));\n\t\t\t\t\ttp = floor(p) + vec2(0.0, -1.0);\n\t\t\t\t\td = min(d, length2(p - tp - vec2(noise(tp))));\n\t\t\t\t\ttp = floor(p) + vec2(1.0, -1.0);\n\t\t\t\t\td = min(d, length2(p - tp - vec2(noise(tp))));\n\n\t\t\t\t\ttp = floor(p) + vec2(-1.0, 0.0);\n\t\t\t\t\td = min(d, length2(p - tp - vec2(noise(tp))));\n\t\t\t\t\ttp = floor(p) + vec2(0.0, 0.0);\n\t\t\t\t\td = min(d, length2(p - tp - vec2(noise(tp))));\n\t\t\t\t\ttp = floor(p) + vec2(1.0, 0.0);\n\t\t\t\t\td = min(d, length2(p - tp - vec2(noise(tp))));\n\n\t\t\t\t\ttp = floor(p) + vec2(-1.0, 1.0);\n\t\t\t\t\td = min(d, length2(p - tp - vec2(noise(tp))));\n\t\t\t\t\ttp = floor(p) + vec2(0.0, 1.0);\n\t\t\t\t\td = min(d, length2(p - tp - vec2(noise(tp))));\n\t\t\t\t\ttp = floor(p) + vec2(1.0, 1.0);\n\t\t\t\t\td = min(d, length2(p - tp - vec2(noise(tp))));\n\t\t\t\t\treturn 3.* exp(-4. * abs(2. * d - 1.));\n\t\t\t\t}\n\n\t\t\t\tfloat fworley(vec2 p)\n\t\t\t\t{\n\t\t\t\t\tfloat t = timeConst * period;\n\t\t\t\t\treturn pow(\n\t\t\t\t\tpow(worley(p - t * 1.0), 2.) *\n\t\t\t\t\tworley(p * 2. + 1.3 + t * .5) *\n\t\t\t\t\tworley(p * 4. + 2.3 + t * -.25) *\n\t\t\t\t\tworley(p * 8. + 3.3 + t * .125) *\n\t\t\t\t\tworley(p * 32. + 4.3 + t * .125) *\n\t\t\t\t\tsqrt(worley(p * 64. + 5.3 + t * -.00625)) *\n\t\t\t\t\tpow(worley(p * -128. + 7.3), 1.0 / 4.0), 0.225 * contrast);\n\t\t\t\t}\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\t\t\t\t\tfloat t = fworley(uv * resolution.xy / 2800.) * intensity;\n\t\t\t\t\tt *= exp(-length2(abs(2. * uv - 1.)));\n\t\t\t\t\tfloat r = length(abs(2. * uv - 1.) * resolution.xy);\n\t\t\t\t\tgl_FragColor = vec4(t * vec3(1.0 * t, 1.0 * t, 2.0 * t) * color, 1.0);\n\t\t\t\t}\n\t\t\t";
        };
        Object.defineProperty(MaterialThunder.prototype, "color", {
            /**
            * Gets the color
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['color'].value; },
            /**
            * Sets the color
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('color', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialThunder.prototype, "period", {
            /**
            * Gets the period
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['period'].value; },
            /**
            * Sets the period
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('period', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialThunder.prototype, "intensity", {
            /**
            * Gets the intensity
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['intensity'].value; },
            /**
            * Sets the intensity
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('intensity', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialThunder.prototype, "contrast", {
            /**
            * Gets the contrast
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['contrast'].value; },
            /**
            * Sets the contrast
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('contrast', parseInt(val.toString())); },
            enumerable: true,
            configurable: true
        });
        return MaterialThunder;
    }(Trike.MaterialMulti));
    Trike.MaterialThunder = MaterialThunder;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Draws cluters of light orbs
    * See http://glslsandbox.com/e#17172.0
    */
    var MaterialOrbs = (function (_super) {
        __extends(MaterialOrbs, _super);
        /**
        * Creates an instance of the shader
        * @param {number} width The width of the texture
        * @param {number} height The height of the texture
        */
        function MaterialOrbs(width, height) {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Texture] = new Trike.PassMaterial('Orbs', this);
            this._numOrbs = 0;
            this.numOrbs = 4;
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('timeConst', Trike.UniformType.FLOAT, 50), true);
            this.addUniform(new Trike.UniformVar('resolution', Trike.UniformType.FLOAT2, new Trike.Vec2(width, height)), true);
            this.addUniform(new Trike.UniformVar('color', Trike.UniformType.COLOR3, new Trike.Color(0xffffff), true));
            this.addUniform(new Trike.UniformVar('period', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('frequency', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('glow', Trike.UniformType.FLOAT, 2), true);
            this.addUniform(new Trike.UniformVar('size', Trike.UniformType.FLOAT, 0.3), true);
            this.addUniform(new Trike.UniformVar('contrast', Trike.UniformType.FLOAT, 1), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialOrbs.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialOrbs.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\tuniform float timeConst;\n\t\t\t\tuniform vec2 resolution;\n\n\t\t\t\tuniform vec3 color;\n\t\t\t\tuniform float period;\n\t\t\t\tuniform float frequency;\n\t\t\t\tuniform float glow;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float contrast;\n\n\t\t\t\tfloat rand(vec2 co)\n\t\t\t\t{\n\t\t\t\t\treturn fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n\t\t\t\t}\n\n\t\t\t\tfloat makePoint(float x, float y, float fx, float fy, float sx, float sy, float t)\n\t\t\t\t{\n\t\t\t\t\tfloat xx= x + sin(.1 * t * fx) * sx * 1.3;\n\t\t\t\t\tfloat yy= y + cos(.1 * t * fy) * sy * 1.3;\n\t\t\t\t\treturn (size + 0.3 * sin(t * fx)) / sqrt(xx * xx + yy * yy);\n\t\t\t\t}\n\n\t\t\t\tvoid main(void )\n\t\t\t\t{\n\t\t\t\t\tvec2 p= (gl_FragCoord.xy / resolution.x) * 2.0 - vec2(1.0, resolution.y / resolution.x);\n\n\t\t\t\t\tp = p * 20.0;\n\t\t\t\t\tfloat x= p.x;\n\t\t\t\t\tfloat y= p.y;\n\t\t\t\t\tfloat a;\n\n\t\t\t\t\tfor (float i = 0.0; i < NUM_ORBS; i++ )\n\t\t\t\t\ta = a + makePoint(x, y, frequency + rand(vec2(i)), frequency + rand(vec2(i + 3.0)), 9.9 + rand(vec2(i + 7.0)), 9.3 + rand(vec2((i + 11.0))) * 0.1, timeConst * period);\n\n\t\t\t\t\tvec3 a1= vec3(a * .02, a * .015, a * .008);\n\t\t\t\t\tgl_FragColor = vec4(a1.x, a1.y, a1.z, 1.0);\n\t\t\t\t\tgl_FragColor = smoothstep(0.98 * (1.0 / glow), 1.05, a) * vec4(1.0) + vec4(vec3(a) * (1.0 - contrast), 1.0);\n\t\t\t\t\tgl_FragColor.rgb *= color;\n\t\t\t\t}\n\t\t\t";
        };
        Object.defineProperty(MaterialOrbs.prototype, "numOrbs", {
            /**
            * Gets the number of orbs
            * @returns {TechnoType}
            */
            get: function () { return this._numOrbs; },
            /**
            * Sets the number of orbs
            * @param {TechnoType} val
            */
            set: function (val) {
                this.removeDefine('#define NUM_ORBS ' + this._numOrbs.toFixed(3));
                this._numOrbs = val;
                this.addDefine('#define NUM_ORBS ' + this._numOrbs.toFixed(3));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialOrbs.prototype, "color", {
            /**
            * Gets the color
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['color'].value; },
            /**
            * Sets the color
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('color', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialOrbs.prototype, "period", {
            /**
            * Gets the period
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['period'].value; },
            /**
            * Sets the period
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('period', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialOrbs.prototype, "frequency", {
            /**
            * Gets the frequency
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['frequency'].value; },
            /**
            * Sets the frequency
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('frequency', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialOrbs.prototype, "glow", {
            /**
            * Gets the glow
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['glow'].value; },
            /**
            * Sets the glow
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('glow', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialOrbs.prototype, "size", {
            /**
            * Gets the size
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['size'].value; },
            /**
            * Sets the size
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('size', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialOrbs.prototype, "contrast", {
            /**
            * Gets the contrast
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['contrast'].value; },
            /**
            * Sets the contrast
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('contrast', val); },
            enumerable: true,
            configurable: true
        });
        return MaterialOrbs;
    }(Trike.MaterialMulti));
    Trike.MaterialOrbs = MaterialOrbs;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Draws a rising vapour type of effect
    * See http://glslsandbox.com/e#17262.0
    */
    var MaterialVapours = (function (_super) {
        __extends(MaterialVapours, _super);
        /**
        * Creates an instance of the shader
        * @param {number} width The width of the texture
        * @param {number} height The height of the texture
        */
        function MaterialVapours(width, height) {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Texture] = new Trike.PassMaterial('Vapours', this);
            this._numOctaves = 0;
            this.numOctaves = 4.0;
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('timeConst', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('resolution', Trike.UniformType.FLOAT2, new Trike.Vec2(width, height)), true);
            this.addUniform(new Trike.UniformVar('contrast', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('color', Trike.UniformType.COLOR3, new Trike.Color(0xffffff), true));
            this.addUniform(new Trike.UniformVar('period', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('frequency', Trike.UniformType.FLOAT, 1), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialVapours.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialVapours.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\tuniform float timeConst;\n\t\t\t\tuniform vec2 resolution;\n\n\t\t\t\tuniform vec3 color;\n\t\t\t\tuniform float period;\n\t\t\t\tuniform float contrast;\n\t\t\t\tuniform float frequency;\n\n\t\t\t\t// by @301z\n\t\t\t\tfloat rand(vec2 n)\n\t\t\t\t{\n\t\t\t\t\treturn fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n\t\t\t\t}\n\n\n\t\t\t\tfloat noise(vec2 n)\n\t\t\t\t{\n\t\t\t\t\tconst vec2 d = vec2(0.0, 1.0);\n\t\t\t\t\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\t\t\t\t\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n\t\t\t\t}\n\n\n\t\t\t\tfloat fbm(vec2 n)\n\t\t\t\t{\n\t\t\t\t\tfloat total = 0.0;\n\t\t\t\t\tfloat c = contrast;\n\t\t\t\t\tfor (int i = 0; i < NUM_OCTAVES; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttotal += noise(n) * c;\n\t\t\t\t\t\tn += n;\n\t\t\t\t\t\tc *= 0.5;\n\t\t\t\t\t}\n\t\t\t\t\treturn total;\n\t\t\t\t}\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tconst vec3 c1 = vec3(0.6, 0.6, 0.6);\n\t\t\t\t\tconst vec3 c2 = vec3(0.7, 0.7, 0.7);\n\t\t\t\t\tconst vec3 c3 = vec3(0.8, 0.8, 0.8);\n\t\t\t\t\tconst vec3 c4 = vec3(0.9, 0.9, 0.9);\n\t\t\t\t\tconst vec3 c5 = vec3(0.1);\n\t\t\t\t\tconst vec3 c6 = vec3(0.9);\n\n\t\t\t\t\tfloat t = timeConst * period;\n\n\t\t\t\t\tvec2 p = gl_FragCoord.xy * 8.0 / resolution.xx * frequency;\n\t\t\t\t\tfloat q = fbm(p - t * 0.1);\n\t\t\t\t\tvec2 r = vec2(fbm(p + q + t * 0.7 - p.x - p.y), fbm(p + q - t * 0.4));\n\t\t\t\t\tvec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);\n\t\t\t\t\tgl_FragColor = vec4(c * cos( gl_FragCoord.y / resolution.y), 1.0);\n\t\t\t\t\tgl_FragColor.rgb *= color;\n\t\t\t\t}\n\t\t\t";
        };
        Object.defineProperty(MaterialVapours.prototype, "color", {
            /**
            * Gets the color
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['color'].value; },
            /**
            * Sets the color
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('color', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialVapours.prototype, "period", {
            /**
            * Gets the period
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['period'].value; },
            /**
            * Sets the period
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('period', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialVapours.prototype, "frequency", {
            /**
            * Gets the frequency
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['frequency'].value; },
            /**
            * Sets the frequency
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('frequency', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialVapours.prototype, "contrast", {
            /**
            * Gets the contrast
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['contrast'].value; },
            /**
            * Sets the contrast
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('contrast', parseInt(val.toString())); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialVapours.prototype, "numOctaves", {
            /**
            * Gets the number of octaves to use. Should not go over 4. Ideally 3
            * @returns {number}
            */
            get: function () { return this._numOctaves; },
            /**
            * Sets the number of octaves to use. Should not go over 4. Ideally 3
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define NUM_OCTAVES ' + this._numOctaves.toFixed(0));
                this._numOctaves = val;
                this.addDefine('#define NUM_OCTAVES ' + this._numOctaves.toFixed(0));
            },
            enumerable: true,
            configurable: true
        });
        return MaterialVapours;
    }(Trike.MaterialMulti));
    Trike.MaterialVapours = MaterialVapours;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Draws animated water beams
    * See http://glslsandbox.com/e#21032.0
    * Ashok Gowtham M
    * UnderWater Caustic lights
    */
    var MaterialWaterBeams = (function (_super) {
        __extends(MaterialWaterBeams, _super);
        /**
        * Creates an instance of the shader
        * @param {number} width The width of the texture
        * @param {number} height The height of the texture
        */
        function MaterialWaterBeams(width, height) {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Texture] = new Trike.PassMaterial('Water Beams', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('timeConst', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('resolution', Trike.UniformType.FLOAT2, new Trike.Vec2(width, height)), true);
            this.addUniform(new Trike.UniformVar('color', Trike.UniformType.COLOR3, new Trike.Color(0xffffff), true));
            this.addUniform(new Trike.UniformVar('period', Trike.UniformType.FLOAT, 1), true);
            this.addUniform(new Trike.UniformVar('frequency', Trike.UniformType.FLOAT, 1), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialWaterBeams.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialWaterBeams.prototype.getFragmentShader = function () {
            return "\n\t\t\t\tuniform float timeConst;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tuniform vec3 color;\n\t\t\t\tuniform float period;\n\t\t\t\tuniform float frequency;\n\n\t\t\t\t// normalized sin\n\t\t\t\tfloat sinn(float x)\n\t\t\t\t{\n\t\t\t\t\treturn sin(x) / 2. + .5;\n\t\t\t\t}\n\n\t\t\t\tfloat CausticPatternFn(vec2 pos)\n\t\t\t\t{\n\t\t\t\t\tfloat t = timeConst * period;\n\t\t\t\t\tfloat f = frequency;\n\t\t\t\t\treturn (sin(pos.x * 40. + t)\n\t\t\t\t\t+ pow(sin(-pos.x * 130. * f + t), 1.)\n\t\t\t\t\t+ pow(sin(pos.x * 30. * f + t), 2.)\n\t\t\t\t\t+ pow(sin(pos.x * 50. * f + t), 2.)\n\t\t\t\t\t+ pow(sin(pos.x * 80. * f + t), 2.)\n\t\t\t\t\t+ pow(sin(pos.x * 90. * f + t), 2.)\n\t\t\t\t\t+ pow(sin(pos.x * 12. * f + t), 2.)\n\t\t\t\t\t+ pow(sin(pos.x * 6. * f + t), 2.)\n\t\t\t\t\t+ pow(sin(-pos.x * 13. * f + t), 5.))/2.;\n\t\t\t\t}\n\n\t\t\t\tvec2 CausticDistortDomainFn(vec2 pos)\n\t\t\t\t{\n\t\t\t\t\tfloat t = timeConst * period;\n\t\t\t\t\tpos.x *= (pos.y * .20 + .5);\n\t\t\t\t\tpos.x *= 1. + sin(t / 1.) / 10.;\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\n\t\t\t\tvoid main(void )\n\t\t\t\t{\n\t\t\t\t\tvec2 pos = gl_FragCoord.xy / resolution;\n\t\t\t\t\tpos -= .5;\n\t\t\t\t\tvec2  CausticDistortedDomain = CausticDistortDomainFn(pos);\n\t\t\t\t\tfloat CausticShape = clamp(7. - length(CausticDistortedDomain.x * 20.), 0., 1.);\n\t\t\t\t\tfloat CausticPattern = CausticPatternFn(CausticDistortedDomain);\n\t\t\t\t\tfloat CausticOnFloor = 0.;\n\t\t\t\t\tfloat Caustic;\n\t\t\t\t\tCaustic += CausticShape * CausticPattern + 0.01;\n\t\t\t\t\tCaustic *= (pos.y + .5) / 4.;\n\t\t\t\t\tfloat f = length(pos + vec2(-.5, .5)) * length(pos + vec2(.5, .5)) * (1. + Caustic) / 1.;\n\t\t\t\t\tgl_FragColor = vec4(.1, .5, .6, 1) * (f);\n\t\t\t\t\tgl_FragColor.rgb *= color;\n\t\t\t\t}\n\t\t\t";
        };
        Object.defineProperty(MaterialWaterBeams.prototype, "color", {
            /**
            * Gets the color
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['color'].value; },
            /**
            * Sets the color
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('color', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialWaterBeams.prototype, "frequency", {
            /**
            * Gets the frequency
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['frequency'].value; },
            /**
            * Sets the frequency
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('frequency', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialWaterBeams.prototype, "period", {
            /**
            * Gets the period
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['period'].value; },
            /**
            * Sets the period
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('period', val); },
            enumerable: true,
            configurable: true
        });
        return MaterialWaterBeams;
    }(Trike.MaterialMulti));
    Trike.MaterialWaterBeams = MaterialWaterBeams;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Draws a terrain heightmap / color map
    * See http://glslsandbox.com/e#20586.0
    * Written by Frank Gennari
    */
    var MaterialTerrainMap = (function (_super) {
        __extends(MaterialTerrainMap, _super);
        /**
        * Creates an instance of the shader
        * @param {number} width The width of the texture
        * @param {number} height The height of the texture
        */
        function MaterialTerrainMap(width, height) {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Texture] = new Trike.PassMaterial('Terrain Map', this);
            this._numOctaves = 0;
            this.numOctaves = 8.0;
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('resolution', Trike.UniformType.FLOAT2, new Trike.Vec2(width, height)), true);
            this.addUniform(new Trike.UniformVar('colorSnow', Trike.UniformType.COLOR3, new Trike.Color(0xffffff), true));
            this.addUniform(new Trike.UniformVar('colorWater', Trike.UniformType.COLOR3, new Trike.Color(0x4174AB), true));
            this.addUniform(new Trike.UniformVar('colorVegetation', Trike.UniformType.COLOR3, new Trike.Color(0x7DAB41), true));
            this.addUniform(new Trike.UniformVar('colorDirt', Trike.UniformType.COLOR3, new Trike.Color(0x8A724D), true));
            this.addUniform(new Trike.UniformVar('colorRock', Trike.UniformType.COLOR3, new Trike.Color(0x8F8F8F), true));
            this.addUniform(new Trike.UniformVar('seed', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('waterVal', Trike.UniformType.FLOAT, 0.2), true);
            this.addUniform(new Trike.UniformVar('snowThreshhold', Trike.UniformType.FLOAT, 0.9), true);
            this.addUniform(new Trike.UniformVar('terrainScale', Trike.UniformType.FLOAT, 2.0), true);
            this.addUniform(new Trike.UniformVar('heightBias', Trike.UniformType.FLOAT, 1.0), true);
            this.addUniform(new Trike.UniformVar('heightColors', Trike.UniformType.FLOAT, 1), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialTerrainMap.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialTerrainMap.prototype.getFragmentShader = function () {
            return "\n\n\t\t\t\tuniform float timeConst;\n\t\t\t\tuniform vec2 resolution;\n\n\t\t\t\t// to be changed by the user\n\t\t\t\tuniform vec3 colorSnow;\n\t\t\t\tuniform vec3 colorRock;\n\t\t\t\tuniform vec3 colorVegetation;\n\t\t\t\tuniform vec3 colorDirt;\n\t\t\t\tuniform vec3 colorWater;\n\t\t\t\tuniform float seed;\n\t\t\t\tuniform float waterVal;\n\t\t\t\tuniform float snowThreshhold;\n\t\t\t\tuniform float terrainScale;\n\t\t\t\tuniform float heightBias;\n\t\t\t\tuniform float heightColors;\n\n\t\t\t\tvec3 draw_terrain( in vec2 vertex );\n\n\t\t\t\tvoid main(void)\n\t\t\t\t{\n\t\t\t\t\tfloat rmin = min(resolution.x, resolution.y);\n\t\t\t\t\tvec2 position  = ((gl_FragCoord.xy - 0.5 * resolution.xy) / rmin);\n\t\t\t\t\tposition.x += seed;\n\t\t\t\t\tposition.y += seed;\n\t\t\t\t\tgl_FragColor = vec4(draw_terrain(position), 1.0);\n\t\t\t\t}\n\n\t\t\t\t// ****************** SIMPLEX NOISE ************************\n\n\t\t\t\tvec3 mod289(in vec3 x)\n\t\t\t\t{\n\t\t\t\t\treturn x - floor(x * 1.0 / 289.0) * 289.0;\n\t\t\t\t}\n\n\t\t\t\tvec3 permute(in vec3 x)\n\t\t\t\t{\n\t\t\t\t\treturn mod289(((x * 34.0) + 1.0) * x);\n\t\t\t\t}\n\n\t\t\t\tfloat simplex(in vec2 v)\n\t\t\t\t{\n\t\t\t\t\tvec4 C = vec4(\n\t\t\t\t\t0.211324865405187,  // (3.0 -  sqrt(3.0)) / 6.0\n\t\t\t\t\t0.366025403784439,  //  0.5 * (sqrt(3.0)  - 1.0)\n\t\t\t\t\t-0.577350269189626,\t // -1.0 + 2.0 * C.x\n\t\t\t\t\t0.024390243902439); //  1.0 / 41.0\n\n\t\t\t\t\t// First corner\n\t\t\t\t\tvec2 i  = floor(v + dot(v, C.yy));\n\t\t\t\t\tvec2 x0 = v - i + dot(i, C.xx);\n\n\t\t\t\t\t// Other corners\n\t\t\t\t\tvec2 i1 = (x0.x > x0.y) ? vec2(1, 0) : vec2(0, 1);\n\t\t\t\t\tvec4 x12 = x0.xyxy + C.xxzz;\n\t\t\t\t\tx12 = vec4(x12.xy - i1, x12.z, x12.w);\n\n\t\t\t\t\t// Permutations\n\t\t\t\t\ti = mod(i, vec2(289)); // Avoid truncation effects in permutation\n\t\t\t\t\tvec3 p = permute(permute(i.y + vec3(0, i1.y, 1)) + i.x + vec3(0, i1.x, 1));\n\t\t\t\t\tvec3 m = max(vec3(0.5) - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), vec3(0));\n\t\t\t\t\tm = m * m;\n\t\t\t\t\tm = m * m;\n\n\t\t\t\t\t// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n\t\t\t\t\t// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\t\t\t\t\tvec3 x = 2.0 * fract(p * C.w) - 1.0;\n\t\t\t\t\tvec3 h = abs(x) - 0.5;\n\t\t\t\t\tvec3 ox = floor(x + 0.5);\n\t\t\t\t\tvec3 a0 = x - ox;\n\n\t\t\t\t\t// Normalise gradients implicitly by scaling m\n\t\t\t\t\t// Inlined for speed: m *= taylorInvSqrt(a0*a0 + h*h);\n\t\t\t\t\tm *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n\n\t\t\t\t\t// Compute final noise value at P\n\t\t\t\t\tvec3 g;\n\t\t\t\t\tg.x = a0.x * x0.x + h.x * x0.y;\n\t\t\t\t\tg.yz = a0.yz * x12.xz + h.yz * x12.yw;\n\t\t\t\t\treturn 130.0 * dot(m, g);\n\t\t\t\t}\n\n\n\t\t\t\t// ****************** PROCEDURAL TERRAIN ************************\n\n\t\t\t\tfloat eval_terrain_noise_base(in vec2 npos, const in float gain, const in float lacunarity)\n\t\t\t\t{\n\t\t\t\t\tfloat val  = 0.0;\n\t\t\t\t\tfloat mag  = 1.0;\n\t\t\t\t\tfloat freq = 0.5; // lower freq for ridged noise\n\n\t\t\t\t\tfor (int i = 0; i < NUM_OCTAVES; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\t// similar to gen_cloud_alpha_time()\n\t\t\t\t\t\tfloat v = simplex(freq * npos);\n\t\t\t\t\t\tv = 2.0 * v - 1.0; // map [0,1] range to [-1,1]\n\t\t\t\t\t\tv = max(0.0,(0.75 - abs(v))); // ridged noise\n\t\t\t\t\t\tval += v * mag;\n\t\t\t\t\t\tfreq *= lacunarity;\n\t\t\t\t\t\tmag *= gain;\n\t\t\t\t\t}\n\t\t\t\t\treturn val + heightBias;\n\t\t\t\t}\n\n\t\t\t\tfloat eval_terrain_noise(in vec2 npos)\n\t\t\t\t{\n\t\t\t\t\treturn 0.7 * eval_terrain_noise_base(npos, 0.7, 2.0);\n\t\t\t\t}\n\n\t\t\t\tfloat eval_terrain_noise_detail(in vec2 npos)\n\t\t\t\t{\n\t\t\t\t\treturn eval_terrain_noise_base(npos, 0.5, 1.92);\n\t\t\t\t}\n\n\t\t\t\tvec3 draw_terrain( in vec2 vertex )\n\t\t\t\t{\n\t\t\t\t\tvec2 spos    = vertex * terrainScale;\n\t\t\t\t\tfloat hval   = eval_terrain_noise(spos);\n\t\t\t\t\tfloat height = max(0.0, 1.8 * (hval - 0.7)); // can go outside the [0,1] range\n\t\t\t\t\tfloat nscale = 0.0;\n\t\t\t\t\tvec4 texel = vec4(1.0,1.0,1.0,1.0);\n\n\t\t\t\t\tif (heightColors === 1.0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tif (height < waterVal)\n\t\t\t\t\t\t\ttexel.rgb = colorWater;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Earthlike planet\n\t\t\t\t\t\t\tnscale = 1.0;\n\t\t\t\t\t\t\tfloat height_ws = (height - waterVal) / (1.0 - waterVal); // rescale to [0,1] above water\n\n\t\t\t\t\t\t\tif (height_ws < 0.1) { texel.rgb = colorDirt; } // low ground\n\t\t\t\t\t\t\telse if (height_ws < 0.4) { texel.rgb = mix(colorDirt, colorVegetation, 3.3333 * (height_ws - 0.1)); }\n\t\t\t\t\t\t\telse if (height_ws < 0.5) { texel.rgb = colorVegetation; } // medium ground\n\t\t\t\t\t\t\telse if (height_ws < 1.0) { texel.rgb = mix(colorVegetation, colorRock, 2.0 * (height_ws - 0.5)); }\n\t\t\t\t\t\t\telse { texel.rgb = colorRock; } // high ground\n\t\t\t\t\t\t\tif (waterVal > 0.0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// handle water\n\t\t\t\t\t\t\t\tif (height < waterVal + 0.07)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// close to water line (can have a little water even if water === 0)\n\t\t\t\t\t\t\t\t\tfloat val = (height - waterVal) / 0.07;\n\t\t\t\t\t\t\t\t\ttexel.rgb = mix(colorWater, texel.rgb, val);\n\t\t\t\t\t\t\t\t\tnscale = val * val; // faster falloff\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (height_ws > 1.0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfloat sv = 0.5 + 0.5 * clamp(20.0 * (1.0 - snowThreshhold), 0.0, 1.0);\n\t\t\t\t\t\t\t\t\tfloat mv = eval_terrain_noise_detail(32.0 * spos) * sv * sqrt(height_ws - 1.0);\n\t\t\t\t\t\t\t\t\tfloat mag= 0.5 * clamp((1.5 * mv * mv - 0.25), 0.0, 1.0);\n\t\t\t\t\t\t\t\t\ttexel = mix(texel, vec4(colorSnow, 1), mag); // blend in some snow on peaks\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\treturn vec3(height, height, height);\n\n\t\t\t\t\treturn texel.rgb;\n\t\t\t\t}\n\t\t\t";
        };
        Object.defineProperty(MaterialTerrainMap.prototype, "colorSnow", {
            /**
            * Gets the color of snow
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['colorSnow'].value; },
            /**
            * Sets the color of snow
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('colorSnow', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialTerrainMap.prototype, "colorWater", {
            /**
            * Gets the color of water
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['colorWater'].value; },
            /**
            * Sets the color of water
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('colorWater', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialTerrainMap.prototype, "colorRock", {
            /**
            * Gets the color of rock
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['colorRock'].value; },
            /**
            * Sets the color of rock
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('colorRock', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialTerrainMap.prototype, "colorDirt", {
            /**
            * Gets the color of dirt
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['colorDirt'].value; },
            /**
            * Sets the color of dirt
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('colorDirt', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialTerrainMap.prototype, "colorVegetation", {
            /**
            * Gets the color of vegetation
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['colorVegetation'].value; },
            /**
            * Sets the color of vegetation
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('colorVegetation', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialTerrainMap.prototype, "seed", {
            /**
            * Gets the seed
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['seed'].value; },
            /**
            * Sets the seed
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('seed', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialTerrainMap.prototype, "snowThreshhold", {
            /**
            * Gets the snow threshold
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['snowThreshhold'].value; },
            /**
            * Sets the snow threshold
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('snowThreshhold', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialTerrainMap.prototype, "waterVal", {
            /**
            * Gets the water rise value
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['waterVal'].value; },
            /**
            * Sets the water rise value
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('waterVal', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialTerrainMap.prototype, "numOctaves", {
            /**
            * Gets the number of octaves to use.
            * @returns {number}
            */
            get: function () { return this._numOctaves; },
            /**
            * Sets the number of octaves to use.
            * @param {number} val
            */
            set: function (val) {
                this.removeDefine('#define NUM_OCTAVES ' + this._numOctaves.toFixed(0));
                this._numOctaves = val;
                this.addDefine('#define NUM_OCTAVES ' + this._numOctaves.toFixed(0));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialTerrainMap.prototype, "terrainScale", {
            /**
            * Gets the terrain scale
            * @returns {number}
            */
            get: function () { return this._uniforms['terrainScale'].value; },
            /**
            * Sets the terrain scale
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('terrainScale', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialTerrainMap.prototype, "heightBias", {
            /**
            * Gets the terrain bias
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['heightBias'].value; },
            /**
            * Sets the terrain height bias
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('heightBias', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialTerrainMap.prototype, "heightColors", {
            /**
            * Gets if the colors are drawn or simply the height map
            * @returns {boolean}
            */
            get: function () { return (this._uniforms['heightColors'].value === 1 ? true : false); },
            /**
            * Sets if the colors are drawn or simply the height map
            * @param {boolean} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('heightColors', (val ? 1 : 0)); },
            enumerable: true,
            configurable: true
        });
        return MaterialTerrainMap;
    }(Trike.MaterialMulti));
    Trike.MaterialTerrainMap = MaterialTerrainMap;
})(Trike || (Trike = {}));
var Trike;
(function (Trike) {
    /**
    * Draws an animated heightmap that resembles ocean noise
    */
    var MaterialOceanNoise = (function (_super) {
        __extends(MaterialOceanNoise, _super);
        /**
        * Creates an instance of the shader
        * @param {number} width The width of the texture
        * @param {number} height The height of the texture
        */
        function MaterialOceanNoise(width, height) {
            // Call the material base
            _super.call(this, Trike.MultiMaterialOptions.None);
            this.materials[Trike.PassType.Texture] = new Trike.PassMaterial('Ocean Noise', this);
            // Define the common uniforms of the material
            this.addUniform(new Trike.UniformVar('timeConst', Trike.UniformType.FLOAT, 0), true);
            this.addUniform(new Trike.UniformVar('resolution', Trike.UniformType.FLOAT2, new Trike.Vec2(width, height)), true);
            this.addUniform(new Trike.UniformVar('color', Trike.UniformType.COLOR3, new Trike.Color(0xffffff), true));
            this.addUniform(new Trike.UniformVar('period', Trike.UniformType.FLOAT, 0.1), true);
            this.addUniform(new Trike.UniformVar('frequency', Trike.UniformType.FLOAT, 0.3), true);
            this.addUniform(new Trike.UniformVar('height', Trike.UniformType.FLOAT, 0.5), true);
            this.addUniform(new Trike.UniformVar('choppiness', Trike.UniformType.FLOAT, 1.5), true);
            // Define the attributes sent from the buffers
            this.addAttribute(new Trike.AttributeVar('position', Trike.AttributeType.POSITION));
            this.addAttribute(new Trike.AttributeVar('surface', Trike.AttributeType.SURFACE));
            // Any define macros
            this.addDefine(Trike.ShaderDefines.ATTR_POSITION);
            this.setShaders(this.getVertexShader(), this.getFragmentShader());
            this.depthWrite = false;
            this.depthRead = false;
        }
        /**
        * Create the vertex shader
        * @returns {string}
        */
        MaterialOceanNoise.prototype.getVertexShader = function () {
            return "\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 surface;\n\t\t\t\tvarying vec2 vSurface;\n\n\t\t\t\tvoid main()\n\t\t\t\t{\n\t\t\t\t\tvSurface = surface;\n\t\t\t\t\tgl_Position = vec4( sign( position.xy ), 0.0, 1.0 );\n\t\t\t\t}\n\t\t\t\t";
        };
        /**
        * Create the fragment shader
        * @returns {string}
        */
        MaterialOceanNoise.prototype.getFragmentShader = function () {
            return "\n\t\t\t\tuniform float timeConst;\n\t\t\t\tuniform vec3 color;\n\t\t\t\tuniform vec2 resolution;\n\t\t\t\tuniform float period;\n\t\t\t\tuniform float height;\n\t\t\t\tuniform float choppiness;\n\t\t\t\tuniform float frequency;\n\t\t\t\tvarying vec2 vSurface;\n\t\t\t\tconst int ITER_FRAGMENT = 5;\n\n\t\t\t\tfloat hash(vec2 p )\n\t\t\t\t{\n\t\t\t\t\tfloat h = dot(p, vec2(127.1, 311.7));\n\t\t\t\t\treturn fract(sin(h) * 43758.5453123);\n\t\t\t\t}\n\n\t\t\t\tfloat noise( in vec2 p )\n\t\t\t\t{\n\t\t\t\t\tvec2 i = floor(p);\n\t\t\t\t\tvec2 f = fract(p);\n\t\t\t\t\tvec2 u = f * f * (3.0 - 2.0 * f);\n\t\t\t\t\treturn -1.0 + 2.0 * mix(mix(hash(i + vec2(0.0, 0.0)),\n\t\t\t\t\thash(i + vec2(1.0, 0.0)), u.x),\n\t\t\t\t\tmix(hash(i + vec2(0.0, 1.0)),\n\t\t\t\t\thash(i + vec2(1.0, 1.0)), u.x), u.y);\n\t\t\t\t}\n\n\t\t\t\t// sea\n\t\t\t\tfloat sea_octave(vec2 uv, float choppy)\n\t\t\t\t{\n\t\t\t\t\tuv += noise(uv);\n\t\t\t\t\tvec2 wv = 1.0 - abs(sin(uv));\n\t\t\t\t\tvec2 swv = abs(cos(uv));\n\t\t\t\t\twv = mix(wv, swv, wv);\n\t\t\t\t\treturn pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);\n\t\t\t\t}\n\n\n\t\t\t\t// main\n\t\t\t\tvoid main(void)\n\t\t\t\t{\n\t\t\t\t\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\t\t\t\t\tuv = uv * 2.0 - 1.0;\n\t\t\t\t\tuv.x *= resolution.x / resolution.y;\n\t\t\t\t\tuv *= 1.;\n\t\t\t\t\tfloat t = timeConst + length (vSurface)/sin(length (vSurface)*1e-1) * 1.0;\n\t\t\t\t\tvec3 p = vec3(0.0, 3.5, t * 5.0);\n\t\t\t\t\tfloat freq = frequency * 5.0;\n\t\t\t\t\tfloat amp = height * 1.0;\n\t\t\t\t\tfloat choppy = choppiness * 2.0;\n\t\t\t\t\tvec2 uv2 = p.xz; uv.x *= 0.75;\n\t\t\t\t\tmat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n\n\t\t\t\t\tfloat d, h = 0.0;\n\t\t\t\t\tfor(int i = 0; i < ITER_FRAGMENT; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\td = sea_octave((uv + t * period) * freq, choppy);\n\t\t\t\t\t\td += sea_octave((uv - t * period) * freq, choppy);\n\t\t\t\t\t\th += d * amp;\n\t\t\t\t\t\tuv *= m; freq *= 1.9; amp *= 0.22;\n\t\t\t\t\t\tchoppy = mix(choppy, 1.0, 0.2);\n\t\t\t\t\t}\n\n\t\t\t\t\tgl_FragColor = vec4(h, h, h, 1.0);\n\t\t\t\t\tgl_FragColor.rgb *= color;\n\t\t\t\t}\n\t\t\t";
        };
        Object.defineProperty(MaterialOceanNoise.prototype, "color", {
            /**
            * Gets the color
            * @returns {Color}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['color'].value; },
            /**
            * Sets the color
            * @param {Color} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('color', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialOceanNoise.prototype, "period", {
            /**
            * Gets the period
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['period'].value; },
            /**
            * Sets the period
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('period', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialOceanNoise.prototype, "frequency", {
            /**
            * Gets the frequency
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['frequency'].value; },
            /**
            * Sets the frequency
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('frequency', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialOceanNoise.prototype, "height", {
            /**
            * Gets the height
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['height'].value; },
            /**
            * Sets the height
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('height', val); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MaterialOceanNoise.prototype, "choppiness", {
            /**
            * Gets the choppiness
            * @returns {number}
            */
            get: function () { return this.materials[Trike.PassType.Texture]._uniforms['choppiness'].value; },
            /**
            * Sets the choppiness
            * @param {number} val
            */
            set: function (val) { this.materials[Trike.PassType.Texture].setUniform('choppiness', val); },
            enumerable: true,
            configurable: true
        });
        return MaterialOceanNoise;
    }(Trike.MaterialMulti));
    Trike.MaterialOceanNoise = MaterialOceanNoise;
})(Trike || (Trike = {}));
